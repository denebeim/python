[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "version_info",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "colorama",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "colorama",
        "description": "colorama",
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "dataclasses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dataclasses",
        "description": "dataclasses",
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "TemporaryFile",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "ansible",
        "description": "ansible",
        "isExtraImport": true,
        "detail": "ansible",
        "documentation": {}
    },
    {
        "label": "ActionBase",
        "importPath": "ansible.plugins.action",
        "description": "ansible.plugins.action",
        "isExtraImport": true,
        "detail": "ansible.plugins.action",
        "documentation": {}
    },
    {
        "label": "merge_hash",
        "importPath": "ansible.utils.vars",
        "description": "ansible.utils.vars",
        "isExtraImport": true,
        "detail": "ansible.utils.vars",
        "documentation": {}
    },
    {
        "label": "unscramble",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "generate_insecure_key",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "scramble",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "scramble",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "unscramble",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "fcntl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fcntl",
        "description": "fcntl",
        "detail": "fcntl",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleFileNotFound",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleFileNotFound",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleConnectionFailure",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleConnectionFailure",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleConnectionFailure",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleParserError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "AnsibleParserError",
        "importPath": "ansible.errors",
        "description": "ansible.errors",
        "isExtraImport": true,
        "detail": "ansible.errors",
        "documentation": {}
    },
    {
        "label": "shlex_quote",
        "importPath": "ansible.module_utils.six.moves",
        "description": "ansible.module_utils.six.moves",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six.moves",
        "documentation": {}
    },
    {
        "label": "shlex_quote",
        "importPath": "ansible.module_utils.six.moves",
        "description": "ansible.module_utils.six.moves",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six.moves",
        "documentation": {}
    },
    {
        "label": "get_bin_path",
        "importPath": "ansible.module_utils.common.process",
        "description": "ansible.module_utils.common.process",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.process",
        "documentation": {}
    },
    {
        "label": "get_bin_path",
        "importPath": "ansible.module_utils.common.process",
        "description": "ansible.module_utils.common.process",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.process",
        "documentation": {}
    },
    {
        "label": "get_bin_path",
        "importPath": "ansible.module_utils.common.process",
        "description": "ansible.module_utils.common.process",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.process",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils.common.text.converters",
        "description": "ansible.module_utils.common.text.converters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.converters",
        "documentation": {}
    },
    {
        "label": "ConnectionBase",
        "importPath": "ansible.plugins.connection",
        "description": "ansible.plugins.connection",
        "isExtraImport": true,
        "detail": "ansible.plugins.connection",
        "documentation": {}
    },
    {
        "label": "BUFSIZE",
        "importPath": "ansible.plugins.connection",
        "description": "ansible.plugins.connection",
        "isExtraImport": true,
        "detail": "ansible.plugins.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionBase",
        "importPath": "ansible.plugins.connection",
        "description": "ansible.plugins.connection",
        "isExtraImport": true,
        "detail": "ansible.plugins.connection",
        "documentation": {}
    },
    {
        "label": "ConnectionBase",
        "importPath": "ansible.plugins.connection",
        "description": "ansible.plugins.connection",
        "isExtraImport": true,
        "detail": "ansible.plugins.connection",
        "documentation": {}
    },
    {
        "label": "Display",
        "importPath": "ansible.utils.display",
        "description": "ansible.utils.display",
        "isExtraImport": true,
        "detail": "ansible.utils.display",
        "documentation": {}
    },
    {
        "label": "Display",
        "importPath": "ansible.utils.display",
        "description": "ansible.utils.display",
        "isExtraImport": true,
        "detail": "ansible.utils.display",
        "documentation": {}
    },
    {
        "label": "Display",
        "importPath": "ansible.utils.display",
        "description": "ansible.utils.display",
        "isExtraImport": true,
        "detail": "ansible.utils.display",
        "documentation": {}
    },
    {
        "label": "Display",
        "importPath": "ansible.utils.display",
        "description": "ansible.utils.display",
        "isExtraImport": true,
        "detail": "ansible.utils.display",
        "documentation": {}
    },
    {
        "label": "Display",
        "importPath": "ansible.utils.display",
        "description": "ansible.utils.display",
        "isExtraImport": true,
        "detail": "ansible.utils.display",
        "documentation": {}
    },
    {
        "label": "Display",
        "importPath": "ansible.utils.display",
        "description": "ansible.utils.display",
        "isExtraImport": true,
        "detail": "ansible.utils.display",
        "documentation": {}
    },
    {
        "label": "selectors",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "description": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "documentation": {}
    },
    {
        "label": "selectors",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "description": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "documentation": {}
    },
    {
        "label": "selectors",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "description": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "documentation": {}
    },
    {
        "label": "selectors",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "description": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.selectors",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "StrictVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.version",
        "description": "ansible_collections.community.docker.plugins.module_utils.version",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClientBase",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "DockerFileCopyError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "DockerFileNotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "fetch_file",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "put_file",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "DockerFileCopyError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "DockerFileNotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "DockerUnexpectedError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "determine_user_group",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "fetch_file_ex",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "put_file",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "put_file_content",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "stat_file",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "_stream_generator_to_fileobj",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "ansible_collections.community.docker.plugins.module_utils.copy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "DockerSocketHandler",
        "importPath": "ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "description": "ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "description": "ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "MissingRequirementException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "TLSParameterError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "create_unexpected_kwargs_error",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "create_api_error_from_http_exception",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "pty",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pty",
        "description": "pty",
        "detail": "pty",
        "documentation": {}
    },
    {
        "label": "ansible.constants",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ansible.constants",
        "description": "ansible.constants",
        "detail": "ansible.constants",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY3",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "iteritems",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "raise_from",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY3",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY3",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY3",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY3",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY3",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "integer_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "iteritems",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "iteritems",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "raise_from",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "raise_from",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "raise_from",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "iteritems",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY2",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "PY3",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "ansible.module_utils.six",
        "description": "ansible.module_utils.six",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six",
        "documentation": {}
    },
    {
        "label": "unfrackpath",
        "importPath": "ansible.utils.path",
        "description": "ansible.utils.path",
        "isExtraImport": true,
        "detail": "ansible.utils.path",
        "documentation": {}
    },
    {
        "label": "BaseInventoryPlugin",
        "importPath": "ansible.plugins.inventory",
        "description": "ansible.plugins.inventory",
        "isExtraImport": true,
        "detail": "ansible.plugins.inventory",
        "documentation": {}
    },
    {
        "label": "Constructable",
        "importPath": "ansible.plugins.inventory",
        "description": "ansible.plugins.inventory",
        "isExtraImport": true,
        "detail": "ansible.plugins.inventory",
        "documentation": {}
    },
    {
        "label": "BaseInventoryPlugin",
        "importPath": "ansible.plugins.inventory",
        "description": "ansible.plugins.inventory",
        "isExtraImport": true,
        "detail": "ansible.plugins.inventory",
        "documentation": {}
    },
    {
        "label": "Constructable",
        "importPath": "ansible.plugins.inventory",
        "description": "ansible.plugins.inventory",
        "isExtraImport": true,
        "detail": "ansible.plugins.inventory",
        "documentation": {}
    },
    {
        "label": "Cacheable",
        "importPath": "ansible.plugins.inventory",
        "description": "ansible.plugins.inventory",
        "isExtraImport": true,
        "detail": "ansible.plugins.inventory",
        "documentation": {}
    },
    {
        "label": "BaseInventoryPlugin",
        "importPath": "ansible.plugins.inventory",
        "description": "ansible.plugins.inventory",
        "isExtraImport": true,
        "detail": "ansible.plugins.inventory",
        "documentation": {}
    },
    {
        "label": "Constructable",
        "importPath": "ansible.plugins.inventory",
        "description": "ansible.plugins.inventory",
        "isExtraImport": true,
        "detail": "ansible.plugins.inventory",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS_VARS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "update_tls_hostname",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_generic",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "normalize_healthcheck",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "omit_none_from_dict",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "normalize_healthcheck_test",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "omit_none_from_dict",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DifferenceTracker",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_generic",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "sanitize_result",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# noqa: F401",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "pylint: disable=unused-import\n    DEFAULT_DOCKER_HOST",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS_VERIFY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS_HOSTNAME",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    DEFAULT_TIMEOUT_SECONDS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS_VARS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    DOCKER_MUTUALLY_EXCLUSIVE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_REQUIRED_TOGETHER",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_REGISTRY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    BYTE_SUFFIXES",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    sanitize_result",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    update_tls_hostname",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_dict_allow_more_present",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    compare_generic",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    DifferenceTracker",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    convert_duration_to_nanosecond",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    parse_healthcheck",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    omit_none_from_dict",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# noqa: F401",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "pylint: disable=unused-import\n    DEFAULT_DOCKER_HOST",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS_VERIFY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS_HOSTNAME",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    DEFAULT_TIMEOUT_SECONDS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_MUTUALLY_EXCLUSIVE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_REQUIRED_TOGETHER",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_REGISTRY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# TODO: remove\n    sanitize_result",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "update_tls_hostname",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "# noqa: F401",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "pylint: disable=unused-import\n    DEFAULT_DOCKER_HOST",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS_VERIFY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_MUTUALLY_EXCLUSIVE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_REQUIRED_TOGETHER",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "sanitize_result",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_generic",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_REGISTRY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DifferenceTracker",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DifferenceTracker",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_generic",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DifferenceTracker",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DifferenceTracker",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "convert_duration_to_nanosecond",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "parse_healthcheck",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DifferenceTracker",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_dict_allow_more_present",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_generic",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "convert_duration_to_nanosecond",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "parse_healthcheck",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.util",
        "description": "ansible_collections.community.docker.plugins.module_utils.util",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "make_unsafe",
        "importPath": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "make_unsafe",
        "importPath": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "make_unsafe",
        "importPath": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "make_unsafe",
        "importPath": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "parse_filters",
        "importPath": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "isExtraImport": true,
        "detail": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "filter_host",
        "importPath": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "isExtraImport": true,
        "detail": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "parse_filters",
        "importPath": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "isExtraImport": true,
        "detail": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "filter_host",
        "importPath": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "isExtraImport": true,
        "detail": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "parse_filters",
        "importPath": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "isExtraImport": true,
        "detail": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "filter_host",
        "importPath": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "isExtraImport": true,
        "detail": "ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "get_connect_params",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "RequestException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClientBase",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common",
        "description": "ansible_collections.community.docker.plugins.module_utils.common",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "parse_address",
        "importPath": "ansible.parsing.utils.addresses",
        "description": "ansible.parsing.utils.addresses",
        "isExtraImport": true,
        "detail": "ansible.parsing.utils.addresses",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "ansible.module_utils.six.moves.urllib.parse",
        "description": "ansible.module_utils.six.moves.urllib.parse",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six.moves.urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "ansible.module_utils.six.moves.urllib.parse",
        "description": "ansible.module_utils.six.moves.urllib.parse",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six.moves.urllib.parse",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "ansible.module_utils.six.moves.queue",
        "description": "ansible.module_utils.six.moves.queue",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six.moves.queue",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "ansible.module_utils.six.moves.queue",
        "description": "ansible.module_utils.six.moves.queue",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six.moves.queue",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "ansible.module_utils.six.moves.urllib_parse",
        "description": "ansible.module_utils.six.moves.urllib_parse",
        "isExtraImport": true,
        "detail": "ansible.module_utils.six.moves.urllib_parse",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "json.decoder",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json.decoder",
        "description": "json.decoder",
        "detail": "json.decoder",
        "documentation": {}
    },
    {
        "label": "select",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "select",
        "description": "select",
        "detail": "select",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "ssl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ssl",
        "description": "ssl",
        "detail": "ssl",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "human_to_bytes",
        "importPath": "ansible.module_utils.common.text.formatters",
        "description": "ansible.module_utils.common.text.formatters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.formatters",
        "documentation": {}
    },
    {
        "label": "human_to_bytes",
        "importPath": "ansible.module_utils.common.text.formatters",
        "description": "ansible.module_utils.common.text.formatters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.formatters",
        "documentation": {}
    },
    {
        "label": "human_to_bytes",
        "importPath": "ansible.module_utils.common.text.formatters",
        "description": "ansible.module_utils.common.text.formatters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.formatters",
        "documentation": {}
    },
    {
        "label": "human_to_bytes",
        "importPath": "ansible.module_utils.common.text.formatters",
        "description": "ansible.module_utils.common.text.formatters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.formatters",
        "documentation": {}
    },
    {
        "label": "human_to_bytes",
        "importPath": "ansible.module_utils.common.text.formatters",
        "description": "ansible.module_utils.common.text.formatters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.formatters",
        "documentation": {}
    },
    {
        "label": "human_to_bytes",
        "importPath": "ansible.module_utils.common.text.formatters",
        "description": "ansible.module_utils.common.text.formatters",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.text.formatters",
        "documentation": {}
    },
    {
        "label": "compare_platform_strings",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "ansible_collections.community.docker.plugins.module_utils._platform",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "compose_platform_string",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "ansible_collections.community.docker.plugins.module_utils._platform",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "normalize_platform_string",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "ansible_collections.community.docker.plugins.module_utils._platform",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "normalize_platform_string",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "ansible_collections.community.docker.plugins.module_utils._platform",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "compare_platform_strings",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "ansible_collections.community.docker.plugins.module_utils._platform",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "compose_platform_string",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "ansible_collections.community.docker.plugins.module_utils._platform",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "parse_env_file",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_port_bindings",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "normalize_links",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_filters",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "format_environment",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_filters",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "format_extra_hosts",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_filters",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_filters",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_volume_binds",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "decode_json_header",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "kwargs_from_env",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_bytes",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_devices",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_env_file",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_host",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "split_command",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "format_environment",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "OPTION_AUTO_REMOVE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_BLKIO_WEIGHT",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CAPABILITIES",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CAP_DROP",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CGROUP_NS_MODE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CGROUP_PARENT",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_COMMAND",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPU_PERIOD",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPU_QUOTA",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPUSET_CPUS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPUSET_MEMS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPU_SHARES",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ENTRYPOINT",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPUS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DETACH_INTERACTIVE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICES",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_READ_BPS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_WRITE_BPS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_READ_IOPS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_WRITE_IOPS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_REQUESTS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_CGROUP_RULES",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DNS_SERVERS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DNS_OPTS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DNS_SEARCH_DOMAINS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DOMAINNAME",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ENVIRONMENT",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ETC_HOSTS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_GROUPS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_HEALTHCHECK",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_HOSTNAME",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_IMAGE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_INIT",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_IPC_MODE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_KERNEL_MEMORY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_LABELS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_LINKS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_LOG_DRIVER_OPTIONS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MAC_ADDRESS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY_RESERVATION",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY_SWAP",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY_SWAPPINESS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_STOP_TIMEOUT",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_NETWORK",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_OOM_KILLER",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_OOM_SCORE_ADJ",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PID_MODE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PIDS_LIMIT",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PLATFORM",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PRIVILEGED",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_READ_ONLY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_RESTART_POLICY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_RUNTIME",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_SECURITY_OPTS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_SHM_SIZE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_STOP_SIGNAL",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_STORAGE_OPTS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_SYSCTLS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_TMPFS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_TTY",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ULIMITS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_USER",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_USERNS_MODE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_UTS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_VOLUME_DRIVER",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_VOLUMES_FROM",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_WORKING_DIR",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MOUNTS_VOLUMES",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PORTS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTIONS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "Engine",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "EngineDriver",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "AnsibleModule",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "missing_required_lib",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "AnsibleModule",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "missing_required_lib",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "AnsibleModule",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "env_fallback",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "missing_required_lib",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "env_fallback",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "AnsibleModule",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "human_to_bytes",
        "importPath": "ansible.module_utils.basic",
        "description": "ansible.module_utils.basic",
        "isExtraImport": true,
        "detail": "ansible.module_utils.basic",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "ansible.module_utils.common._collections_compat",
        "description": "ansible.module_utils.common._collections_compat",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common._collections_compat",
        "documentation": {}
    },
    {
        "label": "BOOLEANS_TRUE",
        "importPath": "ansible.module_utils.parsing.convert_bool",
        "description": "ansible.module_utils.parsing.convert_bool",
        "isExtraImport": true,
        "detail": "ansible.module_utils.parsing.convert_bool",
        "documentation": {}
    },
    {
        "label": "BOOLEANS_FALSE",
        "importPath": "ansible.module_utils.parsing.convert_bool",
        "description": "ansible.module_utils.parsing.convert_bool",
        "isExtraImport": true,
        "detail": "ansible.module_utils.parsing.convert_bool",
        "documentation": {}
    },
    {
        "label": "BOOLEANS_TRUE",
        "importPath": "ansible.module_utils.parsing.convert_bool",
        "description": "ansible.module_utils.parsing.convert_bool",
        "isExtraImport": true,
        "detail": "ansible.module_utils.parsing.convert_bool",
        "documentation": {}
    },
    {
        "label": "BOOLEANS_FALSE",
        "importPath": "ansible.module_utils.parsing.convert_bool",
        "description": "ansible.module_utils.parsing.convert_bool",
        "isExtraImport": true,
        "detail": "ansible.module_utils.parsing.convert_bool",
        "documentation": {}
    },
    {
        "label": "boolean",
        "importPath": "ansible.module_utils.parsing.convert_bool",
        "description": "ansible.module_utils.parsing.convert_bool",
        "isExtraImport": true,
        "detail": "ansible.module_utils.parsing.convert_bool",
        "documentation": {}
    },
    {
        "label": "auth",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "auth",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "auth",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "errors",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "constants",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "auth",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "errors",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api",
        "description": "ansible_collections.community.docker.plugins.module_utils._api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api",
        "documentation": {}
    },
    {
        "label": "APIClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "documentation": {}
    },
    {
        "label": "APIClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "documentation": {}
    },
    {
        "label": "APIClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "documentation": {}
    },
    {
        "label": "APIClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "documentation": {}
    },
    {
        "label": "TLSConfig",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.tls",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.tls",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.tls",
        "documentation": {}
    },
    {
        "label": "resolve_repository_name",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "get_config_header",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "resolve_repository_name",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "get_config_header",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "resolve_repository_name",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "decode_auth",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "InvalidLogFmt",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "parse_line",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "InvalidLogFmt",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "parse_line",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "socket",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils",
        "documentation": {}
    },
    {
        "label": "make_unblocking",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "shutdown_writing",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "write_to_socket",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "is_sequence",
        "importPath": "ansible.module_utils.common.collections",
        "description": "ansible.module_utils.common.collections",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.collections",
        "documentation": {}
    },
    {
        "label": "is_sequence",
        "importPath": "ansible.module_utils.common.collections",
        "description": "ansible.module_utils.common.collections",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.collections",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "check_type_int",
        "importPath": "ansible.module_utils.common.validation",
        "description": "ansible.module_utils.common.validation",
        "isExtraImport": true,
        "detail": "ansible.module_utils.common.validation",
        "documentation": {}
    },
    {
        "label": "AnsibleModuleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "AnsibleModuleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "AnsibleModuleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "AnsibleModuleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "AnsibleModuleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "AnsibleModuleDockerClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "BaseComposeManager",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "common_compose_argspec_ex",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "is_failed",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "BaseComposeManager",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "common_compose_argspec_ex",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "parse_events",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "DockerAPIEngineDriver",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "documentation": {}
    },
    {
        "label": "run_module",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "description": "ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "importPath": "ansible.module_utils._text",
        "description": "ansible.module_utils._text",
        "isExtraImport": true,
        "detail": "ansible.module_utils._text",
        "documentation": {}
    },
    {
        "label": "to_native",
        "importPath": "ansible.module_utils._text",
        "description": "ansible.module_utils._text",
        "isExtraImport": true,
        "detail": "ansible.module_utils._text",
        "documentation": {}
    },
    {
        "label": "to_text",
        "importPath": "ansible.module_utils._text",
        "description": "ansible.module_utils._text",
        "isExtraImport": true,
        "detail": "ansible.module_utils._text",
        "documentation": {}
    },
    {
        "label": "DockerSocketHandlerModule",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "description": "ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "DockerSocketHandlerBase",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "description": "ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "archived_image_manifest",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "api_image_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "ImageArchiveInvalidException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "load_archived_image_manifest",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "api_image_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "ImageArchiveInvalidException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "api_image_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "archived_image_manifest",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "ImageArchiveInvalidException",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "api_image_id",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DATA_CHUNK_SIZE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "CONTAINER_LIMITS_KEYS",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DATA_CHUNK_SIZE",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_API_VERSION",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS_PLATFORM",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_API_VERSION",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS_PLATFORM",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_API_VERSION",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "process_dockerfile",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "tar",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "exclude_paths",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "tar",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "CredentialsNotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "documentation": {}
    },
    {
        "label": "CredentialsNotFound",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "documentation": {}
    },
    {
        "label": "Store",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "documentation": {}
    },
    {
        "label": "Store",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerSwarmClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "description": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerSwarmClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "description": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerSwarmClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "description": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerSwarmClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "description": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerSwarmClient",
        "importPath": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "description": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils.swarm",
        "documentation": {}
    },
    {
        "label": "AnsibleUnsafe",
        "importPath": "ansible.utils.unsafe_proxy",
        "description": "ansible.utils.unsafe_proxy",
        "isExtraImport": true,
        "detail": "ansible.utils.unsafe_proxy",
        "documentation": {}
    },
    {
        "label": "wrap_var",
        "importPath": "ansible.utils.unsafe_proxy",
        "description": "ansible.utils.unsafe_proxy",
        "isExtraImport": true,
        "detail": "ansible.utils.unsafe_proxy",
        "documentation": {}
    },
    {
        "label": "AnsibleUnsafe",
        "importPath": "ansible.utils.unsafe_proxy",
        "description": "ansible.utils.unsafe_proxy",
        "isExtraImport": true,
        "detail": "ansible.utils.unsafe_proxy",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "mock",
        "importPath": "ansible_collections.community.docker.tests.unit.compat",
        "description": "ansible_collections.community.docker.tests.unit.compat",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.tests.unit.compat",
        "documentation": {}
    },
    {
        "label": "unittest",
        "importPath": "ansible_collections.community.docker.tests.unit.compat",
        "description": "ansible_collections.community.docker.tests.unit.compat",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.tests.unit.compat",
        "documentation": {}
    },
    {
        "label": "PlayContext",
        "importPath": "ansible.playbook.play_context",
        "description": "ansible.playbook.play_context",
        "isExtraImport": true,
        "detail": "ansible.playbook.play_context",
        "documentation": {}
    },
    {
        "label": "connection_loader",
        "importPath": "ansible.plugins.loader",
        "description": "ansible.plugins.loader",
        "isExtraImport": true,
        "detail": "ansible.plugins.loader",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "mark",
        "importPath": "pytest",
        "description": "pytest",
        "isExtraImport": true,
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "fixture",
        "importPath": "pytest",
        "description": "pytest",
        "isExtraImport": true,
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "InventoryData",
        "importPath": "ansible.inventory.data",
        "description": "ansible.inventory.data",
        "isExtraImport": true,
        "detail": "ansible.inventory.data",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "ansible.parsing.dataloader",
        "description": "ansible.parsing.dataloader",
        "isExtraImport": true,
        "detail": "ansible.parsing.dataloader",
        "documentation": {}
    },
    {
        "label": "Templar",
        "importPath": "ansible.template",
        "description": "ansible.template",
        "isExtraImport": true,
        "detail": "ansible.template",
        "documentation": {}
    },
    {
        "label": "Templar",
        "importPath": "ansible.template",
        "description": "ansible.template",
        "isExtraImport": true,
        "detail": "ansible.template",
        "documentation": {}
    },
    {
        "label": "InventoryModule",
        "importPath": "ansible_collections.community.docker.plugins.inventory.docker_containers",
        "description": "ansible_collections.community.docker.plugins.inventory.docker_containers",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.inventory.docker_containers",
        "documentation": {}
    },
    {
        "label": "create_autospec",
        "importPath": "ansible_collections.community.docker.tests.unit.compat.mock",
        "description": "ansible_collections.community.docker.tests.unit.compat.mock",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.tests.unit.compat.mock",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "six",
        "importPath": "ansible.module_utils",
        "description": "ansible.module_utils",
        "isExtraImport": true,
        "detail": "ansible.module_utils",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "urllib3",
        "importPath": "requests.packages",
        "description": "requests.packages",
        "isExtraImport": true,
        "detail": "requests.packages",
        "documentation": {}
    },
    {
        "label": "SSHSocket",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "SSHHTTPAdapter",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "ssladapter",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.transport",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.transport",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.transport",
        "documentation": {}
    },
    {
        "label": "update_headers",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "documentation": {}
    },
    {
        "label": "json_splitter",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "stream_as_text",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "json_stream",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "build_port_bindings",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "split_port",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "ProxyConfig",
        "importPath": "ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "description": "ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "documentation": {}
    },
    {
        "label": "ImageManager",
        "importPath": "ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "ansible_collections.community.docker.plugins.modules.docker_image",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "validate_cidr",
        "importPath": "ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "ansible_collections.community.docker.plugins.modules.docker_network",
        "isExtraImport": true,
        "detail": "ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "mock",
        "description": "mock",
        "isExtraImport": true,
        "detail": "mock",
        "documentation": {}
    },
    {
        "label": "DictDataLoader",
        "importPath": "ansible_collections.community.internal_test_tools.tests.unit.mock.loader",
        "description": "ansible_collections.community.internal_test_tools.tests.unit.mock.loader",
        "isExtraImport": true,
        "detail": "ansible_collections.community.internal_test_tools.tests.unit.mock.loader",
        "documentation": {}
    },
    {
        "label": "StaticLiveServerTestCase",
        "importPath": "django.contrib.staticfiles.testing",
        "description": "django.contrib.staticfiles.testing",
        "isExtraImport": true,
        "detail": "django.contrib.staticfiles.testing",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "Keys",
        "importPath": "selenium.webdriver.common.keys",
        "description": "selenium.webdriver.common.keys",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.keys",
        "documentation": {}
    },
    {
        "label": "WebDriverException",
        "importPath": "selenium.common.exceptions",
        "description": "selenium.common.exceptions",
        "isExtraImport": true,
        "detail": "selenium.common.exceptions",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "django.db.models.deletion",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "django.db.models.deletion",
        "description": "django.db.models.deletion",
        "detail": "django.db.models.deletion",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "django.apps",
        "description": "django.apps",
        "isExtraImport": true,
        "detail": "django.apps",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "response",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "HttpRequest",
        "importPath": "django.http",
        "description": "django.http",
        "isExtraImport": true,
        "detail": "django.http",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "django.test",
        "description": "django.test",
        "isExtraImport": true,
        "detail": "django.test",
        "documentation": {}
    },
    {
        "label": "home_page",
        "importPath": "lists.views",
        "description": "lists.views",
        "isExtraImport": true,
        "detail": "lists.views",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "lists.models",
        "description": "lists.models",
        "isExtraImport": true,
        "detail": "lists.models",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "lists.models",
        "description": "lists.models",
        "isExtraImport": true,
        "detail": "lists.models",
        "documentation": {}
    },
    {
        "label": "Item",
        "importPath": "lists.models",
        "description": "lists.models",
        "isExtraImport": true,
        "detail": "lists.models",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "lists.models",
        "description": "lists.models",
        "isExtraImport": true,
        "detail": "lists.models",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "include",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "views",
        "importPath": "lists",
        "description": "lists",
        "isExtraImport": true,
        "detail": "lists",
        "documentation": {}
    },
    {
        "label": "views",
        "importPath": "lists",
        "description": "lists",
        "isExtraImport": true,
        "detail": "lists",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "get_asgi_application",
        "importPath": "django.core.asgi",
        "description": "django.core.asgi",
        "isExtraImport": true,
        "detail": "django.core.asgi",
        "documentation": {}
    },
    {
        "label": "get_wsgi_application",
        "importPath": "django.core.wsgi",
        "description": "django.core.wsgi",
        "isExtraImport": true,
        "detail": "django.core.wsgi",
        "documentation": {}
    },
    {
        "label": "Plugin",
        "kind": 6,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "class Plugin(BaseModel):\n    path: str\n    name: str\n    url: str = None\n    description: str = None\ndef docker_works() -> bool:\n    logging.debug('running docker --help to make sure docker is installed')\n    process = subprocess.run(\"docker --help\",\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "docker_works",
        "kind": 2,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "def docker_works() -> bool:\n    logging.debug('running docker --help to make sure docker is installed')\n    process = subprocess.run(\"docker --help\",\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)\n    logging.debug(f'docker --help return code: %s', process.returncode)\n    return process.returncode == 0\ndef get_context_info() -> dict:\n    return {\n        'PYDEV_PROJECT_ROOT': os.getcwd()",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "get_context_info",
        "kind": 2,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "def get_context_info() -> dict:\n    return {\n        'PYDEV_PROJECT_ROOT': os.getcwd()\n    }\ndef stop_plugin(plugin: Plugin):\n    logging.debug(f'Shutting down plugin: {plugin.name}')\n    env = {**os.environ.copy(), **get_context_info()}\n    process = subprocess.run(f\"docker-compose -f {plugin.path} down --remove-orphans\",\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE,",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "stop_plugin",
        "kind": 2,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "def stop_plugin(plugin: Plugin):\n    logging.debug(f'Shutting down plugin: {plugin.name}')\n    env = {**os.environ.copy(), **get_context_info()}\n    process = subprocess.run(f\"docker-compose -f {plugin.path} down --remove-orphans\",\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE,\n                             env=env)\n    logging.debug('shutdown complete with return code: %s', process.returncode)\n    if process.returncode != 0:\n        logging.debug('stdout: %s', process.stdout)",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "start_plugin",
        "kind": 2,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "def start_plugin(plugin: Plugin):\n    logging.debug(f'Starting plugin: {plugin.name}')\n    env = {**os.environ.copy(), **get_context_info()}\n    process = subprocess.run(f\"docker-compose -f {plugin.path} up -d\",\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE,\n                             env=env)\n    logging.debug('start complete with return code: %s', process.returncode)\n    if process.returncode != 0:\n        logging.debug('stdout: %s', process.stdout)",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "get_plugins",
        "kind": 2,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "def get_plugins(plugins_dir: str) -> List[Plugin]:\n    logging.debug('Searching for plugins in %s', plugins_dir)\n    plugin_files = glob.glob(path.join(plugins_dir, '*.yml'))\n    plugin_files = plugin_files + glob.glob(path.join(plugins_dir, '*.yaml'))\n    plugin_files = list(set(plugin_files))\n    logging.debug('Plugin files: %s', plugin_files)\n    plugins = []\n    for plugin_file in plugin_files:\n        name, ext = os.path.splitext(os.path.basename(plugin_file))\n        comment_lines = []",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "docker_compose_works",
        "kind": 2,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "def docker_compose_works() -> bool:\n    logging.debug('running docker-compose --help to make sure it is installed')\n    process = subprocess.run(\"docker-compose --help\",\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE)\n    logging.debug(f'docker-compose --help return code: %s', process.returncode)\n    return process.returncode == 0\ndef main(plugins_dir: str, verify: bool = False, *args, **kwargs):\n    if verify:\n        if not docker_works():",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.bin.pydev",
        "description": ".venv.bin.pydev",
        "peekOfCode": "def main(plugins_dir: str, verify: bool = False, *args, **kwargs):\n    if verify:\n        if not docker_works():\n            logging.error('Docker does not seem to be installed, terminating')\n            exit(1)\n        if not docker_compose_works():\n            logging.error('Docker compose does not seem to be installed, terminating')\n            exit(1)\n    logging.debug('Creating plugins dir at %s', plugins_dir)\n    os.makedirs(plugins_dir, exist_ok=True)",
        "detail": ".venv.bin.pydev",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.combine-coverage",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.combine-coverage",
        "peekOfCode": "def main():\n    \"\"\"Main program entry point.\"\"\"\n    source_directory = sys.argv[1]\n    if '/ansible_collections/' in os.getcwd():\n        output_path = \"tests/output\"\n    else:\n        output_path = \"test/results\"\n    destination_directory = os.path.join(output_path, 'coverage')\n    if not os.path.exists(destination_directory):\n        os.makedirs(destination_directory)",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.combine-coverage",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.combine-coverage",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.combine-coverage",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport re\nimport shutil\nimport sys\ndef main():\n    \"\"\"Main program entry point.\"\"\"\n    source_directory = sys.argv[1]\n    if '/ansible_collections/' in os.getcwd():\n        output_path = \"tests/output\"",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.combine-coverage",
        "documentation": {}
    },
    {
        "label": "CoverageFile",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "peekOfCode": "class CoverageFile:\n    name: str\n    path: pathlib.Path\n    flags: t.List[str]\n@dataclasses.dataclass(frozen=True)\nclass Args:\n    dry_run: bool\n    path: pathlib.Path\ndef parse_args() -> Args:\n    parser = argparse.ArgumentParser()",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "peekOfCode": "class Args:\n    dry_run: bool\n    path: pathlib.Path\ndef parse_args() -> Args:\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-n', '--dry-run', action='store_true')\n    parser.add_argument('path', type=pathlib.Path)\n    args = parser.parse_args()\n    # Store arguments in a typed dataclass\n    fields = dataclasses.fields(Args)",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "peekOfCode": "def parse_args() -> Args:\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-n', '--dry-run', action='store_true')\n    parser.add_argument('path', type=pathlib.Path)\n    args = parser.parse_args()\n    # Store arguments in a typed dataclass\n    fields = dataclasses.fields(Args)\n    kwargs = {field.name: getattr(args, field.name) for field in fields}\n    return Args(**kwargs)\ndef process_files(directory: pathlib.Path) -> t.Tuple[CoverageFile, ...]:",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "documentation": {}
    },
    {
        "label": "process_files",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "peekOfCode": "def process_files(directory: pathlib.Path) -> t.Tuple[CoverageFile, ...]:\n    processed = []\n    for file in directory.joinpath('reports').glob('coverage*.xml'):\n        name = file.stem.replace('coverage=', '')\n        # Get flags from name\n        flags = name.replace('-powershell', '').split('=')  # Drop '-powershell' suffix\n        flags = [flag if not flag.startswith('stub') else flag.split('-')[0] for flag in flags]  # Remove \"-01\" from stub files\n        processed.append(CoverageFile(name, file, flags))\n    return tuple(processed)\ndef upload_files(codecov_bin: pathlib.Path, files: t.Tuple[CoverageFile, ...], dry_run: bool = False) -> None:",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "documentation": {}
    },
    {
        "label": "upload_files",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "peekOfCode": "def upload_files(codecov_bin: pathlib.Path, files: t.Tuple[CoverageFile, ...], dry_run: bool = False) -> None:\n    for file in files:\n        cmd = [\n            str(codecov_bin),\n            '--name', file.name,\n            '--file', str(file.path),\n        ]\n        for flag in file.flags:\n            cmd.extend(['--flags', flag])\n        if dry_run:",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "documentation": {}
    },
    {
        "label": "download_file",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "peekOfCode": "def download_file(url: str, dest: pathlib.Path, flags: int, dry_run: bool = False) -> None:\n    if dry_run:\n        print(f'DRY-RUN: Would download {url} to {dest} and set mode to {flags:o}')\n        return\n    with urllib.request.urlopen(url) as resp:\n        with dest.open('w+b') as f:\n            # Read data in chunks rather than all at once\n            shutil.copyfileobj(resp, f, 64 * 1024)\n    dest.chmod(flags)\ndef main():",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "peekOfCode": "def main():\n    args = parse_args()\n    url = 'https://ansible-ci-files.s3.amazonaws.com/codecov/linux/codecov'\n    with tempfile.TemporaryDirectory(prefix='codecov-') as tmpdir:\n        codecov_bin = pathlib.Path(tmpdir) / 'codecov'\n        download_file(url, codecov_bin, 0o755, args.dry_run)\n        files = process_files(args.path)\n        upload_files(codecov_bin, files, args.dry_run)\nif __name__ == '__main__':\n    main()",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.publish-codecov",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.time-command",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.time-command",
        "peekOfCode": "def main():\n    \"\"\"Main program entry point.\"\"\"\n    start = time.time()\n    sys.stdin.reconfigure(errors='surrogateescape')\n    sys.stdout.reconfigure(errors='surrogateescape')\n    for line in sys.stdin:\n        seconds = time.time() - start\n        sys.stdout.write('%02d:%02d %s' % (seconds // 60, seconds % 60, line))\n        sys.stdout.flush()\nif __name__ == '__main__':",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.time-command",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker..azure-pipelines.scripts.time-command",
        "description": "collections.ansible_collections.community.docker..azure-pipelines.scripts.time-command",
        "peekOfCode": "__metaclass__ = type\nimport sys\nimport time\ndef main():\n    \"\"\"Main program entry point.\"\"\"\n    start = time.time()\n    sys.stdin.reconfigure(errors='surrogateescape')\n    sys.stdout.reconfigure(errors='surrogateescape')\n    for line in sys.stdin:\n        seconds = time.time() - start",
        "detail": "collections.ansible_collections.community.docker..azure-pipelines.scripts.time-command",
        "documentation": {}
    },
    {
        "label": "ActionModule",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.action.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.action.docker_container_copy_into",
        "peekOfCode": "class ActionModule(ActionBase):\n    # Set to True when transferring files to the remote\n    TRANSFERS_FILES = False\n    def run(self, tmp=None, task_vars=None):\n        self._supports_check_mode = True\n        self._supports_async = True\n        result = super(ActionModule, self).run(tmp, task_vars)\n        del tmp  # tmp no longer has any effect\n        self._task.args['_max_file_size_for_diff'] = C.MAX_FILE_SIZE_FOR_DIFF\n        result = merge_hash(result, self._execute_module(task_vars=task_vars, wrap_async=self._task.async_val))",
        "detail": "collections.ansible_collections.community.docker.plugins.action.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.action.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.action.docker_container_copy_into",
        "peekOfCode": "__metaclass__ = type\nimport base64\nfrom ansible import constants as C\nfrom ansible.plugins.action import ActionBase\nfrom ansible.utils.vars import merge_hash\nfrom ansible_collections.community.docker.plugins.module_utils._scramble import unscramble\nclass ActionModule(ActionBase):\n    # Set to True when transferring files to the remote\n    TRANSFERS_FILES = False\n    def run(self, tmp=None, task_vars=None):",
        "detail": "collections.ansible_collections.community.docker.plugins.action.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "Connection",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "peekOfCode": "class Connection(ConnectionBase):\n    ''' Local docker based connections '''\n    transport = 'community.docker.docker'\n    has_pipelining = True\n    def __init__(self, play_context, new_stdin, *args, **kwargs):\n        super(Connection, self).__init__(play_context, new_stdin, *args, **kwargs)\n        # Note: docker supports running as non-root in some configurations.\n        # (For instance, setting the UNIX socket file to be readable and\n        # writable by a specific UNIX group and then putting users into that\n        # group).  Therefore we don't check that the user is root when using",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nauthor:\n    - Lorin Hochestein (!UNKNOWN)\n    - Leendert Brouwer (!UNKNOWN)\nname: docker\nshort_description: Run tasks in docker containers\ndescription:\n    - Run commands or put/fetch files to an existing docker container.\n    - Uses the Docker CLI to execute commands in the container. If you prefer",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "peekOfCode": "DOCUMENTATION = '''\nauthor:\n    - Lorin Hochestein (!UNKNOWN)\n    - Leendert Brouwer (!UNKNOWN)\nname: docker\nshort_description: Run tasks in docker containers\ndescription:\n    - Run commands or put/fetch files to an existing docker container.\n    - Uses the Docker CLI to execute commands in the container. If you prefer\n      to directly connect to the Docker daemon, use the",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "documentation": {}
    },
    {
        "label": "display",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "peekOfCode": "display = Display()\nclass Connection(ConnectionBase):\n    ''' Local docker based connections '''\n    transport = 'community.docker.docker'\n    has_pipelining = True\n    def __init__(self, play_context, new_stdin, *args, **kwargs):\n        super(Connection, self).__init__(play_context, new_stdin, *args, **kwargs)\n        # Note: docker supports running as non-root in some configurations.\n        # (For instance, setting the UNIX socket file to be readable and\n        # writable by a specific UNIX group and then putting users into that",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker",
        "documentation": {}
    },
    {
        "label": "Connection",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "peekOfCode": "class Connection(ConnectionBase):\n    ''' Local docker based connections '''\n    transport = 'community.docker.docker_api'\n    has_pipelining = True\n    def _call_client(self, callable, not_found_can_be_resource=False):\n        try:\n            return callable()\n        except NotFound as e:\n            if not_found_can_be_resource:\n                raise AnsibleConnectionFailure('Could not find container \"{1}\" or resource in it ({0})'.format(e, self.get_option('remote_addr')))",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nauthor:\n    - Felix Fontein (@felixfontein)\nname: docker_api\nshort_description: Run tasks in docker containers\nversion_added: 1.1.0\ndescription:\n    - Run commands or put/fetch files to an existing docker container.\n    - Uses the L(requests library,https://pypi.org/project/requests/) to interact",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "peekOfCode": "DOCUMENTATION = '''\nauthor:\n    - Felix Fontein (@felixfontein)\nname: docker_api\nshort_description: Run tasks in docker containers\nversion_added: 1.1.0\ndescription:\n    - Run commands or put/fetch files to an existing docker container.\n    - Uses the L(requests library,https://pypi.org/project/requests/) to interact\n      directly with the Docker daemon instead of using the Docker CLI. Use the",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "documentation": {}
    },
    {
        "label": "MIN_DOCKER_API",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "peekOfCode": "MIN_DOCKER_API = None\ndisplay = Display()\nclass Connection(ConnectionBase):\n    ''' Local docker based connections '''\n    transport = 'community.docker.docker_api'\n    has_pipelining = True\n    def _call_client(self, callable, not_found_can_be_resource=False):\n        try:\n            return callable()\n        except NotFound as e:",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "documentation": {}
    },
    {
        "label": "display",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "peekOfCode": "display = Display()\nclass Connection(ConnectionBase):\n    ''' Local docker based connections '''\n    transport = 'community.docker.docker_api'\n    has_pipelining = True\n    def _call_client(self, callable, not_found_can_be_resource=False):\n        try:\n            return callable()\n        except NotFound as e:\n            if not_found_can_be_resource:",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.docker_api",
        "documentation": {}
    },
    {
        "label": "Connection",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "description": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "peekOfCode": "class Connection(ConnectionBase):\n    '''Connections to a container host using nsenter\n    '''\n    transport = 'community.docker.nsenter'\n    has_pipelining = False\n    def __init__(self, *args, **kwargs):\n        super(Connection, self).__init__(*args, **kwargs)\n        self.cwd = None\n    def _connect(self):\n        self._nsenter_pid = self.get_option(\"nsenter_pid\")",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "description": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nname: nsenter\nshort_description: execute on host running controller container\nversion_added: 1.9.0\ndescription:\n    - This connection plugin allows Ansible, running in a privileged container, to execute tasks on the container\n      host instead of in the container itself.\n    - This is useful for running Ansible in a pull model, while still keeping the Ansible control node\n      containerized.",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "description": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "peekOfCode": "DOCUMENTATION = '''\nname: nsenter\nshort_description: execute on host running controller container\nversion_added: 1.9.0\ndescription:\n    - This connection plugin allows Ansible, running in a privileged container, to execute tasks on the container\n      host instead of in the container itself.\n    - This is useful for running Ansible in a pull model, while still keeping the Ansible control node\n      containerized.\n    - It relies on having privileged access to run C(nsenter) in the host's PID namespace, allowing it to enter the",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "documentation": {}
    },
    {
        "label": "display",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "description": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "peekOfCode": "display = Display()\nclass Connection(ConnectionBase):\n    '''Connections to a container host using nsenter\n    '''\n    transport = 'community.docker.nsenter'\n    has_pipelining = False\n    def __init__(self, *args, **kwargs):\n        super(Connection, self).__init__(*args, **kwargs)\n        self.cwd = None\n    def _connect(self):",
        "detail": "collections.ansible_collections.community.docker.plugins.connection.nsenter",
        "documentation": {}
    },
    {
        "label": "ModuleDocFragment",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.doc_fragments.attributes",
        "description": "collections.ansible_collections.community.docker.plugins.doc_fragments.attributes",
        "peekOfCode": "class ModuleDocFragment(object):\n    # Standard documentation fragment\n    DOCUMENTATION = r'''\noptions: {}\nattributes:\n    check_mode:\n      description: Can run in C(check_mode) and return changed status prediction without modifying target.\n    diff_mode:\n      description: Will return details on what has changed (or possibly needs changing in C(check_mode)), when in diff mode.\n'''",
        "detail": "collections.ansible_collections.community.docker.plugins.doc_fragments.attributes",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.doc_fragments.attributes",
        "description": "collections.ansible_collections.community.docker.plugins.doc_fragments.attributes",
        "peekOfCode": "__metaclass__ = type\nclass ModuleDocFragment(object):\n    # Standard documentation fragment\n    DOCUMENTATION = r'''\noptions: {}\nattributes:\n    check_mode:\n      description: Can run in C(check_mode) and return changed status prediction without modifying target.\n    diff_mode:\n      description: Will return details on what has changed (or possibly needs changing in C(check_mode)), when in diff mode.",
        "detail": "collections.ansible_collections.community.docker.plugins.doc_fragments.attributes",
        "documentation": {}
    },
    {
        "label": "ModuleDocFragment",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.doc_fragments.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.doc_fragments.compose_v2",
        "peekOfCode": "class ModuleDocFragment(object):\n    # Docker doc fragment\n    DOCUMENTATION = r'''\noptions:\n    project_src:\n        description:\n          - Path to a directory containing a Compose file\n            (C(compose.yml), C(compose.yaml), C(docker-compose.yml), or C(docker-compose.yaml)).\n          - If O(files) is provided, will look for these files in this directory instead.\n          - Mutually exclusive with O(definition). One of O(project_src) and O(definition) must be provided.",
        "detail": "collections.ansible_collections.community.docker.plugins.doc_fragments.compose_v2",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.doc_fragments.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.doc_fragments.compose_v2",
        "peekOfCode": "__metaclass__ = type\nclass ModuleDocFragment(object):\n    # Docker doc fragment\n    DOCUMENTATION = r'''\noptions:\n    project_src:\n        description:\n          - Path to a directory containing a Compose file\n            (C(compose.yml), C(compose.yaml), C(docker-compose.yml), or C(docker-compose.yaml)).\n          - If O(files) is provided, will look for these files in this directory instead.",
        "detail": "collections.ansible_collections.community.docker.plugins.doc_fragments.compose_v2",
        "documentation": {}
    },
    {
        "label": "ModuleDocFragment",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.doc_fragments.docker",
        "description": "collections.ansible_collections.community.docker.plugins.doc_fragments.docker",
        "peekOfCode": "class ModuleDocFragment(object):\n    # Docker doc fragment\n    DOCUMENTATION = r'''\noptions:\n    docker_host:\n        description:\n            - The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the\n              TCP connection string. For example, V(tcp://192.0.2.23:2376). If TLS is used to encrypt the connection,\n              the module will automatically replace C(tcp) in the connection URL with C(https).\n            - If the value is not specified in the task, the value of environment variable E(DOCKER_HOST) will be used",
        "detail": "collections.ansible_collections.community.docker.plugins.doc_fragments.docker",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.doc_fragments.docker",
        "description": "collections.ansible_collections.community.docker.plugins.doc_fragments.docker",
        "peekOfCode": "__metaclass__ = type\nclass ModuleDocFragment(object):\n    # Docker doc fragment\n    DOCUMENTATION = r'''\noptions:\n    docker_host:\n        description:\n            - The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the\n              TCP connection string. For example, V(tcp://192.0.2.23:2376). If TLS is used to encrypt the connection,\n              the module will automatically replace C(tcp) in the connection URL with C(https).",
        "detail": "collections.ansible_collections.community.docker.plugins.doc_fragments.docker",
        "documentation": {}
    },
    {
        "label": "InventoryModule",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "peekOfCode": "class InventoryModule(BaseInventoryPlugin, Constructable):\n    ''' Host inventory parser for ansible using Docker daemon as source. '''\n    NAME = 'community.docker.docker_containers'\n    def _slugify(self, value):\n        return 'docker_%s' % (re.sub(r'[^\\w-]', '_', value).lower().lstrip('_'))\n    def _populate(self, client):\n        strict = self.get_option('strict')\n        ssh_port = self.get_option('private_ssh_port')\n        default_ip = self.get_option('default_ip')\n        hostname = self.get_option('docker_host')",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nname: docker_containers\nshort_description: Ansible dynamic inventory plugin for Docker containers\nversion_added: 1.1.0\nauthor:\n    - Felix Fontein (@felixfontein)\nextends_documentation_fragment:\n    - ansible.builtin.constructed\n    - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "peekOfCode": "DOCUMENTATION = '''\nname: docker_containers\nshort_description: Ansible dynamic inventory plugin for Docker containers\nversion_added: 1.1.0\nauthor:\n    - Felix Fontein (@felixfontein)\nextends_documentation_fragment:\n    - ansible.builtin.constructed\n    - community.docker.docker.api_documentation\n    - community.docker.docker.ssl_version_deprecation",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "peekOfCode": "EXAMPLES = '''\n# Minimal example using local Docker daemon\nplugin: community.docker.docker_containers\ndocker_host: unix:///var/run/docker.sock\n# Minimal example using remote Docker daemon\nplugin: community.docker.docker_containers\ndocker_host: tcp://my-docker-host:2375\n# Example using remote Docker daemon with unverified TLS\nplugin: community.docker.docker_containers\ndocker_host: tcp://my-docker-host:2376",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "documentation": {}
    },
    {
        "label": "MIN_DOCKER_API",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "peekOfCode": "MIN_DOCKER_API = None\nclass InventoryModule(BaseInventoryPlugin, Constructable):\n    ''' Host inventory parser for ansible using Docker daemon as source. '''\n    NAME = 'community.docker.docker_containers'\n    def _slugify(self, value):\n        return 'docker_%s' % (re.sub(r'[^\\w-]', '_', value).lower().lstrip('_'))\n    def _populate(self, client):\n        strict = self.get_option('strict')\n        ssh_port = self.get_option('private_ssh_port')\n        default_ip = self.get_option('default_ip')",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_containers",
        "documentation": {}
    },
    {
        "label": "InventoryModule",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "peekOfCode": "class InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):\n    ''' Host inventory parser for ansible using Docker machine as source. '''\n    NAME = 'community.docker.docker_machine'\n    DOCKER_MACHINE_PATH = None\n    def _run_command(self, args):\n        if not self.DOCKER_MACHINE_PATH:\n            try:\n                self.DOCKER_MACHINE_PATH = get_bin_path('docker-machine')\n            except ValueError as e:\n                raise AnsibleError(to_native(e))",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n    name: docker_machine\n    author: Ximon Eighteen (@ximon18)\n    short_description: Docker Machine inventory source\n    requirements:\n        - L(Docker Machine,https://docs.docker.com/machine/)\n    extends_documentation_fragment:\n        - ansible.builtin.constructed\n        - community.library_inventory_filtering_v1.inventory_filter",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "peekOfCode": "DOCUMENTATION = '''\n    name: docker_machine\n    author: Ximon Eighteen (@ximon18)\n    short_description: Docker Machine inventory source\n    requirements:\n        - L(Docker Machine,https://docs.docker.com/machine/)\n    extends_documentation_fragment:\n        - ansible.builtin.constructed\n        - community.library_inventory_filtering_v1.inventory_filter\n    description:",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "peekOfCode": "EXAMPLES = '''\n# Minimal example\nplugin: community.docker.docker_machine\n# Example using constructed features to create a group per Docker Machine driver\n# (https://docs.docker.com/machine/drivers/), for example:\n#   $ docker-machine create --driver digitalocean ... mymachine\n#   $ ansible-inventory -i ./path/to/docker-machine.yml --host=mymachine\n#   {\n#     ...\n#     \"digitalocean\": {",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "documentation": {}
    },
    {
        "label": "display",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "peekOfCode": "display = Display()\nclass InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):\n    ''' Host inventory parser for ansible using Docker machine as source. '''\n    NAME = 'community.docker.docker_machine'\n    DOCKER_MACHINE_PATH = None\n    def _run_command(self, args):\n        if not self.DOCKER_MACHINE_PATH:\n            try:\n                self.DOCKER_MACHINE_PATH = get_bin_path('docker-machine')\n            except ValueError as e:",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_machine",
        "documentation": {}
    },
    {
        "label": "InventoryModule",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "peekOfCode": "class InventoryModule(BaseInventoryPlugin, Constructable):\n    ''' Host inventory parser for ansible using Docker swarm as source. '''\n    NAME = 'community.docker.docker_swarm'\n    def _fail(self, msg):\n        raise AnsibleError(msg)\n    def _populate(self):\n        raw_params = dict(\n            docker_host=self.get_option('docker_host'),\n            tls=self.get_option('tls'),\n            tls_verify=self.get_option('validate_certs'),",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n    name: docker_swarm\n    author:\n      - Stefan Heitmller (@morph027) <stefan.heitmueller@gmx.com>\n    short_description: Ansible dynamic inventory plugin for Docker swarm nodes.\n    requirements:\n        - python >= 2.7\n        - L(Docker SDK for Python,https://docker-py.readthedocs.io/en/stable/) >= 1.10.0\n    extends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "peekOfCode": "DOCUMENTATION = '''\n    name: docker_swarm\n    author:\n      - Stefan Heitmller (@morph027) <stefan.heitmueller@gmx.com>\n    short_description: Ansible dynamic inventory plugin for Docker swarm nodes.\n    requirements:\n        - python >= 2.7\n        - L(Docker SDK for Python,https://docker-py.readthedocs.io/en/stable/) >= 1.10.0\n    extends_documentation_fragment:\n        - ansible.builtin.constructed",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "peekOfCode": "EXAMPLES = '''\n# Minimal example using local docker\nplugin: community.docker.docker_swarm\ndocker_host: unix:///var/run/docker.sock\n# Minimal example using remote docker\nplugin: community.docker.docker_swarm\ndocker_host: tcp://my-docker-host:2375\n# Example using remote docker with unverified TLS\nplugin: community.docker.docker_swarm\ndocker_host: tcp://my-docker-host:2376",
        "detail": "collections.ansible_collections.community.docker.plugins.inventory.docker_swarm",
        "documentation": {}
    },
    {
        "label": "APIClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "peekOfCode": "class APIClient(\n        _Session,\n        DaemonApiMixin):\n    \"\"\"\n    A low-level client for the Docker Engine API.\n    Example:\n        >>> import docker\n        >>> client = docker.APIClient(base_url='unix://var/run/docker.sock')\n        >>> client.version()\n        {u'ApiVersion': u'1.33',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport logging\nimport struct\nfrom functools import partial\nfrom ansible.module_utils.six import PY3, binary_type, iteritems, string_types, raise_from\nfrom ansible.module_utils.six.moves.urllib.parse import quote\nfrom .. import auth\nfrom .._import_helper import fail_on_missing_imports\nfrom .._import_helper import HTTPError as _HTTPError",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass APIClient(\n        _Session,\n        DaemonApiMixin):\n    \"\"\"\n    A low-level client for the Docker Engine API.\n    Example:\n        >>> import docker\n        >>> client = docker.APIClient(base_url='unix://var/run/docker.sock')\n        >>> client.version()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.client",
        "documentation": {}
    },
    {
        "label": "DaemonApiMixin",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.daemon",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.daemon",
        "peekOfCode": "class DaemonApiMixin(object):\n    @minimum_version('1.25')\n    def df(self):\n        \"\"\"\n        Get data usage information.\n        Returns:\n            (dict): A dictionary representing different resource categories\n            and their respective data usage.\n        Raises:\n            :py:class:`docker.errors.APIError`",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.daemon",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.daemon",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.daemon",
        "peekOfCode": "__metaclass__ = type\nimport os\nfrom .. import auth\nfrom ..utils.decorators import minimum_version\nclass DaemonApiMixin(object):\n    @minimum_version('1.25')\n    def df(self):\n        \"\"\"\n        Get data usage information.\n        Returns:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.api.daemon",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "peekOfCode": "__metaclass__ = type\nPROGRAM_PREFIX = 'docker-credential-'\nDEFAULT_LINUX_STORE = 'secretservice'\nDEFAULT_OSX_STORE = 'osxkeychain'\nDEFAULT_WIN32_STORE = 'wincred'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "documentation": {}
    },
    {
        "label": "PROGRAM_PREFIX",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "peekOfCode": "PROGRAM_PREFIX = 'docker-credential-'\nDEFAULT_LINUX_STORE = 'secretservice'\nDEFAULT_OSX_STORE = 'osxkeychain'\nDEFAULT_WIN32_STORE = 'wincred'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LINUX_STORE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "peekOfCode": "DEFAULT_LINUX_STORE = 'secretservice'\nDEFAULT_OSX_STORE = 'osxkeychain'\nDEFAULT_WIN32_STORE = 'wincred'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OSX_STORE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "peekOfCode": "DEFAULT_OSX_STORE = 'osxkeychain'\nDEFAULT_WIN32_STORE = 'wincred'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_WIN32_STORE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "peekOfCode": "DEFAULT_WIN32_STORE = 'wincred'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.constants",
        "documentation": {}
    },
    {
        "label": "StoreError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "peekOfCode": "class StoreError(RuntimeError):\n    pass\nclass CredentialsNotFound(StoreError):\n    pass\nclass InitializationError(StoreError):\n    pass\ndef process_store_error(cpe, program):\n    message = cpe.output.decode('utf-8')\n    if 'credentials not found in native keychain' in message:\n        return CredentialsNotFound(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "documentation": {}
    },
    {
        "label": "CredentialsNotFound",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "peekOfCode": "class CredentialsNotFound(StoreError):\n    pass\nclass InitializationError(StoreError):\n    pass\ndef process_store_error(cpe, program):\n    message = cpe.output.decode('utf-8')\n    if 'credentials not found in native keychain' in message:\n        return CredentialsNotFound(\n            'No matching credentials in {0}'.format(\n                program",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "documentation": {}
    },
    {
        "label": "InitializationError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "peekOfCode": "class InitializationError(StoreError):\n    pass\ndef process_store_error(cpe, program):\n    message = cpe.output.decode('utf-8')\n    if 'credentials not found in native keychain' in message:\n        return CredentialsNotFound(\n            'No matching credentials in {0}'.format(\n                program\n            )\n        )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "documentation": {}
    },
    {
        "label": "process_store_error",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "peekOfCode": "def process_store_error(cpe, program):\n    message = cpe.output.decode('utf-8')\n    if 'credentials not found in native keychain' in message:\n        return CredentialsNotFound(\n            'No matching credentials in {0}'.format(\n                program\n            )\n        )\n    return StoreError(\n        'Credentials store {0} exited with \"{1}\".'.format(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "peekOfCode": "__metaclass__ = type\nclass StoreError(RuntimeError):\n    pass\nclass CredentialsNotFound(StoreError):\n    pass\nclass InitializationError(StoreError):\n    pass\ndef process_store_error(cpe, program):\n    message = cpe.output.decode('utf-8')\n    if 'credentials not found in native keychain' in message:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.errors",
        "documentation": {}
    },
    {
        "label": "Store",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "peekOfCode": "class Store(object):\n    def __init__(self, program, environment=None):\n        \"\"\" Create a store object that acts as an interface to\n            perform the basic operations for storing, retrieving\n            and erasing credentials using `program`.\n        \"\"\"\n        self.program = constants.PROGRAM_PREFIX + program\n        self.exe = find_executable(self.program)\n        self.environment = environment\n        if self.exe is None:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "peekOfCode": "__metaclass__ = type\nimport errno\nimport json\nimport subprocess\nfrom ansible.module_utils.six import PY3, binary_type\nfrom . import constants\nfrom . import errors\nfrom .utils import create_environment_dict\nfrom .utils import find_executable\nclass Store(object):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.store",
        "documentation": {}
    },
    {
        "label": "find_executable",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "peekOfCode": "def find_executable(executable, path=None):\n    \"\"\"\n    As distutils.spawn.find_executable, but on Windows, look up\n    every extension declared in PATHEXT instead of just `.exe`\n    \"\"\"\n    if not PY2:\n        # shutil.which() already uses PATHEXT on Windows, so on\n        # Python 3 we can simply use shutil.which() in all cases.\n        # (https://github.com/docker/docker-py/commit/42789818bed5d86b487a030e2e60b02bf0cfa284)\n        return which(executable, path=path)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "documentation": {}
    },
    {
        "label": "create_environment_dict",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "peekOfCode": "def create_environment_dict(overrides):\n    \"\"\"\n    Create and return a copy of os.environ with the specified overrides\n    \"\"\"\n    result = os.environ.copy()\n    result.update(overrides or {})\n    return result",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport sys\nfrom ansible.module_utils.six import PY2\nif PY2:\n    from distutils.spawn import find_executable as which\nelse:\n    from shutil import which\ndef find_executable(executable, path=None):\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.credentials.utils",
        "documentation": {}
    },
    {
        "label": "BaseHTTPAdapter",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.basehttpadapter",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.basehttpadapter",
        "peekOfCode": "class BaseHTTPAdapter(_HTTPAdapter):\n    def close(self):\n        super(BaseHTTPAdapter, self).close()\n        if hasattr(self, 'pools'):\n            self.pools.clear()\n    # Hotfix for requests 2.32.0 and 2.32.1: its commit\n    # https://github.com/psf/requests/commit/c0813a2d910ea6b4f8438b91d315b8d181302356\n    # changes requests.adapters.HTTPAdapter to no longer call get_connection() from\n    # send(), but instead call _get_connection().\n    def _get_connection(self, request, *args, **kwargs):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.basehttpadapter",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.basehttpadapter",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.basehttpadapter",
        "peekOfCode": "__metaclass__ = type\nfrom .._import_helper import HTTPAdapter as _HTTPAdapter\nclass BaseHTTPAdapter(_HTTPAdapter):\n    def close(self):\n        super(BaseHTTPAdapter, self).close()\n        if hasattr(self, 'pools'):\n            self.pools.clear()\n    # Hotfix for requests 2.32.0 and 2.32.1: its commit\n    # https://github.com/psf/requests/commit/c0813a2d910ea6b4f8438b91d315b8d181302356\n    # changes requests.adapters.HTTPAdapter to no longer call get_connection() from",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.basehttpadapter",
        "documentation": {}
    },
    {
        "label": "NpipeHTTPConnection",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "peekOfCode": "class NpipeHTTPConnection(urllib3_connection.HTTPConnection, object):\n    def __init__(self, npipe_path, timeout=60):\n        super(NpipeHTTPConnection, self).__init__(\n            'localhost', timeout=timeout\n        )\n        self.npipe_path = npipe_path\n        self.timeout = timeout\n    def connect(self):\n        sock = NpipeSocket()\n        sock.settimeout(self.timeout)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "documentation": {}
    },
    {
        "label": "NpipeHTTPConnectionPool",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "peekOfCode": "class NpipeHTTPConnectionPool(urllib3.connectionpool.HTTPConnectionPool):\n    def __init__(self, npipe_path, timeout=60, maxsize=10):\n        super(NpipeHTTPConnectionPool, self).__init__(\n            'localhost', timeout=timeout, maxsize=maxsize\n        )\n        self.npipe_path = npipe_path\n        self.timeout = timeout\n    def _new_conn(self):\n        return NpipeHTTPConnection(\n            self.npipe_path, self.timeout",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "documentation": {}
    },
    {
        "label": "NpipeHTTPAdapter",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "peekOfCode": "class NpipeHTTPAdapter(BaseHTTPAdapter):\n    __attrs__ = HTTPAdapter.__attrs__ + ['npipe_path',\n                                         'pools',\n                                         'timeout',\n                                         'max_pool_size']\n    def __init__(self, base_url, timeout=60,\n                 pool_connections=constants.DEFAULT_NUM_POOLS,\n                 max_pool_size=constants.DEFAULT_MAX_POOL_SIZE):\n        self.npipe_path = base_url.replace('npipe://', '')\n        self.timeout = timeout",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "peekOfCode": "__metaclass__ = type\nfrom ansible.module_utils.six.moves.queue import Empty\nfrom .. import constants\nfrom .._import_helper import HTTPAdapter, urllib3, urllib3_connection\nfrom .basehttpadapter import BaseHTTPAdapter\nfrom .npipesocket import NpipeSocket\nRecentlyUsedContainer = urllib3._collections.RecentlyUsedContainer\nclass NpipeHTTPConnection(urllib3_connection.HTTPConnection, object):\n    def __init__(self, npipe_path, timeout=60):\n        super(NpipeHTTPConnection, self).__init__(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "documentation": {}
    },
    {
        "label": "RecentlyUsedContainer",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "peekOfCode": "RecentlyUsedContainer = urllib3._collections.RecentlyUsedContainer\nclass NpipeHTTPConnection(urllib3_connection.HTTPConnection, object):\n    def __init__(self, npipe_path, timeout=60):\n        super(NpipeHTTPConnection, self).__init__(\n            'localhost', timeout=timeout\n        )\n        self.npipe_path = npipe_path\n        self.timeout = timeout\n    def connect(self):\n        sock = NpipeSocket()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipeconn",
        "documentation": {}
    },
    {
        "label": "NpipeSocket",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "class NpipeSocket(object):\n    \"\"\" Partial implementation of the socket API over windows named pipes.\n        This implementation is only designed to be used as a client socket,\n        and server-specific methods (bind, listen, accept...) are not\n        implemented.\n    \"\"\"\n    def __init__(self, handle=None):\n        self._timeout = win32pipe.NMPWAIT_USE_DEFAULT_WAIT\n        self._handle = handle\n        self._closed = False",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "NpipeFileIOBase",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "class NpipeFileIOBase(io.RawIOBase):\n    def __init__(self, npipe_socket):\n        self.sock = npipe_socket\n    def close(self):\n        super(NpipeFileIOBase, self).close()\n        self.sock = None\n    def fileno(self):\n        return self.sock.fileno()\n    def isatty(self):\n        return False",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "check_closed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "def check_closed(f):\n    @functools.wraps(f)\n    def wrapped(self, *args, **kwargs):\n        if self._closed:\n            raise RuntimeError(\n                'Can not reuse socket after connection was closed.'\n            )\n        return f(self, *args, **kwargs)\n    return wrapped\nclass NpipeSocket(object):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "__metaclass__ = type\nimport functools\nimport io\nimport time\nimport traceback\nfrom ansible.module_utils.six import PY2\nPYWIN32_IMPORT_ERROR = None\ntry:\n    import win32file\n    import win32pipe",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "PYWIN32_IMPORT_ERROR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "PYWIN32_IMPORT_ERROR = None\ntry:\n    import win32file\n    import win32pipe\n    import pywintypes\n    import win32event\n    import win32api\nexcept ImportError:\n    PYWIN32_IMPORT_ERROR = traceback.format_exc()\ncERROR_PIPE_BUSY = 0xe7",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "cERROR_PIPE_BUSY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "cERROR_PIPE_BUSY = 0xe7\ncSECURITY_SQOS_PRESENT = 0x100000\ncSECURITY_ANONYMOUS = 0\nMAXIMUM_RETRY_COUNT = 10\ndef check_closed(f):\n    @functools.wraps(f)\n    def wrapped(self, *args, **kwargs):\n        if self._closed:\n            raise RuntimeError(\n                'Can not reuse socket after connection was closed.'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "cSECURITY_SQOS_PRESENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "cSECURITY_SQOS_PRESENT = 0x100000\ncSECURITY_ANONYMOUS = 0\nMAXIMUM_RETRY_COUNT = 10\ndef check_closed(f):\n    @functools.wraps(f)\n    def wrapped(self, *args, **kwargs):\n        if self._closed:\n            raise RuntimeError(\n                'Can not reuse socket after connection was closed.'\n            )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "cSECURITY_ANONYMOUS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "cSECURITY_ANONYMOUS = 0\nMAXIMUM_RETRY_COUNT = 10\ndef check_closed(f):\n    @functools.wraps(f)\n    def wrapped(self, *args, **kwargs):\n        if self._closed:\n            raise RuntimeError(\n                'Can not reuse socket after connection was closed.'\n            )\n        return f(self, *args, **kwargs)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "MAXIMUM_RETRY_COUNT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "peekOfCode": "MAXIMUM_RETRY_COUNT = 10\ndef check_closed(f):\n    @functools.wraps(f)\n    def wrapped(self, *args, **kwargs):\n        if self._closed:\n            raise RuntimeError(\n                'Can not reuse socket after connection was closed.'\n            )\n        return f(self, *args, **kwargs)\n    return wrapped",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.npipesocket",
        "documentation": {}
    },
    {
        "label": "SSHSocket",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "peekOfCode": "class SSHSocket(socket.socket):\n    def __init__(self, host):\n        super(SSHSocket, self).__init__(\n            socket.AF_INET, socket.SOCK_STREAM)\n        self.host = host\n        self.port = None\n        self.user = None\n        if ':' in self.host:\n            self.host, self.port = self.host.split(':')\n        if '@' in self.host:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "SSHConnection",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "peekOfCode": "class SSHConnection(urllib3_connection.HTTPConnection, object):\n    def __init__(self, ssh_transport=None, timeout=60, host=None):\n        super(SSHConnection, self).__init__(\n            'localhost', timeout=timeout\n        )\n        self.ssh_transport = ssh_transport\n        self.timeout = timeout\n        self.ssh_host = host\n    def connect(self):\n        if self.ssh_transport:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "SSHConnectionPool",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "peekOfCode": "class SSHConnectionPool(urllib3.connectionpool.HTTPConnectionPool):\n    scheme = 'ssh'\n    def __init__(self, ssh_client=None, timeout=60, maxsize=10, host=None):\n        super(SSHConnectionPool, self).__init__(\n            'localhost', timeout=timeout, maxsize=maxsize\n        )\n        self.ssh_transport = None\n        self.timeout = timeout\n        if ssh_client:\n            self.ssh_transport = ssh_client.get_transport()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "SSHHTTPAdapter",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "peekOfCode": "class SSHHTTPAdapter(BaseHTTPAdapter):\n    __attrs__ = HTTPAdapter.__attrs__ + [\n        'pools', 'timeout', 'ssh_client', 'ssh_params', 'max_pool_size'\n    ]\n    def __init__(self, base_url, timeout=60,\n                 pool_connections=constants.DEFAULT_NUM_POOLS,\n                 max_pool_size=constants.DEFAULT_MAX_POOL_SIZE,\n                 shell_out=False):\n        self.ssh_client = None\n        if not shell_out:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "peekOfCode": "__metaclass__ = type\nimport logging\nimport os\nimport signal\nimport socket\nimport subprocess\nimport traceback\nfrom ansible.module_utils.six import PY3\nfrom ansible.module_utils.six.moves.queue import Empty\nfrom ansible.module_utils.six.moves.urllib_parse import urlparse",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "PARAMIKO_IMPORT_ERROR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "peekOfCode": "PARAMIKO_IMPORT_ERROR = None\ntry:\n    import paramiko\nexcept ImportError:\n    PARAMIKO_IMPORT_ERROR = traceback.format_exc()\nRecentlyUsedContainer = urllib3._collections.RecentlyUsedContainer\nclass SSHSocket(socket.socket):\n    def __init__(self, host):\n        super(SSHSocket, self).__init__(\n            socket.AF_INET, socket.SOCK_STREAM)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "RecentlyUsedContainer",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "peekOfCode": "RecentlyUsedContainer = urllib3._collections.RecentlyUsedContainer\nclass SSHSocket(socket.socket):\n    def __init__(self, host):\n        super(SSHSocket, self).__init__(\n            socket.AF_INET, socket.SOCK_STREAM)\n        self.host = host\n        self.port = None\n        self.user = None\n        if ':' in self.host:\n            self.host, self.port = self.host.split(':')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn",
        "documentation": {}
    },
    {
        "label": "SSLHTTPAdapter",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "peekOfCode": "class SSLHTTPAdapter(BaseHTTPAdapter):\n    '''An HTTPS Transport Adapter that uses an arbitrary SSL version.'''\n    __attrs__ = HTTPAdapter.__attrs__ + ['assert_hostname', 'ssl_version']\n    def __init__(self, ssl_version=None, assert_hostname=None, **kwargs):\n        self.ssl_version = ssl_version\n        self.assert_hostname = assert_hostname\n        super(SSLHTTPAdapter, self).__init__(**kwargs)\n    def init_poolmanager(self, connections, maxsize, block=False):\n        kwargs = {\n            'num_pools': connections,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "peekOfCode": "__metaclass__ = type\n\"\"\" Resolves OpenSSL issues in some servers:\n      https://lukasa.co.uk/2013/01/Choosing_SSL_Version_In_Requests/\n      https://github.com/kennethreitz/requests/pull/799\n\"\"\"\nfrom ansible_collections.community.docker.plugins.module_utils.version import LooseVersion\nfrom .._import_helper import HTTPAdapter, urllib3\nfrom .basehttpadapter import BaseHTTPAdapter\nPoolManager = urllib3.poolmanager.PoolManager\nclass SSLHTTPAdapter(BaseHTTPAdapter):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "documentation": {}
    },
    {
        "label": "PoolManager",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "peekOfCode": "PoolManager = urllib3.poolmanager.PoolManager\nclass SSLHTTPAdapter(BaseHTTPAdapter):\n    '''An HTTPS Transport Adapter that uses an arbitrary SSL version.'''\n    __attrs__ = HTTPAdapter.__attrs__ + ['assert_hostname', 'ssl_version']\n    def __init__(self, ssl_version=None, assert_hostname=None, **kwargs):\n        self.ssl_version = ssl_version\n        self.assert_hostname = assert_hostname\n        super(SSLHTTPAdapter, self).__init__(**kwargs)\n    def init_poolmanager(self, connections, maxsize, block=False):\n        kwargs = {",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.ssladapter",
        "documentation": {}
    },
    {
        "label": "UnixHTTPConnection",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "peekOfCode": "class UnixHTTPConnection(urllib3_connection.HTTPConnection, object):\n    def __init__(self, base_url, unix_socket, timeout=60):\n        super(UnixHTTPConnection, self).__init__(\n            'localhost', timeout=timeout\n        )\n        self.base_url = base_url\n        self.unix_socket = unix_socket\n        self.timeout = timeout\n        self.disable_buffering = False\n    def connect(self):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "documentation": {}
    },
    {
        "label": "UnixHTTPConnectionPool",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "peekOfCode": "class UnixHTTPConnectionPool(urllib3.connectionpool.HTTPConnectionPool):\n    def __init__(self, base_url, socket_path, timeout=60, maxsize=10):\n        super(UnixHTTPConnectionPool, self).__init__(\n            'localhost', timeout=timeout, maxsize=maxsize\n        )\n        self.base_url = base_url\n        self.socket_path = socket_path\n        self.timeout = timeout\n    def _new_conn(self):\n        return UnixHTTPConnection(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "documentation": {}
    },
    {
        "label": "UnixHTTPAdapter",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "peekOfCode": "class UnixHTTPAdapter(BaseHTTPAdapter):\n    __attrs__ = HTTPAdapter.__attrs__ + ['pools',\n                                         'socket_path',\n                                         'timeout',\n                                         'max_pool_size']\n    def __init__(self, socket_url, timeout=60,\n                 pool_connections=constants.DEFAULT_NUM_POOLS,\n                 max_pool_size=constants.DEFAULT_MAX_POOL_SIZE):\n        socket_path = socket_url.replace('http+unix://', '')\n        if not socket_path.startswith('/'):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "peekOfCode": "__metaclass__ = type\nimport socket\nfrom ansible.module_utils.six import PY2\nfrom .basehttpadapter import BaseHTTPAdapter\nfrom .. import constants\nfrom .._import_helper import HTTPAdapter, urllib3, urllib3_connection\nRecentlyUsedContainer = urllib3._collections.RecentlyUsedContainer\nclass UnixHTTPConnection(urllib3_connection.HTTPConnection, object):\n    def __init__(self, base_url, unix_socket, timeout=60):\n        super(UnixHTTPConnection, self).__init__(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "documentation": {}
    },
    {
        "label": "RecentlyUsedContainer",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "peekOfCode": "RecentlyUsedContainer = urllib3._collections.RecentlyUsedContainer\nclass UnixHTTPConnection(urllib3_connection.HTTPConnection, object):\n    def __init__(self, base_url, unix_socket, timeout=60):\n        super(UnixHTTPConnection, self).__init__(\n            'localhost', timeout=timeout\n        )\n        self.base_url = base_url\n        self.unix_socket = unix_socket\n        self.timeout = timeout\n        self.disable_buffering = False",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.transport.unixconn",
        "documentation": {}
    },
    {
        "label": "CancellableStream",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.types.daemon",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.types.daemon",
        "peekOfCode": "class CancellableStream(object):\n    \"\"\"\n    Stream wrapper for real-time events, logs, etc. from the server.\n    Example:\n        >>> events = client.events()\n        >>> for event in events:\n        ...   print(event)\n        >>> # and cancel from another thread\n        >>> events.close()\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.types.daemon",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.types.daemon",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.types.daemon",
        "peekOfCode": "__metaclass__ = type\nimport socket\nfrom .._import_helper import urllib3\nfrom ..errors import DockerException\nclass CancellableStream(object):\n    \"\"\"\n    Stream wrapper for real-time events, logs, etc. from the server.\n    Example:\n        >>> events = client.events()\n        >>> for event in events:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.types.daemon",
        "documentation": {}
    },
    {
        "label": "PatternMatcher",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "class PatternMatcher(object):\n    def __init__(self, patterns):\n        self.patterns = list(filter(\n            lambda p: p.dirs, [Pattern(p) for p in patterns]\n        ))\n        self.patterns.append(Pattern('!.dockerignore'))\n    def matches(self, filepath):\n        matched = False\n        parent_path = os.path.dirname(filepath)\n        parent_path_dirs = split_path(parent_path)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "class Pattern(object):\n    def __init__(self, pattern_str):\n        self.exclusion = False\n        if pattern_str.startswith('!'):\n            self.exclusion = True\n            pattern_str = pattern_str[1:]\n        self.dirs = self.normalize(pattern_str)\n        self.cleaned_pattern = '/'.join(self.dirs)\n    @classmethod\n    def normalize(cls, p):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "tar",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def tar(path, exclude=None, dockerfile=None, fileobj=None, gzip=False):\n    root = os.path.abspath(path)\n    exclude = exclude or []\n    dockerfile = dockerfile or (None, None)\n    extra_files = []\n    if dockerfile[1] is not None:\n        dockerignore_contents = '\\n'.join(\n            (exclude or ['.dockerignore']) + [dockerfile[0]]\n        )\n        extra_files = [",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "exclude_paths",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def exclude_paths(root, patterns, dockerfile=None):\n    \"\"\"\n    Given a root directory path and a list of .dockerignore patterns, return\n    an iterator of all paths (both regular files and directories) in the root\n    directory that do *not* match any of the patterns.\n    All paths returned are relative to the root.\n    \"\"\"\n    if dockerfile is None:\n        dockerfile = 'Dockerfile'\n    patterns.append('!' + dockerfile)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "build_file_list",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def build_file_list(root):\n    files = []\n    for dirname, dirnames, fnames in os.walk(root):\n        for filename in fnames + dirnames:\n            longpath = os.path.join(dirname, filename)\n            files.append(\n                longpath.replace(root, '', 1).lstrip('/')\n            )\n    return files\ndef create_archive(root, files=None, fileobj=None, gzip=False,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "create_archive",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def create_archive(root, files=None, fileobj=None, gzip=False,\n                   extra_files=None):\n    extra_files = extra_files or []\n    if not fileobj:\n        fileobj = tempfile.NamedTemporaryFile()\n    t = tarfile.open(mode='w:gz' if gzip else 'w', fileobj=fileobj)\n    if files is None:\n        files = build_file_list(root)\n    extra_names = set(e[0] for e in extra_files)\n    for path in files:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "mkbuildcontext",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def mkbuildcontext(dockerfile):\n    f = tempfile.NamedTemporaryFile()\n    t = tarfile.open(mode='w', fileobj=f)\n    if isinstance(dockerfile, io.StringIO):\n        dfinfo = tarfile.TarInfo('Dockerfile')\n        if PY3:\n            raise TypeError('Please use io.BytesIO to create in-memory '\n                            'Dockerfiles with Python 3')\n        else:\n            dfinfo.size = len(dockerfile.getvalue())",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "split_path",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def split_path(p):\n    return [pt for pt in re.split(_SEP, p) if pt and pt != '.']\ndef normalize_slashes(p):\n    if IS_WINDOWS_PLATFORM:\n        return '/'.join(split_path(p))\n    return p\ndef walk(root, patterns, default=True):\n    pm = PatternMatcher(patterns)\n    return pm.walk(root)\n# Heavily based on",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "normalize_slashes",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def normalize_slashes(p):\n    if IS_WINDOWS_PLATFORM:\n        return '/'.join(split_path(p))\n    return p\ndef walk(root, patterns, default=True):\n    pm = PatternMatcher(patterns)\n    return pm.walk(root)\n# Heavily based on\n# https://github.com/moby/moby/blob/master/pkg/fileutils/fileutils.go\nclass PatternMatcher(object):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "walk",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def walk(root, patterns, default=True):\n    pm = PatternMatcher(patterns)\n    return pm.walk(root)\n# Heavily based on\n# https://github.com/moby/moby/blob/master/pkg/fileutils/fileutils.go\nclass PatternMatcher(object):\n    def __init__(self, patterns):\n        self.patterns = list(filter(\n            lambda p: p.dirs, [Pattern(p) for p in patterns]\n        ))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "process_dockerfile",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "def process_dockerfile(dockerfile, path):\n    if not dockerfile:\n        return (None, None)\n    abs_dockerfile = dockerfile\n    if not os.path.isabs(dockerfile):\n        abs_dockerfile = os.path.join(path, dockerfile)\n        if IS_WINDOWS_PLATFORM and path.startswith(\n                WINDOWS_LONGPATH_PREFIX):\n            abs_dockerfile = '{0}{1}'.format(\n                WINDOWS_LONGPATH_PREFIX,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "__metaclass__ = type\nimport io\nimport os\nimport random\nimport re\nimport tarfile\nimport tempfile\nfrom ansible.module_utils.six import PY3\nfrom . import fnmatch\nfrom ..constants import IS_WINDOWS_PLATFORM, WINDOWS_LONGPATH_PREFIX",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "_SEP",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "peekOfCode": "_SEP = re.compile('/|\\\\\\\\') if IS_WINDOWS_PLATFORM else re.compile('/')\ndef tar(path, exclude=None, dockerfile=None, fileobj=None, gzip=False):\n    root = os.path.abspath(path)\n    exclude = exclude or []\n    dockerfile = dockerfile or (None, None)\n    extra_files = []\n    if dockerfile[1] is not None:\n        dockerignore_contents = '\\n'.join(\n            (exclude or ['.dockerignore']) + [dockerfile[0]]\n        )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.build",
        "documentation": {}
    },
    {
        "label": "find_config_file",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "def find_config_file(config_path=None):\n    paths = list(filter(None, [\n        config_path,  # 1\n        config_path_from_environment(),  # 2\n        os.path.join(home_dir(), DOCKER_CONFIG_FILENAME),  # 3\n        os.path.join(home_dir(), LEGACY_DOCKER_CONFIG_FILENAME),  # 4\n    ]))\n    log.debug(\"Trying paths: %s\", repr(paths))\n    for path in paths:\n        if os.path.exists(path):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "config_path_from_environment",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "def config_path_from_environment():\n    config_dir = os.environ.get('DOCKER_CONFIG')\n    if not config_dir:\n        return None\n    return os.path.join(config_dir, os.path.basename(DOCKER_CONFIG_FILENAME))\ndef home_dir():\n    \"\"\"\n    Get the user's home directory, using the same logic as the Docker Engine\n    client - use %USERPROFILE% on Windows, $HOME/getuid on POSIX.\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "home_dir",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "def home_dir():\n    \"\"\"\n    Get the user's home directory, using the same logic as the Docker Engine\n    client - use %USERPROFILE% on Windows, $HOME/getuid on POSIX.\n    \"\"\"\n    if IS_WINDOWS_PLATFORM:\n        return os.environ.get('USERPROFILE', '')\n    else:\n        return os.path.expanduser('~')\ndef load_general_config(config_path=None):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "load_general_config",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "def load_general_config(config_path=None):\n    config_file = find_config_file(config_path)\n    if not config_file:\n        return {}\n    try:\n        with open(config_file) as f:\n            return json.load(f)\n    except (IOError, ValueError) as e:\n        # In the case of a legacy `.dockercfg` file, we won't\n        # be able to load any JSON data.",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport logging\nimport os\nfrom ..constants import IS_WINDOWS_PLATFORM\nDOCKER_CONFIG_FILENAME = os.path.join('.docker', 'config.json')\nLEGACY_DOCKER_CONFIG_FILENAME = '.dockercfg'\nlog = logging.getLogger(__name__)\ndef find_config_file(config_path=None):\n    paths = list(filter(None, [",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "DOCKER_CONFIG_FILENAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "DOCKER_CONFIG_FILENAME = os.path.join('.docker', 'config.json')\nLEGACY_DOCKER_CONFIG_FILENAME = '.dockercfg'\nlog = logging.getLogger(__name__)\ndef find_config_file(config_path=None):\n    paths = list(filter(None, [\n        config_path,  # 1\n        config_path_from_environment(),  # 2\n        os.path.join(home_dir(), DOCKER_CONFIG_FILENAME),  # 3\n        os.path.join(home_dir(), LEGACY_DOCKER_CONFIG_FILENAME),  # 4\n    ]))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "LEGACY_DOCKER_CONFIG_FILENAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "LEGACY_DOCKER_CONFIG_FILENAME = '.dockercfg'\nlog = logging.getLogger(__name__)\ndef find_config_file(config_path=None):\n    paths = list(filter(None, [\n        config_path,  # 1\n        config_path_from_environment(),  # 2\n        os.path.join(home_dir(), DOCKER_CONFIG_FILENAME),  # 3\n        os.path.join(home_dir(), LEGACY_DOCKER_CONFIG_FILENAME),  # 4\n    ]))\n    log.debug(\"Trying paths: %s\", repr(paths))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef find_config_file(config_path=None):\n    paths = list(filter(None, [\n        config_path,  # 1\n        config_path_from_environment(),  # 2\n        os.path.join(home_dir(), DOCKER_CONFIG_FILENAME),  # 3\n        os.path.join(home_dir(), LEGACY_DOCKER_CONFIG_FILENAME),  # 4\n    ]))\n    log.debug(\"Trying paths: %s\", repr(paths))\n    for path in paths:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.config",
        "documentation": {}
    },
    {
        "label": "check_resource",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "peekOfCode": "def check_resource(resource_name):\n    def decorator(f):\n        @functools.wraps(f)\n        def wrapped(self, resource_id=None, *args, **kwargs):\n            if resource_id is None and kwargs.get(resource_name):\n                resource_id = kwargs.pop(resource_name)\n            if isinstance(resource_id, dict):\n                resource_id = resource_id.get('Id', resource_id.get('ID'))\n            if not resource_id:\n                raise errors.NullResource(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "documentation": {}
    },
    {
        "label": "minimum_version",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "peekOfCode": "def minimum_version(version):\n    def decorator(f):\n        @functools.wraps(f)\n        def wrapper(self, *args, **kwargs):\n            if utils.version_lt(self._version, version):\n                raise errors.InvalidVersion(\n                    '{0} is not available for version < {1}'.format(\n                        f.__name__, version\n                    )\n                )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "documentation": {}
    },
    {
        "label": "update_headers",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "peekOfCode": "def update_headers(f):\n    def inner(self, *args, **kwargs):\n        if 'HttpHeaders' in self._general_configs:\n            if not kwargs.get('headers'):\n                kwargs['headers'] = self._general_configs['HttpHeaders']\n            else:\n                kwargs['headers'].update(self._general_configs['HttpHeaders'])\n        return f(self, *args, **kwargs)\n    return inner",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "peekOfCode": "__metaclass__ = type\nimport functools\nfrom .. import errors\nfrom . import utils\ndef check_resource(resource_name):\n    def decorator(f):\n        @functools.wraps(f)\n        def wrapped(self, resource_id=None, *args, **kwargs):\n            if resource_id is None and kwargs.get(resource_name):\n                resource_id = kwargs.pop(resource_name)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.decorators",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "peekOfCode": "def fnmatch(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN.\n    Patterns are Unix shell style:\n    *       matches everything\n    ?       matches any single character\n    [seq]   matches any character in seq\n    [!seq]  matches any char not in seq\n    An initial period in FILENAME is not special.\n    Both FILENAME and PATTERN are first case-normalized\n    if the operating system requires it.",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatchcase",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "peekOfCode": "def fnmatchcase(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN, including case.\n    This is a version of fnmatch() which doesn't case-normalize\n    its arguments.\n    \"\"\"\n    try:\n        re_pat = _cache[pat]\n    except KeyError:\n        res = translate(pat)\n        if len(_cache) >= _MAXCACHE:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "documentation": {}
    },
    {
        "label": "translate",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "peekOfCode": "def translate(pat):\n    \"\"\"Translate a shell PATTERN to a regular expression.\n    There is no way to quote meta-characters.\n    \"\"\"\n    i, n = 0, len(pat)\n    res = '^'\n    while i < n:\n        c = pat[i]\n        i = i + 1\n        if c == '*':",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "peekOfCode": "__metaclass__ = type\n\"\"\"Filename matching with shell patterns.\nfnmatch(FILENAME, PATTERN) matches according to the local convention.\nfnmatchcase(FILENAME, PATTERN) always takes case in account.\nThe functions operate by translating the pattern into a regular\nexpression.  They cache the compiled regular expressions for speed.\nThe function translate(PATTERN) returns a regular expression\ncorresponding to PATTERN.  (It does not compile it.)\n\"\"\"\nimport re",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "peekOfCode": "__all__ = [\"fnmatch\", \"fnmatchcase\", \"translate\"]\n_cache = {}\n_MAXCACHE = 100\ndef _purge():\n    \"\"\"Clear the pattern cache\"\"\"\n    _cache.clear()\ndef fnmatch(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN.\n    Patterns are Unix shell style:\n    *       matches everything",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "documentation": {}
    },
    {
        "label": "_cache",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "peekOfCode": "_cache = {}\n_MAXCACHE = 100\ndef _purge():\n    \"\"\"Clear the pattern cache\"\"\"\n    _cache.clear()\ndef fnmatch(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN.\n    Patterns are Unix shell style:\n    *       matches everything\n    ?       matches any single character",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "documentation": {}
    },
    {
        "label": "_MAXCACHE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "peekOfCode": "_MAXCACHE = 100\ndef _purge():\n    \"\"\"Clear the pattern cache\"\"\"\n    _cache.clear()\ndef fnmatch(name, pat):\n    \"\"\"Test whether FILENAME matches PATTERN.\n    Patterns are Unix shell style:\n    *       matches everything\n    ?       matches any single character\n    [seq]   matches any character in seq",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.fnmatch",
        "documentation": {}
    },
    {
        "label": "stream_as_text",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "peekOfCode": "def stream_as_text(stream):\n    \"\"\"\n    Given a stream of bytes or text, if any of the items in the stream\n    are bytes convert them to text.\n    This function can be removed once we return text streams\n    instead of byte streams.\n    \"\"\"\n    for data in stream:\n        if not isinstance(data, text_type):\n            data = data.decode('utf-8', 'replace')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "json_splitter",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "peekOfCode": "def json_splitter(buffer):\n    \"\"\"Attempt to parse a json object from a buffer. If there is at least one\n    object, return it and the rest of the buffer, otherwise return None.\n    \"\"\"\n    buffer = buffer.strip()\n    try:\n        obj, index = json_decoder.raw_decode(buffer)\n        rest = buffer[json.decoder.WHITESPACE.match(buffer, index).end():]\n        return obj, rest\n    except ValueError:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "json_stream",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "peekOfCode": "def json_stream(stream):\n    \"\"\"Given a stream of text, return a stream of json objects.\n    This handles streams which are inconsistently buffered (some entries may\n    be newline delimited, and others are not).\n    \"\"\"\n    return split_buffer(stream, json_splitter, json_decoder.decode)\ndef line_splitter(buffer, separator=u'\\n'):\n    index = buffer.find(text_type(separator))\n    if index == -1:\n        return None",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "line_splitter",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "peekOfCode": "def line_splitter(buffer, separator=u'\\n'):\n    index = buffer.find(text_type(separator))\n    if index == -1:\n        return None\n    return buffer[:index + 1], buffer[index + 1:]\ndef split_buffer(stream, splitter=None, decoder=lambda a: a):\n    \"\"\"Given a generator which yields strings and a splitter function,\n    joins all input, splits on the separator and yields each chunk.\n    Unlike string.split(), each chunk includes the trailing\n    separator, except for the last one if none was found on the end",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "split_buffer",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "peekOfCode": "def split_buffer(stream, splitter=None, decoder=lambda a: a):\n    \"\"\"Given a generator which yields strings and a splitter function,\n    joins all input, splits on the separator and yields each chunk.\n    Unlike string.split(), each chunk includes the trailing\n    separator, except for the last one if none was found on the end\n    of the input.\n    \"\"\"\n    splitter = splitter or line_splitter\n    buffered = text_type('')\n    for data in stream_as_text(stream):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport json.decoder\nfrom ansible.module_utils.six import text_type\nfrom ..errors import StreamParseError\njson_decoder = json.JSONDecoder()\ndef stream_as_text(stream):\n    \"\"\"\n    Given a stream of bytes or text, if any of the items in the stream\n    are bytes convert them to text.",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "json_decoder",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "peekOfCode": "json_decoder = json.JSONDecoder()\ndef stream_as_text(stream):\n    \"\"\"\n    Given a stream of bytes or text, if any of the items in the stream\n    are bytes convert them to text.\n    This function can be removed once we return text streams\n    instead of byte streams.\n    \"\"\"\n    for data in stream:\n        if not isinstance(data, text_type):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream",
        "documentation": {}
    },
    {
        "label": "add_port_mapping",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "peekOfCode": "def add_port_mapping(port_bindings, internal_port, external):\n    if internal_port in port_bindings:\n        port_bindings[internal_port].append(external)\n    else:\n        port_bindings[internal_port] = [external]\ndef add_port(port_bindings, internal_port_range, external_range):\n    if external_range is None:\n        for internal_port in internal_port_range:\n            add_port_mapping(port_bindings, internal_port, None)\n    else:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "add_port",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "peekOfCode": "def add_port(port_bindings, internal_port_range, external_range):\n    if external_range is None:\n        for internal_port in internal_port_range:\n            add_port_mapping(port_bindings, internal_port, None)\n    else:\n        ports = zip(internal_port_range, external_range)\n        for internal_port, external_port in ports:\n            add_port_mapping(port_bindings, internal_port, external_port)\ndef build_port_bindings(ports):\n    port_bindings = {}",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "build_port_bindings",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "peekOfCode": "def build_port_bindings(ports):\n    port_bindings = {}\n    for port in ports:\n        internal_port_range, external_range = split_port(port)\n        add_port(port_bindings, internal_port_range, external_range)\n    return port_bindings\ndef _raise_invalid_port(port):\n    raise ValueError('Invalid port \"%s\", should be '\n                     '[[remote_ip:]remote_port[-remote_port]:]'\n                     'port[/protocol]' % port)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "port_range",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "peekOfCode": "def port_range(start, end, proto, randomly_available_port=False):\n    if not start:\n        return start\n    if not end:\n        return [start + proto]\n    if randomly_available_port:\n        return ['{0}-{1}'.format(start, end) + proto]\n    return [str(port) + proto for port in range(int(start), int(end) + 1)]\ndef split_port(port):\n    if hasattr(port, 'legacy_repr'):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "split_port",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "peekOfCode": "def split_port(port):\n    if hasattr(port, 'legacy_repr'):\n        # This is the worst hack, but it prevents a bug in Compose 1.14.0\n        # https://github.com/docker/docker-py/issues/1668\n        # TODO: remove once fixed in Compose stable\n        port = port.legacy_repr()\n    port = str(port)\n    match = PORT_SPEC.match(port)\n    if match is None:\n        _raise_invalid_port(port)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "peekOfCode": "__metaclass__ = type\nimport re\nPORT_SPEC = re.compile(\n    \"^\"  # Match full string\n    \"(\"  # External part\n    r\"(\\[?(?P<host>[a-fA-F\\d.:]+)\\]?:)?\"  # Address\n    r\"(?P<ext>[\\d]*)(-(?P<ext_end>[\\d]+))?:\"  # External range\n    \")?\"\n    r\"(?P<int>[\\d]+)(-(?P<int_end>[\\d]+))?\"  # Internal range\n    \"(?P<proto>/(udp|tcp|sctp))?\"  # Protocol",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "PORT_SPEC",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "peekOfCode": "PORT_SPEC = re.compile(\n    \"^\"  # Match full string\n    \"(\"  # External part\n    r\"(\\[?(?P<host>[a-fA-F\\d.:]+)\\]?:)?\"  # Address\n    r\"(?P<ext>[\\d]*)(-(?P<ext_end>[\\d]+))?:\"  # External range\n    \")?\"\n    r\"(?P<int>[\\d]+)(-(?P<int_end>[\\d]+))?\"  # Internal range\n    \"(?P<proto>/(udp|tcp|sctp))?\"  # Protocol\n    \"$\"  # Match full string\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.ports",
        "documentation": {}
    },
    {
        "label": "ProxyConfig",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "peekOfCode": "class ProxyConfig(dict):\n    '''\n    Hold the client's proxy configuration\n    '''\n    @property\n    def http(self):\n        return self.get('http')\n    @property\n    def https(self):\n        return self.get('https')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "peekOfCode": "__metaclass__ = type\nfrom .utils import format_environment\nclass ProxyConfig(dict):\n    '''\n    Hold the client's proxy configuration\n    '''\n    @property\n    def http(self):\n        return self.get('http')\n    @property",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.proxy",
        "documentation": {}
    },
    {
        "label": "SocketError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "class SocketError(Exception):\n    pass\n# NpipeSockets have their own error types\n# pywintypes.error: (109, 'ReadFile', 'The pipe has been ended.')\nNPIPE_ENDED = 109\ndef read(socket, n=4096):\n    \"\"\"\n    Reads at most n bytes from socket\n    \"\"\"\n    recoverable_errors = (errno.EINTR, errno.EDEADLK, errno.EWOULDBLOCK)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def read(socket, n=4096):\n    \"\"\"\n    Reads at most n bytes from socket\n    \"\"\"\n    recoverable_errors = (errno.EINTR, errno.EDEADLK, errno.EWOULDBLOCK)\n    if PY3 and not isinstance(socket, NpipeSocket):\n        if not hasattr(select, \"poll\"):\n            # Limited to 1024\n            select.select([socket], [], [])\n        else:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "read_exactly",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def read_exactly(socket, n):\n    \"\"\"\n    Reads exactly n bytes from socket\n    Raises SocketError if there isn't enough data\n    \"\"\"\n    data = binary_type()\n    while len(data) < n:\n        next_data = read(socket, n - len(data))\n        if not next_data:\n            raise SocketError(\"Unexpected EOF\")",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "next_frame_header",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def next_frame_header(socket):\n    \"\"\"\n    Returns the stream and size of the next frame of data waiting to be read\n    from socket, according to the protocol defined here:\n    https://docs.docker.com/engine/api/v1.24/#attach-to-a-container\n    \"\"\"\n    try:\n        data = read_exactly(socket, 8)\n    except SocketError:\n        return (-1, -1)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "frames_iter",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def frames_iter(socket, tty):\n    \"\"\"\n    Return a generator of frames read from socket. A frame is a tuple where\n    the first item is the stream number and the second item is a chunk of data.\n    If the tty setting is enabled, the streams are multiplexed into the stdout\n    stream.\n    \"\"\"\n    if tty:\n        return ((STDOUT, frame) for frame in frames_iter_tty(socket))\n    else:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "frames_iter_no_tty",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def frames_iter_no_tty(socket):\n    \"\"\"\n    Returns a generator of data read from the socket when the tty setting is\n    not enabled.\n    \"\"\"\n    while True:\n        (stream, n) = next_frame_header(socket)\n        if n < 0:\n            break\n        while n > 0:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "frames_iter_tty",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def frames_iter_tty(socket):\n    \"\"\"\n    Return a generator of data read from the socket when the tty setting is\n    enabled.\n    \"\"\"\n    while True:\n        result = read(socket)\n        if len(result) == 0:\n            # We have reached EOF\n            return",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "consume_socket_output",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def consume_socket_output(frames, demux=False):\n    \"\"\"\n    Iterate through frames read from the socket and return the result.\n    Args:\n        demux (bool):\n            If False, stdout and stderr are multiplexed, and the result is the\n            concatenation of all the frames. If True, the streams are\n            demultiplexed, and the result is a 2-tuple where each item is the\n            concatenation of frames belonging to the same stream.\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "demux_adaptor",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "def demux_adaptor(stream_id, data):\n    \"\"\"\n    Utility to demultiplex stdout and stderr when reading frames from the\n    socket.\n    \"\"\"\n    if stream_id == STDOUT:\n        return (data, None)\n    elif stream_id == STDERR:\n        return (None, data)\n    else:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "__metaclass__ = type\nimport errno\nimport os\nimport select\nimport socket as pysocket\nimport struct\nfrom ansible.module_utils.six import PY3, binary_type\nfrom ..transport.npipesocket import NpipeSocket\nSTDOUT = 1\nSTDERR = 2",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "STDOUT = 1\nSTDERR = 2\nclass SocketError(Exception):\n    pass\n# NpipeSockets have their own error types\n# pywintypes.error: (109, 'ReadFile', 'The pipe has been ended.')\nNPIPE_ENDED = 109\ndef read(socket, n=4096):\n    \"\"\"\n    Reads at most n bytes from socket",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "STDERR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "STDERR = 2\nclass SocketError(Exception):\n    pass\n# NpipeSockets have their own error types\n# pywintypes.error: (109, 'ReadFile', 'The pipe has been ended.')\nNPIPE_ENDED = 109\ndef read(socket, n=4096):\n    \"\"\"\n    Reads at most n bytes from socket\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "NPIPE_ENDED",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "peekOfCode": "NPIPE_ENDED = 109\ndef read(socket, n=4096):\n    \"\"\"\n    Reads at most n bytes from socket\n    \"\"\"\n    recoverable_errors = (errno.EINTR, errno.EDEADLK, errno.EWOULDBLOCK)\n    if PY3 and not isinstance(socket, NpipeSocket):\n        if not hasattr(select, \"poll\"):\n            # Limited to 1024\n            select.select([socket], [], [])",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.socket",
        "documentation": {}
    },
    {
        "label": "create_ipam_pool",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def create_ipam_pool(*args, **kwargs):\n    raise errors.DeprecatedMethod(\n        'utils.create_ipam_pool has been removed. Please use a '\n        'docker.types.IPAMPool object instead.'\n    )\ndef create_ipam_config(*args, **kwargs):\n    raise errors.DeprecatedMethod(\n        'utils.create_ipam_config has been removed. Please use a '\n        'docker.types.IPAMConfig object instead.'\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "create_ipam_config",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def create_ipam_config(*args, **kwargs):\n    raise errors.DeprecatedMethod(\n        'utils.create_ipam_config has been removed. Please use a '\n        'docker.types.IPAMConfig object instead.'\n    )\ndef decode_json_header(header):\n    data = base64.b64decode(header)\n    if PY3:\n        data = data.decode('utf-8')\n    return json.loads(data)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "decode_json_header",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def decode_json_header(header):\n    data = base64.b64decode(header)\n    if PY3:\n        data = data.decode('utf-8')\n    return json.loads(data)\ndef compare_version(v1, v2):\n    \"\"\"Compare docker versions\n    >>> v1 = '1.9'\n    >>> v2 = '1.10'\n    >>> compare_version(v1, v2)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "compare_version",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def compare_version(v1, v2):\n    \"\"\"Compare docker versions\n    >>> v1 = '1.9'\n    >>> v2 = '1.10'\n    >>> compare_version(v1, v2)\n    1\n    >>> compare_version(v2, v1)\n    -1\n    >>> compare_version(v2, v2)\n    0",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "version_lt",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def version_lt(v1, v2):\n    return compare_version(v1, v2) > 0\ndef version_gte(v1, v2):\n    return not version_lt(v1, v2)\ndef _convert_port_binding(binding):\n    result = {'HostIp': '', 'HostPort': ''}\n    if isinstance(binding, tuple):\n        if len(binding) == 2:\n            result['HostPort'] = binding[1]\n            result['HostIp'] = binding[0]",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "version_gte",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def version_gte(v1, v2):\n    return not version_lt(v1, v2)\ndef _convert_port_binding(binding):\n    result = {'HostIp': '', 'HostPort': ''}\n    if isinstance(binding, tuple):\n        if len(binding) == 2:\n            result['HostPort'] = binding[1]\n            result['HostIp'] = binding[0]\n        elif isinstance(binding[0], string_types):\n            result['HostIp'] = binding[0]",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_port_bindings",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def convert_port_bindings(port_bindings):\n    result = {}\n    for k, v in iteritems(port_bindings):\n        key = str(k)\n        if '/' not in key:\n            key += '/tcp'\n        if isinstance(v, list):\n            result[key] = [_convert_port_binding(binding) for binding in v]\n        else:\n            result[key] = [_convert_port_binding(v)]",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_volume_binds",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def convert_volume_binds(binds):\n    if isinstance(binds, list):\n        return binds\n    result = []\n    for k, v in binds.items():\n        if isinstance(k, binary_type):\n            k = k.decode('utf-8')\n        if isinstance(v, dict):\n            if 'ro' in v and 'mode' in v:\n                raise ValueError(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_tmpfs_mounts",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def convert_tmpfs_mounts(tmpfs):\n    if isinstance(tmpfs, dict):\n        return tmpfs\n    if not isinstance(tmpfs, list):\n        raise ValueError(\n            'Expected tmpfs value to be either a list or a dict, found: {0}'\n            .format(type(tmpfs).__name__)\n        )\n    result = {}\n    for mount in tmpfs:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_service_networks",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def convert_service_networks(networks):\n    if not networks:\n        return networks\n    if not isinstance(networks, list):\n        raise TypeError('networks parameter must be a list.')\n    result = []\n    for n in networks:\n        if isinstance(n, string_types):\n            n = {'Target': n}\n        result.append(n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_repository_tag",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def parse_repository_tag(repo_name):\n    parts = repo_name.rsplit('@', 1)\n    if len(parts) == 2:\n        return tuple(parts)\n    parts = repo_name.rsplit(':', 1)\n    if len(parts) == 2 and '/' not in parts[1]:\n        return tuple(parts)\n    return repo_name, None\ndef parse_host(addr, is_win32=False, tls=False):\n    # Sensible defaults",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_host",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def parse_host(addr, is_win32=False, tls=False):\n    # Sensible defaults\n    if not addr and is_win32:\n        return DEFAULT_NPIPE\n    if not addr or addr.strip() == 'unix://':\n        return DEFAULT_UNIX_SOCKET\n    addr = addr.strip()\n    parsed_url = urlparse(addr)\n    proto = parsed_url.scheme\n    if not proto or any(x not in string.ascii_letters + '+' for x in proto):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_devices",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def parse_devices(devices):\n    device_list = []\n    for device in devices:\n        if isinstance(device, dict):\n            device_list.append(device)\n            continue\n        if not isinstance(device, string_types):\n            raise errors.DockerException(\n                'Invalid device type {0}'.format(type(device))\n            )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "kwargs_from_env",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def kwargs_from_env(ssl_version=None, assert_hostname=None, environment=None):\n    if not environment:\n        environment = os.environ\n    host = environment.get('DOCKER_HOST')\n    # empty string for cert path is the same as unset.\n    cert_path = environment.get('DOCKER_CERT_PATH') or None\n    # empty string for tls verify counts as \"false\".\n    # Any value or 'unset' counts as true.\n    tls_verify = environment.get('DOCKER_TLS_VERIFY')\n    if tls_verify == '':",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "convert_filters",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def convert_filters(filters):\n    result = {}\n    for k, v in iteritems(filters):\n        if isinstance(v, bool):\n            v = 'true' if v else 'false'\n        if not isinstance(v, list):\n            v = [v, ]\n        result[k] = [\n            str(item) if not isinstance(item, string_types) else item\n            for item in v",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_bytes",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def parse_bytes(s):\n    if isinstance(s, integer_types + (float,)):\n        return s\n    if len(s) == 0:\n        return 0\n    if s[-2:-1].isalpha() and s[-1].isalpha():\n        if s[-1] == \"b\" or s[-1] == \"B\":\n            s = s[:-1]\n    units = BYTE_UNITS\n    suffix = s[-1].lower()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "normalize_links",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def normalize_links(links):\n    if isinstance(links, dict):\n        links = iteritems(links)\n    return ['{0}:{1}'.format(k, v) if v else k for k, v in sorted(links)]\ndef parse_env_file(env_file):\n    \"\"\"\n    Reads a line-separated environment file.\n    The format of each line should be \"key=value\".\n    \"\"\"\n    environment = {}",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "parse_env_file",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def parse_env_file(env_file):\n    \"\"\"\n    Reads a line-separated environment file.\n    The format of each line should be \"key=value\".\n    \"\"\"\n    environment = {}\n    with open(env_file, 'r') as f:\n        for line in f:\n            if line[0] == '#':\n                continue",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "split_command",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def split_command(command):\n    if PY2 and not isinstance(command, binary_type):\n        command = command.encode('utf-8')\n    return shlex.split(command)\ndef format_environment(environment):\n    def format_env(key, value):\n        if value is None:\n            return key\n        if isinstance(value, binary_type):\n            value = value.decode('utf-8')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "format_environment",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def format_environment(environment):\n    def format_env(key, value):\n        if value is None:\n            return key\n        if isinstance(value, binary_type):\n            value = value.decode('utf-8')\n        return u'{key}={value}'.format(key=key, value=value)\n    return [format_env(*var) for var in iteritems(environment)]\ndef format_extra_hosts(extra_hosts, task=False):\n    # Use format dictated by Swarm API if container is part of a task",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "format_extra_hosts",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def format_extra_hosts(extra_hosts, task=False):\n    # Use format dictated by Swarm API if container is part of a task\n    if task:\n        return [\n            '{0} {1}'.format(v, k) for k, v in sorted(iteritems(extra_hosts))\n        ]\n    return [\n        '{0}:{1}'.format(k, v) for k, v in sorted(iteritems(extra_hosts))\n    ]\ndef create_host_config(self, *args, **kwargs):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "create_host_config",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "def create_host_config(self, *args, **kwargs):\n    raise errors.DeprecatedMethod(\n        'utils.create_host_config has been removed. Please use a '\n        'docker.types.HostConfig object instead.'\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "__metaclass__ = type\nimport base64\nimport collections\nimport json\nimport os\nimport os.path\nimport shlex\nimport string\nfrom ansible_collections.community.docker.plugins.module_utils.version import StrictVersion\nfrom ansible.module_utils.six import PY2, PY3, binary_type, integer_types, iteritems, string_types, text_type",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "URLComponents",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "peekOfCode": "URLComponents = collections.namedtuple(\n    'URLComponents',\n    'scheme netloc url params query fragment',\n)\ndef create_ipam_pool(*args, **kwargs):\n    raise errors.DeprecatedMethod(\n        'utils.create_ipam_pool has been removed. Please use a '\n        'docker.types.IPAMPool object instead.'\n    )\ndef create_ipam_config(*args, **kwargs):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.utils.utils",
        "documentation": {}
    },
    {
        "label": "fail_on_missing_imports",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "peekOfCode": "def fail_on_missing_imports():\n    if REQUESTS_IMPORT_ERROR is not None:\n        from .errors import MissingRequirementException\n        raise MissingRequirementException(\n            'You have to install requests',\n            'requests', REQUESTS_IMPORT_ERROR)\n    if URLLIB3_IMPORT_ERROR is not None:\n        from .errors import MissingRequirementException\n        raise MissingRequirementException(\n            'You have to install urllib3',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "peekOfCode": "__metaclass__ = type\nimport traceback\nfrom ansible.module_utils.six import PY2\nREQUESTS_IMPORT_ERROR = None\nURLLIB3_IMPORT_ERROR = None\nBACKPORTS_SSL_MATCH_HOSTNAME_IMPORT_ERROR = None\ntry:\n    from requests import Session  # noqa: F401, pylint: disable=unused-import\n    from requests.adapters import HTTPAdapter  # noqa: F401, pylint: disable=unused-import\n    from requests.exceptions import HTTPError, InvalidSchema  # noqa: F401, pylint: disable=unused-import",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "documentation": {}
    },
    {
        "label": "REQUESTS_IMPORT_ERROR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "peekOfCode": "REQUESTS_IMPORT_ERROR = None\nURLLIB3_IMPORT_ERROR = None\nBACKPORTS_SSL_MATCH_HOSTNAME_IMPORT_ERROR = None\ntry:\n    from requests import Session  # noqa: F401, pylint: disable=unused-import\n    from requests.adapters import HTTPAdapter  # noqa: F401, pylint: disable=unused-import\n    from requests.exceptions import HTTPError, InvalidSchema  # noqa: F401, pylint: disable=unused-import\nexcept ImportError:\n    REQUESTS_IMPORT_ERROR = traceback.format_exc()\n    class Session(object):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "documentation": {}
    },
    {
        "label": "URLLIB3_IMPORT_ERROR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "peekOfCode": "URLLIB3_IMPORT_ERROR = None\nBACKPORTS_SSL_MATCH_HOSTNAME_IMPORT_ERROR = None\ntry:\n    from requests import Session  # noqa: F401, pylint: disable=unused-import\n    from requests.adapters import HTTPAdapter  # noqa: F401, pylint: disable=unused-import\n    from requests.exceptions import HTTPError, InvalidSchema  # noqa: F401, pylint: disable=unused-import\nexcept ImportError:\n    REQUESTS_IMPORT_ERROR = traceback.format_exc()\n    class Session(object):\n        __attrs__ = []",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "documentation": {}
    },
    {
        "label": "BACKPORTS_SSL_MATCH_HOSTNAME_IMPORT_ERROR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "peekOfCode": "BACKPORTS_SSL_MATCH_HOSTNAME_IMPORT_ERROR = None\ntry:\n    from requests import Session  # noqa: F401, pylint: disable=unused-import\n    from requests.adapters import HTTPAdapter  # noqa: F401, pylint: disable=unused-import\n    from requests.exceptions import HTTPError, InvalidSchema  # noqa: F401, pylint: disable=unused-import\nexcept ImportError:\n    REQUESTS_IMPORT_ERROR = traceback.format_exc()\n    class Session(object):\n        __attrs__ = []\n    class HTTPAdapter(object):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api._import_helper",
        "documentation": {}
    },
    {
        "label": "AuthConfig",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "class AuthConfig(dict):\n    def __init__(self, dct, credstore_env=None):\n        if 'auths' not in dct:\n            dct['auths'] = {}\n        self.update(dct)\n        self._credstore_env = credstore_env\n        self._stores = {}\n    @classmethod\n    def parse_auth(cls, entries, raise_on_error=False):\n        \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "resolve_repository_name",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def resolve_repository_name(repo_name):\n    if '://' in repo_name:\n        raise errors.InvalidRepository(\n            'Repository name cannot contain a scheme ({0})'.format(repo_name)\n        )\n    index_name, remote_name = split_repo_name(repo_name)\n    if index_name[0] == '-' or index_name[-1] == '-':\n        raise errors.InvalidRepository(\n            'Invalid index name ({0}). Cannot begin or end with a'\n            ' hyphen.'.format(index_name)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "resolve_index_name",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def resolve_index_name(index_name):\n    index_name = convert_to_hostname(index_name)\n    if index_name == 'index.' + INDEX_NAME:\n        index_name = INDEX_NAME\n    return index_name\ndef get_config_header(client, registry):\n    log.debug('Looking for auth config')\n    if not client._auth_configs or client._auth_configs.is_empty:\n        log.debug(\n            \"No auth config in memory - loading from filesystem\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "get_config_header",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def get_config_header(client, registry):\n    log.debug('Looking for auth config')\n    if not client._auth_configs or client._auth_configs.is_empty:\n        log.debug(\n            \"No auth config in memory - loading from filesystem\"\n        )\n        client._auth_configs = load_config(credstore_env=client.credstore_env)\n    authcfg = resolve_authconfig(\n        client._auth_configs, registry, credstore_env=client.credstore_env\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "split_repo_name",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def split_repo_name(repo_name):\n    parts = repo_name.split('/', 1)\n    if len(parts) == 1 or (\n        '.' not in parts[0] and ':' not in parts[0] and parts[0] != 'localhost'\n    ):\n        # This is a docker index repo (ex: username/foobar or ubuntu)\n        return INDEX_NAME, repo_name\n    return tuple(parts)\ndef get_credential_store(authconfig, registry):\n    if not isinstance(authconfig, AuthConfig):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "get_credential_store",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def get_credential_store(authconfig, registry):\n    if not isinstance(authconfig, AuthConfig):\n        authconfig = AuthConfig(authconfig)\n    return authconfig.get_credential_store(registry)\nclass AuthConfig(dict):\n    def __init__(self, dct, credstore_env=None):\n        if 'auths' not in dct:\n            dct['auths'] = {}\n        self.update(dct)\n        self._credstore_env = credstore_env",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "resolve_authconfig",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def resolve_authconfig(authconfig, registry=None, credstore_env=None):\n    if not isinstance(authconfig, AuthConfig):\n        authconfig = AuthConfig(authconfig, credstore_env)\n    return authconfig.resolve_authconfig(registry)\ndef convert_to_hostname(url):\n    return url.replace('http://', '').replace('https://', '').split('/', 1)[0]\ndef decode_auth(auth):\n    if isinstance(auth, string_types):\n        auth = auth.encode('ascii')\n    s = base64.b64decode(auth)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "convert_to_hostname",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def convert_to_hostname(url):\n    return url.replace('http://', '').replace('https://', '').split('/', 1)[0]\ndef decode_auth(auth):\n    if isinstance(auth, string_types):\n        auth = auth.encode('ascii')\n    s = base64.b64decode(auth)\n    login, pwd = s.split(b':', 1)\n    return login.decode('utf8'), pwd.decode('utf8')\ndef encode_header(auth):\n    auth_json = json.dumps(auth).encode('ascii')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "decode_auth",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def decode_auth(auth):\n    if isinstance(auth, string_types):\n        auth = auth.encode('ascii')\n    s = base64.b64decode(auth)\n    login, pwd = s.split(b':', 1)\n    return login.decode('utf8'), pwd.decode('utf8')\ndef encode_header(auth):\n    auth_json = json.dumps(auth).encode('ascii')\n    return base64.urlsafe_b64encode(auth_json)\ndef parse_auth(entries, raise_on_error=False):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "encode_header",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def encode_header(auth):\n    auth_json = json.dumps(auth).encode('ascii')\n    return base64.urlsafe_b64encode(auth_json)\ndef parse_auth(entries, raise_on_error=False):\n    \"\"\"\n    Parses authentication entries\n    Args:\n      entries:        Dict of authentication entries.\n      raise_on_error: If set to true, an invalid format will raise\n                      InvalidConfigFile",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "parse_auth",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def parse_auth(entries, raise_on_error=False):\n    \"\"\"\n    Parses authentication entries\n    Args:\n      entries:        Dict of authentication entries.\n      raise_on_error: If set to true, an invalid format will raise\n                      InvalidConfigFile\n    Returns:\n      Authentication registry.\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "def load_config(config_path=None, config_dict=None, credstore_env=None):\n    return AuthConfig.load_config(config_path, config_dict, credstore_env)\ndef _load_legacy_config(config_file):\n    log.debug(\"Attempting to parse legacy auth file format\")\n    try:\n        data = []\n        with open(config_file) as f:\n            for line in f.readlines():\n                data.append(line.strip().split(' = ')[1])\n            if len(data) < 2:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "__metaclass__ = type\nimport base64\nimport json\nimport logging\nfrom ansible.module_utils.six import iteritems, string_types\nfrom . import errors\nfrom .credentials.store import Store\nfrom .credentials.errors import StoreError, CredentialsNotFound\nfrom .utils import config\nINDEX_NAME = 'docker.io'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "INDEX_NAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "INDEX_NAME = 'docker.io'\nINDEX_URL = 'https://index.{0}/v1/'.format(INDEX_NAME)\nTOKEN_USERNAME = '<token>'\nlog = logging.getLogger(__name__)\ndef resolve_repository_name(repo_name):\n    if '://' in repo_name:\n        raise errors.InvalidRepository(\n            'Repository name cannot contain a scheme ({0})'.format(repo_name)\n        )\n    index_name, remote_name = split_repo_name(repo_name)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "INDEX_URL",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "INDEX_URL = 'https://index.{0}/v1/'.format(INDEX_NAME)\nTOKEN_USERNAME = '<token>'\nlog = logging.getLogger(__name__)\ndef resolve_repository_name(repo_name):\n    if '://' in repo_name:\n        raise errors.InvalidRepository(\n            'Repository name cannot contain a scheme ({0})'.format(repo_name)\n        )\n    index_name, remote_name = split_repo_name(repo_name)\n    if index_name[0] == '-' or index_name[-1] == '-':",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "TOKEN_USERNAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "TOKEN_USERNAME = '<token>'\nlog = logging.getLogger(__name__)\ndef resolve_repository_name(repo_name):\n    if '://' in repo_name:\n        raise errors.InvalidRepository(\n            'Repository name cannot contain a scheme ({0})'.format(repo_name)\n        )\n    index_name, remote_name = split_repo_name(repo_name)\n    if index_name[0] == '-' or index_name[-1] == '-':\n        raise errors.InvalidRepository(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef resolve_repository_name(repo_name):\n    if '://' in repo_name:\n        raise errors.InvalidRepository(\n            'Repository name cannot contain a scheme ({0})'.format(repo_name)\n        )\n    index_name, remote_name = split_repo_name(repo_name)\n    if index_name[0] == '-' or index_name[-1] == '-':\n        raise errors.InvalidRepository(\n            'Invalid index name ({0}). Cannot begin or end with a'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.auth",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "__metaclass__ = type\nimport sys\nDEFAULT_DOCKER_API_VERSION = '1.41'\nMINIMUM_DOCKER_API_VERSION = '1.21'\nDEFAULT_TIMEOUT_SECONDS = 60\nSTREAM_HEADER_SIZE_BYTES = 8\nCONTAINER_LIMITS_KEYS = [\n    'memory', 'memswap', 'cpushares', 'cpusetcpus'\n]\nDEFAULT_HTTP_HOST = \"127.0.0.1\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_API_VERSION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_DOCKER_API_VERSION = '1.41'\nMINIMUM_DOCKER_API_VERSION = '1.21'\nDEFAULT_TIMEOUT_SECONDS = 60\nSTREAM_HEADER_SIZE_BYTES = 8\nCONTAINER_LIMITS_KEYS = [\n    'memory', 'memswap', 'cpushares', 'cpusetcpus'\n]\nDEFAULT_HTTP_HOST = \"127.0.0.1\"\nDEFAULT_UNIX_SOCKET = \"http+unix:///var/run/docker.sock\"\nDEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "MINIMUM_DOCKER_API_VERSION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "MINIMUM_DOCKER_API_VERSION = '1.21'\nDEFAULT_TIMEOUT_SECONDS = 60\nSTREAM_HEADER_SIZE_BYTES = 8\nCONTAINER_LIMITS_KEYS = [\n    'memory', 'memswap', 'cpushares', 'cpusetcpus'\n]\nDEFAULT_HTTP_HOST = \"127.0.0.1\"\nDEFAULT_UNIX_SOCKET = \"http+unix:///var/run/docker.sock\"\nDEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'\nBYTE_UNITS = {",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUT_SECONDS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_TIMEOUT_SECONDS = 60\nSTREAM_HEADER_SIZE_BYTES = 8\nCONTAINER_LIMITS_KEYS = [\n    'memory', 'memswap', 'cpushares', 'cpusetcpus'\n]\nDEFAULT_HTTP_HOST = \"127.0.0.1\"\nDEFAULT_UNIX_SOCKET = \"http+unix:///var/run/docker.sock\"\nDEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'\nBYTE_UNITS = {\n    'b': 1,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "STREAM_HEADER_SIZE_BYTES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "STREAM_HEADER_SIZE_BYTES = 8\nCONTAINER_LIMITS_KEYS = [\n    'memory', 'memswap', 'cpushares', 'cpusetcpus'\n]\nDEFAULT_HTTP_HOST = \"127.0.0.1\"\nDEFAULT_UNIX_SOCKET = \"http+unix:///var/run/docker.sock\"\nDEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'\nBYTE_UNITS = {\n    'b': 1,\n    'k': 1024,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "CONTAINER_LIMITS_KEYS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "CONTAINER_LIMITS_KEYS = [\n    'memory', 'memswap', 'cpushares', 'cpusetcpus'\n]\nDEFAULT_HTTP_HOST = \"127.0.0.1\"\nDEFAULT_UNIX_SOCKET = \"http+unix:///var/run/docker.sock\"\nDEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'\nBYTE_UNITS = {\n    'b': 1,\n    'k': 1024,\n    'm': 1024 * 1024,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_HTTP_HOST",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_HTTP_HOST = \"127.0.0.1\"\nDEFAULT_UNIX_SOCKET = \"http+unix:///var/run/docker.sock\"\nDEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'\nBYTE_UNITS = {\n    'b': 1,\n    'k': 1024,\n    'm': 1024 * 1024,\n    'g': 1024 * 1024 * 1024\n}\nIS_WINDOWS_PLATFORM = (sys.platform == 'win32')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_UNIX_SOCKET",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_UNIX_SOCKET = \"http+unix:///var/run/docker.sock\"\nDEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'\nBYTE_UNITS = {\n    'b': 1,\n    'k': 1024,\n    'm': 1024 * 1024,\n    'g': 1024 * 1024 * 1024\n}\nIS_WINDOWS_PLATFORM = (sys.platform == 'win32')\nWINDOWS_LONGPATH_PREFIX = '\\\\\\\\?\\\\'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_NPIPE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_NPIPE = 'npipe:////./pipe/docker_engine'\nBYTE_UNITS = {\n    'b': 1,\n    'k': 1024,\n    'm': 1024 * 1024,\n    'g': 1024 * 1024 * 1024\n}\nIS_WINDOWS_PLATFORM = (sys.platform == 'win32')\nWINDOWS_LONGPATH_PREFIX = '\\\\\\\\?\\\\'\nDEFAULT_USER_AGENT = \"ansible-community.docker\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "BYTE_UNITS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "BYTE_UNITS = {\n    'b': 1,\n    'k': 1024,\n    'm': 1024 * 1024,\n    'g': 1024 * 1024 * 1024\n}\nIS_WINDOWS_PLATFORM = (sys.platform == 'win32')\nWINDOWS_LONGPATH_PREFIX = '\\\\\\\\?\\\\'\nDEFAULT_USER_AGENT = \"ansible-community.docker\"\nDEFAULT_NUM_POOLS = 25",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS_PLATFORM",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "IS_WINDOWS_PLATFORM = (sys.platform == 'win32')\nWINDOWS_LONGPATH_PREFIX = '\\\\\\\\?\\\\'\nDEFAULT_USER_AGENT = \"ansible-community.docker\"\nDEFAULT_NUM_POOLS = 25\n# The OpenSSH server default value for MaxSessions is 10 which means we can\n# use up to 9, leaving the final session for the underlying SSH connection.\n# For more details see: https://github.com/docker/docker-py/issues/2246\nDEFAULT_NUM_POOLS_SSH = 9\nDEFAULT_MAX_POOL_SIZE = 10\nDEFAULT_DATA_CHUNK_SIZE = 1024 * 2048",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "WINDOWS_LONGPATH_PREFIX",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "WINDOWS_LONGPATH_PREFIX = '\\\\\\\\?\\\\'\nDEFAULT_USER_AGENT = \"ansible-community.docker\"\nDEFAULT_NUM_POOLS = 25\n# The OpenSSH server default value for MaxSessions is 10 which means we can\n# use up to 9, leaving the final session for the underlying SSH connection.\n# For more details see: https://github.com/docker/docker-py/issues/2246\nDEFAULT_NUM_POOLS_SSH = 9\nDEFAULT_MAX_POOL_SIZE = 10\nDEFAULT_DATA_CHUNK_SIZE = 1024 * 2048\nDEFAULT_SWARM_ADDR_POOL = ['10.0.0.0/8']",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_USER_AGENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_USER_AGENT = \"ansible-community.docker\"\nDEFAULT_NUM_POOLS = 25\n# The OpenSSH server default value for MaxSessions is 10 which means we can\n# use up to 9, leaving the final session for the underlying SSH connection.\n# For more details see: https://github.com/docker/docker-py/issues/2246\nDEFAULT_NUM_POOLS_SSH = 9\nDEFAULT_MAX_POOL_SIZE = 10\nDEFAULT_DATA_CHUNK_SIZE = 1024 * 2048\nDEFAULT_SWARM_ADDR_POOL = ['10.0.0.0/8']\nDEFAULT_SWARM_SUBNET_SIZE = 24",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_NUM_POOLS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_NUM_POOLS = 25\n# The OpenSSH server default value for MaxSessions is 10 which means we can\n# use up to 9, leaving the final session for the underlying SSH connection.\n# For more details see: https://github.com/docker/docker-py/issues/2246\nDEFAULT_NUM_POOLS_SSH = 9\nDEFAULT_MAX_POOL_SIZE = 10\nDEFAULT_DATA_CHUNK_SIZE = 1024 * 2048\nDEFAULT_SWARM_ADDR_POOL = ['10.0.0.0/8']\nDEFAULT_SWARM_SUBNET_SIZE = 24",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_NUM_POOLS_SSH",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_NUM_POOLS_SSH = 9\nDEFAULT_MAX_POOL_SIZE = 10\nDEFAULT_DATA_CHUNK_SIZE = 1024 * 2048\nDEFAULT_SWARM_ADDR_POOL = ['10.0.0.0/8']\nDEFAULT_SWARM_SUBNET_SIZE = 24",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAX_POOL_SIZE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_MAX_POOL_SIZE = 10\nDEFAULT_DATA_CHUNK_SIZE = 1024 * 2048\nDEFAULT_SWARM_ADDR_POOL = ['10.0.0.0/8']\nDEFAULT_SWARM_SUBNET_SIZE = 24",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DATA_CHUNK_SIZE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_DATA_CHUNK_SIZE = 1024 * 2048\nDEFAULT_SWARM_ADDR_POOL = ['10.0.0.0/8']\nDEFAULT_SWARM_SUBNET_SIZE = 24",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SWARM_ADDR_POOL",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_SWARM_ADDR_POOL = ['10.0.0.0/8']\nDEFAULT_SWARM_SUBNET_SIZE = 24",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SWARM_SUBNET_SIZE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "peekOfCode": "DEFAULT_SWARM_SUBNET_SIZE = 24",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.constants",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class DockerException(Exception):\n    \"\"\"\n    A base class from which all other exceptions inherit.\n    If you want to catch all errors that the Docker SDK might raise,\n    catch this base exception.\n    \"\"\"\ndef create_api_error_from_http_exception(e):\n    \"\"\"\n    Create a suitable APIError from requests.exceptions.HTTPError.\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "APIError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class APIError(_HTTPError, DockerException):\n    \"\"\"\n    An HTTP error from the API.\n    \"\"\"\n    def __init__(self, message, response=None, explanation=None):\n        # requests 1.2 supports response as a keyword argument, but\n        # requests 1.1 doesn't\n        super(APIError, self).__init__(message)\n        self.response = response\n        self.explanation = explanation",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NotFound",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class NotFound(APIError):\n    pass\nclass ImageNotFound(NotFound):\n    pass\nclass InvalidVersion(DockerException):\n    pass\nclass InvalidRepository(DockerException):\n    pass\nclass InvalidConfigFile(DockerException):\n    pass",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "ImageNotFound",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class ImageNotFound(NotFound):\n    pass\nclass InvalidVersion(DockerException):\n    pass\nclass InvalidRepository(DockerException):\n    pass\nclass InvalidConfigFile(DockerException):\n    pass\nclass InvalidArgument(DockerException):\n    pass",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "InvalidVersion",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class InvalidVersion(DockerException):\n    pass\nclass InvalidRepository(DockerException):\n    pass\nclass InvalidConfigFile(DockerException):\n    pass\nclass InvalidArgument(DockerException):\n    pass\nclass DeprecatedMethod(DockerException):\n    pass",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "InvalidRepository",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class InvalidRepository(DockerException):\n    pass\nclass InvalidConfigFile(DockerException):\n    pass\nclass InvalidArgument(DockerException):\n    pass\nclass DeprecatedMethod(DockerException):\n    pass\nclass TLSParameterError(DockerException):\n    def __init__(self, msg):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "InvalidConfigFile",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class InvalidConfigFile(DockerException):\n    pass\nclass InvalidArgument(DockerException):\n    pass\nclass DeprecatedMethod(DockerException):\n    pass\nclass TLSParameterError(DockerException):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "InvalidArgument",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class InvalidArgument(DockerException):\n    pass\nclass DeprecatedMethod(DockerException):\n    pass\nclass TLSParameterError(DockerException):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return self.msg + (\". TLS configurations should map the Docker CLI \"\n                           \"client configurations. See \"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "DeprecatedMethod",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class DeprecatedMethod(DockerException):\n    pass\nclass TLSParameterError(DockerException):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return self.msg + (\". TLS configurations should map the Docker CLI \"\n                           \"client configurations. See \"\n                           \"https://docs.docker.com/engine/articles/https/ \"\n                           \"for API details.\")",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "TLSParameterError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class TLSParameterError(DockerException):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return self.msg + (\". TLS configurations should map the Docker CLI \"\n                           \"client configurations. See \"\n                           \"https://docs.docker.com/engine/articles/https/ \"\n                           \"for API details.\")\nclass NullResource(DockerException, ValueError):\n    pass",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "NullResource",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class NullResource(DockerException, ValueError):\n    pass\nclass ContainerError(DockerException):\n    \"\"\"\n    Represents a container that has exited with a non-zero exit code.\n    \"\"\"\n    def __init__(self, container, exit_status, command, image, stderr):\n        self.container = container\n        self.exit_status = exit_status\n        self.command = command",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "ContainerError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class ContainerError(DockerException):\n    \"\"\"\n    Represents a container that has exited with a non-zero exit code.\n    \"\"\"\n    def __init__(self, container, exit_status, command, image, stderr):\n        self.container = container\n        self.exit_status = exit_status\n        self.command = command\n        self.image = image\n        self.stderr = stderr",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "StreamParseError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class StreamParseError(RuntimeError):\n    def __init__(self, reason):\n        self.msg = reason\nclass BuildError(DockerException):\n    def __init__(self, reason, build_log):\n        super(BuildError, self).__init__(reason)\n        self.msg = reason\n        self.build_log = build_log\nclass ImageLoadError(DockerException):\n    pass",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "BuildError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class BuildError(DockerException):\n    def __init__(self, reason, build_log):\n        super(BuildError, self).__init__(reason)\n        self.msg = reason\n        self.build_log = build_log\nclass ImageLoadError(DockerException):\n    pass\ndef create_unexpected_kwargs_error(name, kwargs):\n    quoted_kwargs = [\"'{0}'\".format(k) for k in sorted(kwargs)]\n    text = [\"{0}() \".format(name)]",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "ImageLoadError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class ImageLoadError(DockerException):\n    pass\ndef create_unexpected_kwargs_error(name, kwargs):\n    quoted_kwargs = [\"'{0}'\".format(k) for k in sorted(kwargs)]\n    text = [\"{0}() \".format(name)]\n    if len(quoted_kwargs) == 1:\n        text.append(\"got an unexpected keyword argument \")\n    else:\n        text.append(\"got unexpected keyword arguments \")\n    text.append(', '.join(quoted_kwargs))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "MissingContextParameter",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class MissingContextParameter(DockerException):\n    def __init__(self, param):\n        self.param = param\n    def __str__(self):\n        return (\"missing parameter: {0}\".format(self.param))\nclass ContextAlreadyExists(DockerException):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return (\"context {0} already exists\".format(self.name))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "ContextAlreadyExists",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class ContextAlreadyExists(DockerException):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return (\"context {0} already exists\".format(self.name))\nclass ContextException(DockerException):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return (self.msg)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "ContextException",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class ContextException(DockerException):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return (self.msg)\nclass ContextNotFound(DockerException):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return (\"context '{0}' not found\".format(self.name))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "ContextNotFound",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class ContextNotFound(DockerException):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return (\"context '{0}' not found\".format(self.name))\nclass MissingRequirementException(DockerException):\n    def __init__(self, msg, requirement, import_exception):\n        self.msg = msg\n        self.requirement = requirement\n        self.import_exception = import_exception",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "MissingRequirementException",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "class MissingRequirementException(DockerException):\n    def __init__(self, msg, requirement, import_exception):\n        self.msg = msg\n        self.requirement = requirement\n        self.import_exception = import_exception\n    def __str__(self):\n        return (self.msg)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "create_api_error_from_http_exception",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "def create_api_error_from_http_exception(e):\n    \"\"\"\n    Create a suitable APIError from requests.exceptions.HTTPError.\n    \"\"\"\n    response = e.response\n    try:\n        explanation = response.json()['message']\n    except ValueError:\n        explanation = to_native((response.content or '').strip())\n    cls = APIError",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "create_unexpected_kwargs_error",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "def create_unexpected_kwargs_error(name, kwargs):\n    quoted_kwargs = [\"'{0}'\".format(k) for k in sorted(kwargs)]\n    text = [\"{0}() \".format(name)]\n    if len(quoted_kwargs) == 1:\n        text.append(\"got an unexpected keyword argument \")\n    else:\n        text.append(\"got unexpected keyword arguments \")\n    text.append(', '.join(quoted_kwargs))\n    return TypeError(''.join(text))\nclass MissingContextParameter(DockerException):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "peekOfCode": "__metaclass__ = type\nfrom ._import_helper import HTTPError as _HTTPError\nfrom ansible.module_utils.common.text.converters import to_native\nfrom ansible.module_utils.six import raise_from\nclass DockerException(Exception):\n    \"\"\"\n    A base class from which all other exceptions inherit.\n    If you want to catch all errors that the Docker SDK might raise,\n    catch this base exception.\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.errors",
        "documentation": {}
    },
    {
        "label": "TLSConfig",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.tls",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.tls",
        "peekOfCode": "class TLSConfig(object):\n    \"\"\"\n    TLS configuration.\n    Args:\n        client_cert (tuple of str): Path to client cert, path to client key.\n        ca_cert (str): Path to CA cert file.\n        verify (bool or str): This can be ``False`` or a path to a CA cert\n            file.\n        ssl_version (int): A valid `SSL version`_.\n        assert_hostname (bool): Verify the hostname of the server.",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.tls",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._api.tls",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._api.tls",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport ssl\nimport sys\nfrom . import errors\nfrom .transport.ssladapter import SSLHTTPAdapter\nclass TLSConfig(object):\n    \"\"\"\n    TLS configuration.\n    Args:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._api.tls",
        "documentation": {}
    },
    {
        "label": "Option",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "class Option(object):\n    def __init__(\n        self,\n        name,\n        type,\n        owner,\n        ansible_type=None,\n        elements=None,\n        ansible_elements=None,\n        ansible_suboptions=None,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OptionGroup",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "class OptionGroup(object):\n    def __init__(\n        self,\n        preprocess=None,\n        ansible_mutually_exclusive=None,\n        ansible_required_together=None,\n        ansible_required_one_of=None,\n        ansible_required_if=None,\n        ansible_required_by=None,\n    ):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "Engine",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "class Engine(object):\n    min_api_version = None  # string or None\n    min_api_version_obj = None  # LooseVersion object or None\n    extra_option_minimal_versions = None  # dict[str, dict[str, Any]] or None\n    @abc.abstractmethod\n    def get_value(self, module, container, api_version, options, image, host_info):\n        pass\n    def compare_value(self, option, param_value, container_value):\n        return option.compare(param_value, container_value)\n    @abc.abstractmethod",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "EngineDriver",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "class EngineDriver(object):\n    name = None  # string\n    @abc.abstractmethod\n    def setup(self, argument_spec, mutually_exclusive=None, required_together=None, required_one_of=None, required_if=None, required_by=None):\n        # Return (module, active_options, client)\n        pass\n    @abc.abstractmethod\n    def get_host_info(self, client):\n        pass\n    @abc.abstractmethod",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "__metaclass__ = type\nimport abc\nimport os\nimport re\nimport shlex\nfrom functools import partial\nfrom ansible.module_utils.common.text.converters import to_native, to_text\nfrom ansible.module_utils.common.text.formatters import human_to_bytes\nfrom ansible.module_utils.six import string_types\nfrom ansible_collections.community.docker.plugins.module_utils.util import (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_IP_REPLACEMENT_STRING",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "_DEFAULT_IP_REPLACEMENT_STRING = '[[DEFAULT_IP:iewahhaeB4Sae6Aen8IeShairoh4zeph7xaekoh8Geingunaesaeweiy3ooleiwi]]'\n_MOUNT_OPTION_TYPES = dict(\n    volume_driver='volume',\n    volume_options='volume',\n    propagation='bind',\n    no_copy='volume',\n    labels='volume',\n    tmpfs_size='tmpfs',\n    tmpfs_mode='tmpfs',\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "_MOUNT_OPTION_TYPES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "_MOUNT_OPTION_TYPES = dict(\n    volume_driver='volume',\n    volume_options='volume',\n    propagation='bind',\n    no_copy='volume',\n    labels='volume',\n    tmpfs_size='tmpfs',\n    tmpfs_mode='tmpfs',\n)\ndef _get_ansible_type(type):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_AUTO_REMOVE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_AUTO_REMOVE = (\n    OptionGroup()\n    .add_option('auto_remove', type='bool')\n)\nOPTION_BLKIO_WEIGHT = (\n    OptionGroup()\n    .add_option('blkio_weight', type='int')\n)\nOPTION_CAPABILITIES = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_BLKIO_WEIGHT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_BLKIO_WEIGHT = (\n    OptionGroup()\n    .add_option('blkio_weight', type='int')\n)\nOPTION_CAPABILITIES = (\n    OptionGroup()\n    .add_option('capabilities', type='set', elements='str')\n)\nOPTION_CAP_DROP = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CAPABILITIES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CAPABILITIES = (\n    OptionGroup()\n    .add_option('capabilities', type='set', elements='str')\n)\nOPTION_CAP_DROP = (\n    OptionGroup()\n    .add_option('cap_drop', type='set', elements='str')\n)\nOPTION_CGROUP_NS_MODE = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CAP_DROP",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CAP_DROP = (\n    OptionGroup()\n    .add_option('cap_drop', type='set', elements='str')\n)\nOPTION_CGROUP_NS_MODE = (\n    OptionGroup()\n    .add_option('cgroupns_mode', type='str', ansible_choices=['private', 'host'])\n)\nOPTION_CGROUP_PARENT = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CGROUP_NS_MODE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CGROUP_NS_MODE = (\n    OptionGroup()\n    .add_option('cgroupns_mode', type='str', ansible_choices=['private', 'host'])\n)\nOPTION_CGROUP_PARENT = (\n    OptionGroup()\n    .add_option('cgroup_parent', type='str')\n)\nOPTION_COMMAND = (\n    OptionGroup(preprocess=_preprocess_command)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CGROUP_PARENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CGROUP_PARENT = (\n    OptionGroup()\n    .add_option('cgroup_parent', type='str')\n)\nOPTION_COMMAND = (\n    OptionGroup(preprocess=_preprocess_command)\n    .add_option('command', type='list', elements='str', ansible_type='raw')\n)\nOPTION_CPU_PERIOD = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_COMMAND",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_COMMAND = (\n    OptionGroup(preprocess=_preprocess_command)\n    .add_option('command', type='list', elements='str', ansible_type='raw')\n)\nOPTION_CPU_PERIOD = (\n    OptionGroup()\n    .add_option('cpu_period', type='int')\n)\nOPTION_CPU_QUOTA = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPU_PERIOD",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CPU_PERIOD = (\n    OptionGroup()\n    .add_option('cpu_period', type='int')\n)\nOPTION_CPU_QUOTA = (\n    OptionGroup()\n    .add_option('cpu_quota', type='int')\n)\nOPTION_CPUSET_CPUS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPU_QUOTA",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CPU_QUOTA = (\n    OptionGroup()\n    .add_option('cpu_quota', type='int')\n)\nOPTION_CPUSET_CPUS = (\n    OptionGroup()\n    .add_option('cpuset_cpus', type='str')\n)\nOPTION_CPUSET_MEMS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPUSET_CPUS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CPUSET_CPUS = (\n    OptionGroup()\n    .add_option('cpuset_cpus', type='str')\n)\nOPTION_CPUSET_MEMS = (\n    OptionGroup()\n    .add_option('cpuset_mems', type='str')\n)\nOPTION_CPU_SHARES = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPUSET_MEMS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CPUSET_MEMS = (\n    OptionGroup()\n    .add_option('cpuset_mems', type='str')\n)\nOPTION_CPU_SHARES = (\n    OptionGroup()\n    .add_option('cpu_shares', type='int')\n)\nOPTION_ENTRYPOINT = (\n    OptionGroup(preprocess=_preprocess_entrypoint)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPU_SHARES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CPU_SHARES = (\n    OptionGroup()\n    .add_option('cpu_shares', type='int')\n)\nOPTION_ENTRYPOINT = (\n    OptionGroup(preprocess=_preprocess_entrypoint)\n    .add_option('entrypoint', type='list', elements='str')\n)\nOPTION_CPUS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ENTRYPOINT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_ENTRYPOINT = (\n    OptionGroup(preprocess=_preprocess_entrypoint)\n    .add_option('entrypoint', type='list', elements='str')\n)\nOPTION_CPUS = (\n    OptionGroup()\n    .add_option('cpus', type='int', ansible_type='float')\n)\nOPTION_DETACH_INTERACTIVE = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_CPUS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_CPUS = (\n    OptionGroup()\n    .add_option('cpus', type='int', ansible_type='float')\n)\nOPTION_DETACH_INTERACTIVE = (\n    OptionGroup()\n    .add_option('detach', type='bool')\n    .add_option('interactive', type='bool')\n)\nOPTION_DEVICES = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DETACH_INTERACTIVE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DETACH_INTERACTIVE = (\n    OptionGroup()\n    .add_option('detach', type='bool')\n    .add_option('interactive', type='bool')\n)\nOPTION_DEVICES = (\n    OptionGroup()\n    .add_option('devices', type='set', elements='dict', ansible_elements='str')\n)\nOPTION_DEVICE_READ_BPS = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DEVICES = (\n    OptionGroup()\n    .add_option('devices', type='set', elements='dict', ansible_elements='str')\n)\nOPTION_DEVICE_READ_BPS = (\n    OptionGroup()\n    .add_option('device_read_bps', type='set', elements='dict', ansible_suboptions=dict(\n        path=dict(required=True, type='str'),\n        rate=dict(required=True, type='str'),\n    ))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_READ_BPS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DEVICE_READ_BPS = (\n    OptionGroup()\n    .add_option('device_read_bps', type='set', elements='dict', ansible_suboptions=dict(\n        path=dict(required=True, type='str'),\n        rate=dict(required=True, type='str'),\n    ))\n)\nOPTION_DEVICE_WRITE_BPS = (\n    OptionGroup()\n    .add_option('device_write_bps', type='set', elements='dict', ansible_suboptions=dict(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_WRITE_BPS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DEVICE_WRITE_BPS = (\n    OptionGroup()\n    .add_option('device_write_bps', type='set', elements='dict', ansible_suboptions=dict(\n        path=dict(required=True, type='str'),\n        rate=dict(required=True, type='str'),\n    ))\n)\nOPTION_DEVICE_READ_IOPS = (\n    OptionGroup()\n    .add_option('device_read_iops', type='set', elements='dict', ansible_suboptions=dict(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_READ_IOPS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DEVICE_READ_IOPS = (\n    OptionGroup()\n    .add_option('device_read_iops', type='set', elements='dict', ansible_suboptions=dict(\n        path=dict(required=True, type='str'),\n        rate=dict(required=True, type='int'),\n    ))\n)\nOPTION_DEVICE_WRITE_IOPS = (\n    OptionGroup()\n    .add_option('device_write_iops', type='set', elements='dict', ansible_suboptions=dict(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_WRITE_IOPS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DEVICE_WRITE_IOPS = (\n    OptionGroup()\n    .add_option('device_write_iops', type='set', elements='dict', ansible_suboptions=dict(\n        path=dict(required=True, type='str'),\n        rate=dict(required=True, type='int'),\n    ))\n)\nOPTION_DEVICE_REQUESTS = (\n    OptionGroup()\n    .add_option('device_requests', type='set', elements='dict', ansible_suboptions=dict(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_REQUESTS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DEVICE_REQUESTS = (\n    OptionGroup()\n    .add_option('device_requests', type='set', elements='dict', ansible_suboptions=dict(\n        capabilities=dict(type='list', elements='list'),\n        count=dict(type='int'),\n        device_ids=dict(type='list', elements='str'),\n        driver=dict(type='str'),\n        options=dict(type='dict'),\n    ))\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DEVICE_CGROUP_RULES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DEVICE_CGROUP_RULES = (\n    OptionGroup()\n    .add_option('device_cgroup_rules', type='list', elements='str')\n)\nOPTION_DNS_SERVERS = (\n    OptionGroup()\n    .add_option('dns_servers', type='list', elements='str')\n)\nOPTION_DNS_OPTS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DNS_SERVERS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DNS_SERVERS = (\n    OptionGroup()\n    .add_option('dns_servers', type='list', elements='str')\n)\nOPTION_DNS_OPTS = (\n    OptionGroup()\n    .add_option('dns_opts', type='set', elements='str')\n)\nOPTION_DNS_SEARCH_DOMAINS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DNS_OPTS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DNS_OPTS = (\n    OptionGroup()\n    .add_option('dns_opts', type='set', elements='str')\n)\nOPTION_DNS_SEARCH_DOMAINS = (\n    OptionGroup()\n    .add_option('dns_search_domains', type='list', elements='str')\n)\nOPTION_DOMAINNAME = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DNS_SEARCH_DOMAINS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DNS_SEARCH_DOMAINS = (\n    OptionGroup()\n    .add_option('dns_search_domains', type='list', elements='str')\n)\nOPTION_DOMAINNAME = (\n    OptionGroup()\n    .add_option('domainname', type='str')\n)\nOPTION_ENVIRONMENT = (\n    OptionGroup(preprocess=_preprocess_env)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_DOMAINNAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_DOMAINNAME = (\n    OptionGroup()\n    .add_option('domainname', type='str')\n)\nOPTION_ENVIRONMENT = (\n    OptionGroup(preprocess=_preprocess_env)\n    .add_option('env', type='set', ansible_type='dict', elements='str', needs_no_suboptions=True)\n    .add_option('env_file', type='set', ansible_type='path', elements='str', not_a_container_option=True)\n)\nOPTION_ETC_HOSTS = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ENVIRONMENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_ENVIRONMENT = (\n    OptionGroup(preprocess=_preprocess_env)\n    .add_option('env', type='set', ansible_type='dict', elements='str', needs_no_suboptions=True)\n    .add_option('env_file', type='set', ansible_type='path', elements='str', not_a_container_option=True)\n)\nOPTION_ETC_HOSTS = (\n    OptionGroup()\n    .add_option('etc_hosts', type='set', ansible_type='dict', elements='str', needs_no_suboptions=True)\n)\nOPTION_GROUPS = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ETC_HOSTS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_ETC_HOSTS = (\n    OptionGroup()\n    .add_option('etc_hosts', type='set', ansible_type='dict', elements='str', needs_no_suboptions=True)\n)\nOPTION_GROUPS = (\n    OptionGroup()\n    .add_option('groups', type='set', elements='str')\n)\nOPTION_HEALTHCHECK = (\n    OptionGroup(preprocess=_preprocess_healthcheck)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_GROUPS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_GROUPS = (\n    OptionGroup()\n    .add_option('groups', type='set', elements='str')\n)\nOPTION_HEALTHCHECK = (\n    OptionGroup(preprocess=_preprocess_healthcheck)\n    .add_option('healthcheck', type='dict', ansible_suboptions=dict(\n        test=dict(type='raw'),\n        test_cli_compatible=dict(type='bool', default=False),\n        interval=dict(type='str'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_HEALTHCHECK",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_HEALTHCHECK = (\n    OptionGroup(preprocess=_preprocess_healthcheck)\n    .add_option('healthcheck', type='dict', ansible_suboptions=dict(\n        test=dict(type='raw'),\n        test_cli_compatible=dict(type='bool', default=False),\n        interval=dict(type='str'),\n        timeout=dict(type='str'),\n        start_period=dict(type='str'),\n        start_interval=dict(type='str'),\n        retries=dict(type='int'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_HOSTNAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_HOSTNAME = (\n    OptionGroup()\n    .add_option('hostname', type='str')\n)\nOPTION_IMAGE = (\n    OptionGroup()\n    .add_option('image', type='str')\n)\nOPTION_INIT = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_IMAGE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_IMAGE = (\n    OptionGroup()\n    .add_option('image', type='str')\n)\nOPTION_INIT = (\n    OptionGroup()\n    .add_option('init', type='bool')\n)\nOPTION_IPC_MODE = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_INIT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_INIT = (\n    OptionGroup()\n    .add_option('init', type='bool')\n)\nOPTION_IPC_MODE = (\n    OptionGroup()\n    .add_option('ipc_mode', type='str')\n)\nOPTION_KERNEL_MEMORY = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='kernel_memory'))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_IPC_MODE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_IPC_MODE = (\n    OptionGroup()\n    .add_option('ipc_mode', type='str')\n)\nOPTION_KERNEL_MEMORY = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='kernel_memory'))\n    .add_option('kernel_memory', type='int', ansible_type='str')\n)\nOPTION_LABELS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_KERNEL_MEMORY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_KERNEL_MEMORY = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='kernel_memory'))\n    .add_option('kernel_memory', type='int', ansible_type='str')\n)\nOPTION_LABELS = (\n    OptionGroup()\n    .add_option('labels', type='dict', needs_no_suboptions=True)\n)\nOPTION_LINKS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_LABELS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_LABELS = (\n    OptionGroup()\n    .add_option('labels', type='dict', needs_no_suboptions=True)\n)\nOPTION_LINKS = (\n    OptionGroup()\n    .add_option('links', type='set', elements='list', ansible_elements='str')\n)\nOPTION_LOG_DRIVER_OPTIONS = (\n    OptionGroup(preprocess=_preprocess_log, ansible_required_by={'log_options': ['log_driver']})",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_LINKS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_LINKS = (\n    OptionGroup()\n    .add_option('links', type='set', elements='list', ansible_elements='str')\n)\nOPTION_LOG_DRIVER_OPTIONS = (\n    OptionGroup(preprocess=_preprocess_log, ansible_required_by={'log_options': ['log_driver']})\n    .add_option('log_driver', type='str')\n    .add_option('log_options', type='dict', ansible_aliases=['log_opt'], needs_no_suboptions=True)\n)\nOPTION_MAC_ADDRESS = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_LOG_DRIVER_OPTIONS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_LOG_DRIVER_OPTIONS = (\n    OptionGroup(preprocess=_preprocess_log, ansible_required_by={'log_options': ['log_driver']})\n    .add_option('log_driver', type='str')\n    .add_option('log_options', type='dict', ansible_aliases=['log_opt'], needs_no_suboptions=True)\n)\nOPTION_MAC_ADDRESS = (\n    OptionGroup(preprocess=_preprocess_mac_address)\n    .add_option('mac_address', type='str')\n)\nOPTION_MEMORY = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MAC_ADDRESS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_MAC_ADDRESS = (\n    OptionGroup(preprocess=_preprocess_mac_address)\n    .add_option('mac_address', type='str')\n)\nOPTION_MEMORY = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory'))\n    .add_option('memory', type='int', ansible_type='str')\n)\nOPTION_MEMORY_RESERVATION = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory_reservation'))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_MEMORY = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory'))\n    .add_option('memory', type='int', ansible_type='str')\n)\nOPTION_MEMORY_RESERVATION = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory_reservation'))\n    .add_option('memory_reservation', type='int', ansible_type='str')\n)\nOPTION_MEMORY_SWAP = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory_swap', unlimited_value=-1))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY_RESERVATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_MEMORY_RESERVATION = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory_reservation'))\n    .add_option('memory_reservation', type='int', ansible_type='str')\n)\nOPTION_MEMORY_SWAP = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory_swap', unlimited_value=-1))\n    .add_option('memory_swap', type='int', ansible_type='str')\n)\nOPTION_MEMORY_SWAPPINESS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY_SWAP",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_MEMORY_SWAP = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='memory_swap', unlimited_value=-1))\n    .add_option('memory_swap', type='int', ansible_type='str')\n)\nOPTION_MEMORY_SWAPPINESS = (\n    OptionGroup()\n    .add_option('memory_swappiness', type='int')\n)\nOPTION_STOP_TIMEOUT = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MEMORY_SWAPPINESS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_MEMORY_SWAPPINESS = (\n    OptionGroup()\n    .add_option('memory_swappiness', type='int')\n)\nOPTION_STOP_TIMEOUT = (\n    OptionGroup()\n    .add_option('stop_timeout', type='int', default_comparison='ignore')\n)\nOPTION_NETWORK = (\n    OptionGroup(preprocess=_preprocess_networks)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_STOP_TIMEOUT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_STOP_TIMEOUT = (\n    OptionGroup()\n    .add_option('stop_timeout', type='int', default_comparison='ignore')\n)\nOPTION_NETWORK = (\n    OptionGroup(preprocess=_preprocess_networks)\n    .add_option('network_mode', type='str')\n    .add_option('networks', type='set', elements='dict', ansible_suboptions=dict(\n        name=dict(type='str', required=True),\n        ipv4_address=dict(type='str'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_NETWORK",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_NETWORK = (\n    OptionGroup(preprocess=_preprocess_networks)\n    .add_option('network_mode', type='str')\n    .add_option('networks', type='set', elements='dict', ansible_suboptions=dict(\n        name=dict(type='str', required=True),\n        ipv4_address=dict(type='str'),\n        ipv6_address=dict(type='str'),\n        aliases=dict(type='list', elements='str'),\n        links=dict(type='list', elements='str'),\n        mac_address=dict(type='str'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_OOM_KILLER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_OOM_KILLER = (\n    OptionGroup()\n    .add_option('oom_killer', type='bool')\n)\nOPTION_OOM_SCORE_ADJ = (\n    OptionGroup()\n    .add_option('oom_score_adj', type='int')\n)\nOPTION_PID_MODE = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_OOM_SCORE_ADJ",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_OOM_SCORE_ADJ = (\n    OptionGroup()\n    .add_option('oom_score_adj', type='int')\n)\nOPTION_PID_MODE = (\n    OptionGroup()\n    .add_option('pid_mode', type='str')\n)\nOPTION_PIDS_LIMIT = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PID_MODE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_PID_MODE = (\n    OptionGroup()\n    .add_option('pid_mode', type='str')\n)\nOPTION_PIDS_LIMIT = (\n    OptionGroup()\n    .add_option('pids_limit', type='int')\n)\nOPTION_PLATFORM = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PIDS_LIMIT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_PIDS_LIMIT = (\n    OptionGroup()\n    .add_option('pids_limit', type='int')\n)\nOPTION_PLATFORM = (\n    OptionGroup()\n    .add_option('platform', type='str', compare=_compare_platform)\n)\nOPTION_PRIVILEGED = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PLATFORM",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_PLATFORM = (\n    OptionGroup()\n    .add_option('platform', type='str', compare=_compare_platform)\n)\nOPTION_PRIVILEGED = (\n    OptionGroup()\n    .add_option('privileged', type='bool')\n)\nOPTION_READ_ONLY = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PRIVILEGED",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_PRIVILEGED = (\n    OptionGroup()\n    .add_option('privileged', type='bool')\n)\nOPTION_READ_ONLY = (\n    OptionGroup()\n    .add_option('read_only', type='bool')\n)\nOPTION_RESTART_POLICY = (\n    OptionGroup(ansible_required_by={'restart_retries': ['restart_policy']})",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_READ_ONLY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_READ_ONLY = (\n    OptionGroup()\n    .add_option('read_only', type='bool')\n)\nOPTION_RESTART_POLICY = (\n    OptionGroup(ansible_required_by={'restart_retries': ['restart_policy']})\n    .add_option('restart_policy', type='str', ansible_choices=['no', 'on-failure', 'always', 'unless-stopped'])\n    .add_option('restart_retries', type='int')\n)\nOPTION_RUNTIME = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_RESTART_POLICY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_RESTART_POLICY = (\n    OptionGroup(ansible_required_by={'restart_retries': ['restart_policy']})\n    .add_option('restart_policy', type='str', ansible_choices=['no', 'on-failure', 'always', 'unless-stopped'])\n    .add_option('restart_retries', type='int')\n)\nOPTION_RUNTIME = (\n    OptionGroup()\n    .add_option('runtime', type='str')\n)\nOPTION_SECURITY_OPTS = (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_RUNTIME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_RUNTIME = (\n    OptionGroup()\n    .add_option('runtime', type='str')\n)\nOPTION_SECURITY_OPTS = (\n    OptionGroup()\n    .add_option('security_opts', type='set', elements='str')\n)\nOPTION_SHM_SIZE = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='shm_size'))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_SECURITY_OPTS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_SECURITY_OPTS = (\n    OptionGroup()\n    .add_option('security_opts', type='set', elements='str')\n)\nOPTION_SHM_SIZE = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='shm_size'))\n    .add_option('shm_size', type='int', ansible_type='str')\n)\nOPTION_STOP_SIGNAL = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_SHM_SIZE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_SHM_SIZE = (\n    OptionGroup(preprocess=partial(_preprocess_convert_to_bytes, name='shm_size'))\n    .add_option('shm_size', type='int', ansible_type='str')\n)\nOPTION_STOP_SIGNAL = (\n    OptionGroup()\n    .add_option('stop_signal', type='str')\n)\nOPTION_STORAGE_OPTS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_STOP_SIGNAL",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_STOP_SIGNAL = (\n    OptionGroup()\n    .add_option('stop_signal', type='str')\n)\nOPTION_STORAGE_OPTS = (\n    OptionGroup()\n    .add_option('storage_opts', type='dict', needs_no_suboptions=True)\n)\nOPTION_SYSCTLS = (\n    OptionGroup(preprocess=_preprocess_sysctls)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_STORAGE_OPTS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_STORAGE_OPTS = (\n    OptionGroup()\n    .add_option('storage_opts', type='dict', needs_no_suboptions=True)\n)\nOPTION_SYSCTLS = (\n    OptionGroup(preprocess=_preprocess_sysctls)\n    .add_option('sysctls', type='dict', needs_no_suboptions=True)\n)\nOPTION_TMPFS = (\n    OptionGroup(preprocess=_preprocess_tmpfs)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_SYSCTLS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_SYSCTLS = (\n    OptionGroup(preprocess=_preprocess_sysctls)\n    .add_option('sysctls', type='dict', needs_no_suboptions=True)\n)\nOPTION_TMPFS = (\n    OptionGroup(preprocess=_preprocess_tmpfs)\n    .add_option('tmpfs', type='dict', ansible_type='list', ansible_elements='str')\n)\nOPTION_TTY = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_TMPFS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_TMPFS = (\n    OptionGroup(preprocess=_preprocess_tmpfs)\n    .add_option('tmpfs', type='dict', ansible_type='list', ansible_elements='str')\n)\nOPTION_TTY = (\n    OptionGroup()\n    .add_option('tty', type='bool')\n)\nOPTION_ULIMITS = (\n    OptionGroup(preprocess=_preprocess_ulimits)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_TTY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_TTY = (\n    OptionGroup()\n    .add_option('tty', type='bool')\n)\nOPTION_ULIMITS = (\n    OptionGroup(preprocess=_preprocess_ulimits)\n    .add_option('ulimits', type='set', elements='dict', ansible_elements='str')\n)\nOPTION_USER = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_ULIMITS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_ULIMITS = (\n    OptionGroup(preprocess=_preprocess_ulimits)\n    .add_option('ulimits', type='set', elements='dict', ansible_elements='str')\n)\nOPTION_USER = (\n    OptionGroup()\n    .add_option('user', type='str')\n)\nOPTION_USERNS_MODE = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_USER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_USER = (\n    OptionGroup()\n    .add_option('user', type='str')\n)\nOPTION_USERNS_MODE = (\n    OptionGroup()\n    .add_option('userns_mode', type='str')\n)\nOPTION_UTS = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_USERNS_MODE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_USERNS_MODE = (\n    OptionGroup()\n    .add_option('userns_mode', type='str')\n)\nOPTION_UTS = (\n    OptionGroup()\n    .add_option('uts', type='str')\n)\nOPTION_VOLUME_DRIVER = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_UTS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_UTS = (\n    OptionGroup()\n    .add_option('uts', type='str')\n)\nOPTION_VOLUME_DRIVER = (\n    OptionGroup()\n    .add_option('volume_driver', type='str')\n)\nOPTION_VOLUMES_FROM = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_VOLUME_DRIVER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_VOLUME_DRIVER = (\n    OptionGroup()\n    .add_option('volume_driver', type='str')\n)\nOPTION_VOLUMES_FROM = (\n    OptionGroup()\n    .add_option('volumes_from', type='set', elements='str')\n)\nOPTION_WORKING_DIR = (\n    OptionGroup()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_VOLUMES_FROM",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_VOLUMES_FROM = (\n    OptionGroup()\n    .add_option('volumes_from', type='set', elements='str')\n)\nOPTION_WORKING_DIR = (\n    OptionGroup()\n    .add_option('working_dir', type='str')\n)\nOPTION_MOUNTS_VOLUMES = (\n    OptionGroup(preprocess=_preprocess_mounts)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_WORKING_DIR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_WORKING_DIR = (\n    OptionGroup()\n    .add_option('working_dir', type='str')\n)\nOPTION_MOUNTS_VOLUMES = (\n    OptionGroup(preprocess=_preprocess_mounts)\n    .add_option('mounts', type='set', elements='dict', ansible_suboptions=dict(\n        target=dict(type='str', required=True),\n        source=dict(type='str'),\n        type=dict(type='str', choices=['bind', 'volume', 'tmpfs', 'npipe'], default='volume'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_MOUNTS_VOLUMES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_MOUNTS_VOLUMES = (\n    OptionGroup(preprocess=_preprocess_mounts)\n    .add_option('mounts', type='set', elements='dict', ansible_suboptions=dict(\n        target=dict(type='str', required=True),\n        source=dict(type='str'),\n        type=dict(type='str', choices=['bind', 'volume', 'tmpfs', 'npipe'], default='volume'),\n        read_only=dict(type='bool'),\n        consistency=dict(type='str', choices=['default', 'consistent', 'cached', 'delegated']),\n        propagation=dict(type='str', choices=['private', 'rprivate', 'shared', 'rshared', 'slave', 'rslave']),\n        no_copy=dict(type='bool'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTION_PORTS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTION_PORTS = (\n    OptionGroup(preprocess=_preprocess_ports)\n    .add_option('exposed_ports', type='set', elements='str', ansible_aliases=['exposed', 'expose'])\n    .add_option('publish_all_ports', type='bool')\n    .add_option('published_ports', type='dict', ansible_type='list', ansible_elements='str', ansible_aliases=['ports'])\n    .add_option('ports', type='set', elements='str', not_an_ansible_option=True, default_comparison='ignore')\n)\nOPTIONS = [\n    OPTION_AUTO_REMOVE,\n    OPTION_BLKIO_WEIGHT,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "OPTIONS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "peekOfCode": "OPTIONS = [\n    OPTION_AUTO_REMOVE,\n    OPTION_BLKIO_WEIGHT,\n    OPTION_CAPABILITIES,\n    OPTION_CAP_DROP,\n    OPTION_CGROUP_NS_MODE,\n    OPTION_CGROUP_PARENT,\n    OPTION_COMMAND,\n    OPTION_CPU_PERIOD,\n    OPTION_CPU_QUOTA,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.base",
        "documentation": {}
    },
    {
        "label": "DockerAPIEngineDriver",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "peekOfCode": "class DockerAPIEngineDriver(EngineDriver):\n    name = 'docker_api'\n    def setup(self, argument_spec, mutually_exclusive=None, required_together=None, required_one_of=None, required_if=None, required_by=None):\n        argument_spec = argument_spec or {}\n        mutually_exclusive = mutually_exclusive or []\n        required_together = required_together or []\n        required_one_of = required_one_of or []\n        required_if = required_if or []\n        required_by = required_by or {}\n        active_options = []",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "documentation": {}
    },
    {
        "label": "DockerAPIEngine",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "peekOfCode": "class DockerAPIEngine(Engine):\n    def __init__(\n        self,\n        get_value,\n        preprocess_value=None,\n        get_expected_values=None,\n        ignore_mismatching_result=None,\n        set_value=None,\n        update_value=None,\n        can_set_value=None,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport traceback\nfrom ansible.module_utils.common.text.converters import to_native, to_text\nfrom ansible.module_utils.common.text.formatters import human_to_bytes\nfrom ansible_collections.community.docker.plugins.module_utils.common_api import (\n    AnsibleDockerClient,\n    RequestException,\n)\nfrom ansible_collections.community.docker.plugins.module_utils._platform import (",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_IP_REPLACEMENT_STRING",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "peekOfCode": "_DEFAULT_IP_REPLACEMENT_STRING = '[[DEFAULT_IP:iewahhaeB4Sae6Aen8IeShairoh4zeph7xaekoh8Geingunaesaeweiy3ooleiwi]]'\n_MOUNT_OPTION_TYPES = dict(\n    volume_driver='volume',\n    volume_options='volume',\n    propagation='bind',\n    no_copy='volume',\n    labels='volume',\n    tmpfs_size='tmpfs',\n    tmpfs_mode='tmpfs',\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "documentation": {}
    },
    {
        "label": "_MOUNT_OPTION_TYPES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "peekOfCode": "_MOUNT_OPTION_TYPES = dict(\n    volume_driver='volume',\n    volume_options='volume',\n    propagation='bind',\n    no_copy='volume',\n    labels='volume',\n    tmpfs_size='tmpfs',\n    tmpfs_mode='tmpfs',\n)\ndef _get_ansible_type(type):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "documentation": {}
    },
    {
        "label": "_SENTRY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "peekOfCode": "_SENTRY = object()\nclass DockerAPIEngineDriver(EngineDriver):\n    name = 'docker_api'\n    def setup(self, argument_spec, mutually_exclusive=None, required_together=None, required_one_of=None, required_if=None, required_by=None):\n        argument_spec = argument_spec or {}\n        mutually_exclusive = mutually_exclusive or []\n        required_together = required_together or []\n        required_one_of = required_one_of or []\n        required_if = required_if or []\n        required_by = required_by or {}",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.docker_api",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "peekOfCode": "class Container(DockerBaseClass):\n    def __init__(self, container, engine_driver):\n        super(Container, self).__init__()\n        self.raw = container\n        self.id = None\n        self.image = None\n        self.image_name = None\n        self.container = container\n        self.engine_driver = engine_driver\n        if container:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "documentation": {}
    },
    {
        "label": "ContainerManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "peekOfCode": "class ContainerManager(DockerBaseClass):\n    def __init__(self, module, engine_driver, client, active_options):\n        self.module = module\n        self.engine_driver = engine_driver\n        self.client = client\n        self.options = active_options\n        self.all_options = self._collect_all_options(active_options)\n        self.check_mode = self.module.check_mode\n        self.param_cleanup = self.module.params['cleanup']\n        self.param_container_default_behavior = self.module.params['container_default_behavior']",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "documentation": {}
    },
    {
        "label": "run_module",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "peekOfCode": "def run_module(engine_driver):\n    module, active_options, client = engine_driver.setup(\n        argument_spec=dict(\n            cleanup=dict(type='bool', default=False),\n            comparisons=dict(type='dict'),\n            container_default_behavior=dict(type='str', default='no_defaults', choices=['compatibility', 'no_defaults']),\n            command_handling=dict(type='str', choices=['compatibility', 'correct'], default='correct'),\n            default_host_ip=dict(type='str'),\n            force_kill=dict(type='bool', default=False, aliases=['forcekill']),\n            ignore_image=dict(type='bool', default=False, removed_in_version='4.0.0', removed_from_collection='community.docker'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "peekOfCode": "__metaclass__ = type\nimport re\nfrom time import sleep\nfrom ansible.module_utils.common.text.converters import to_native, to_text\nfrom ansible_collections.community.docker.plugins.module_utils.util import (\n    DifferenceTracker,\n    DockerBaseClass,\n    compare_generic,\n    is_image_name_id,\n    sanitize_result,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.module_container.module",
        "documentation": {}
    },
    {
        "label": "InvalidLogFmt",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "peekOfCode": "class InvalidLogFmt(Exception):\n    pass\nclass _Mode(object):\n    GARBAGE = 0\n    KEY = 1\n    EQUAL = 2\n    IDENT_VALUE = 3\n    QUOTED_VALUE = 4\n_ESCAPE_DICT = {\n    '\"': '\"',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "_Mode",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "peekOfCode": "class _Mode(object):\n    GARBAGE = 0\n    KEY = 1\n    EQUAL = 2\n    IDENT_VALUE = 3\n    QUOTED_VALUE = 4\n_ESCAPE_DICT = {\n    '\"': '\"',\n    '\\\\': '\\\\',\n    \"'\": \"'\",",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "_Parser",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "peekOfCode": "class _Parser(object):\n    def __init__(self, line):\n        self.line = line\n        self.index = 0\n        self.length = len(line)\n    def done(self):\n        return self.index >= self.length\n    def cur(self):\n        return self.line[self.index]\n    def next(self):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "parse_line",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "peekOfCode": "def parse_line(line, logrus_mode=False):\n    result = {}\n    parser = _Parser(line)\n    key = []\n    value = []\n    mode = _Mode.GARBAGE\n    def handle_kv(has_no_value=False):\n        k = ''.join(key)\n        v = None if has_no_value else ''.join(value)\n        result[k] = v",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "peekOfCode": "__metaclass__ = type\n# The format is defined in https://pkg.go.dev/github.com/kr/logfmt?utm_source=godoc\n# (look for \"EBNFish\")\nclass InvalidLogFmt(Exception):\n    pass\nclass _Mode(object):\n    GARBAGE = 0\n    KEY = 1\n    EQUAL = 2\n    IDENT_VALUE = 3",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "_ESCAPE_DICT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "peekOfCode": "_ESCAPE_DICT = {\n    '\"': '\"',\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '/': '/',\n    'b': '\\b',\n    'f': '\\f',\n    'n': '\\n',\n    'r': '\\r',\n    't': '\\t',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "_HEX_DICT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "peekOfCode": "_HEX_DICT = {\n    '0': 0,\n    '1': 1,\n    '2': 2,\n    '3': 3,\n    '4': 4,\n    '5': 5,\n    '6': 6,\n    '7': 7,\n    '8': 8,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._logfmt",
        "documentation": {}
    },
    {
        "label": "_Platform",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "class _Platform(object):\n    def __init__(self, os=None, arch=None, variant=None):\n        self.os = os\n        self.arch = arch\n        self.variant = variant\n        if variant is not None:\n            if arch is None:\n                raise ValueError('If variant is given, architecture must be given too')\n            if os is None:\n                raise ValueError('If variant is given, os must be given too')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "normalize_platform_string",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "def normalize_platform_string(string, daemon_os=None, daemon_arch=None):\n    return str(_Platform.parse_platform_string(string, daemon_os=daemon_os, daemon_arch=daemon_arch))\ndef compose_platform_string(os=None, arch=None, variant=None, daemon_os=None, daemon_arch=None):\n    if os is None and daemon_os is not None:\n        os = _normalize_os(daemon_os)\n    if arch is None and daemon_arch is not None:\n        arch, variant = _normalize_arch(daemon_arch, variant or '')\n        variant = variant or None\n    return str(_Platform(os=os, arch=arch, variant=variant or None))\ndef compare_platform_strings(string1, string2):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "compose_platform_string",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "def compose_platform_string(os=None, arch=None, variant=None, daemon_os=None, daemon_arch=None):\n    if os is None and daemon_os is not None:\n        os = _normalize_os(daemon_os)\n    if arch is None and daemon_arch is not None:\n        arch, variant = _normalize_arch(daemon_arch, variant or '')\n        variant = variant or None\n    return str(_Platform(os=os, arch=arch, variant=variant or None))\ndef compare_platform_strings(string1, string2):\n    return _Platform.parse_platform_string(string1) == _Platform.parse_platform_string(string2)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "compare_platform_strings",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "def compare_platform_strings(string1, string2):\n    return _Platform.parse_platform_string(string1) == _Platform.parse_platform_string(string2)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "__metaclass__ = type\nimport re\n_VALID_STR = re.compile('^[A-Za-z0-9_-]+$')\ndef _validate_part(string, part, part_name):\n    if not part:\n        raise ValueError('Invalid platform string \"{string}\": {part} is empty'.format(string=string, part=part_name))\n    if not _VALID_STR.match(part):\n        raise ValueError('Invalid platform string \"{string}\": {part} has invalid characters'.format(string=string, part=part_name))\n    return part\n# See https://github.com/containerd/containerd/blob/main/platforms/database.go#L32-L38",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "_VALID_STR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "_VALID_STR = re.compile('^[A-Za-z0-9_-]+$')\ndef _validate_part(string, part, part_name):\n    if not part:\n        raise ValueError('Invalid platform string \"{string}\": {part} is empty'.format(string=string, part=part_name))\n    if not _VALID_STR.match(part):\n        raise ValueError('Invalid platform string \"{string}\": {part} has invalid characters'.format(string=string, part=part_name))\n    return part\n# See https://github.com/containerd/containerd/blob/main/platforms/database.go#L32-L38\n_KNOWN_OS = (\n    \"aix\", \"android\", \"darwin\", \"dragonfly\", \"freebsd\", \"hurd\", \"illumos\", \"ios\", \"js\",",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "_KNOWN_OS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "_KNOWN_OS = (\n    \"aix\", \"android\", \"darwin\", \"dragonfly\", \"freebsd\", \"hurd\", \"illumos\", \"ios\", \"js\",\n    \"linux\", \"nacl\", \"netbsd\", \"openbsd\", \"plan9\", \"solaris\", \"windows\", \"zos\",\n)\n# See https://github.com/containerd/containerd/blob/main/platforms/database.go#L54-L60\n_KNOWN_ARCH = (\n    \"386\", \"amd64\", \"amd64p32\", \"arm\", \"armbe\", \"arm64\", \"arm64be\", \"ppc64\", \"ppc64le\",\n    \"loong64\", \"mips\", \"mipsle\", \"mips64\", \"mips64le\", \"mips64p32\", \"mips64p32le\",\n    \"ppc\", \"riscv\", \"riscv64\", \"s390\", \"s390x\", \"sparc\", \"sparc64\", \"wasm\",\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "_KNOWN_ARCH",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "_KNOWN_ARCH = (\n    \"386\", \"amd64\", \"amd64p32\", \"arm\", \"armbe\", \"arm64\", \"arm64be\", \"ppc64\", \"ppc64le\",\n    \"loong64\", \"mips\", \"mipsle\", \"mips64\", \"mips64le\", \"mips64p32\", \"mips64p32le\",\n    \"ppc\", \"riscv\", \"riscv64\", \"s390\", \"s390x\", \"sparc\", \"sparc64\", \"wasm\",\n)\ndef _normalize_os(os_str):\n    # See normalizeOS() in https://github.com/containerd/containerd/blob/main/platforms/database.go\n    os_str = os_str.lower()\n    if os_str == 'macos':\n        os_str = 'darwin'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "_NORMALIZE_ARCH",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "peekOfCode": "_NORMALIZE_ARCH = {\n    (\"i386\", None): (\"386\", \"\"),\n    (\"x86_64\", \"v1\"): (\"amd64\", \"\"),\n    (\"x86-64\", \"v1\"): (\"amd64\", \"\"),\n    (\"amd64\", \"v1\"): (\"amd64\", \"\"),\n    (\"x86_64\", None): (\"amd64\", None),\n    (\"x86-64\", None): (\"amd64\", None),\n    (\"amd64\", None): (\"amd64\", None),\n    (\"aarch64\", \"8\"): (\"arm64\", \"\"),\n    (\"arm64\", \"8\"): (\"arm64\", \"\"),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._platform",
        "documentation": {}
    },
    {
        "label": "generate_insecure_key",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "peekOfCode": "def generate_insecure_key():\n    '''Do NOT use this for cryptographic purposes!'''\n    while True:\n        # Generate a one-byte key. Right now the functions below do not use more\n        # than one byte, so this is sufficient.\n        if PY2:\n            key = chr(random.randint(0, 255))\n        else:\n            key = bytes([random.randint(0, 255)])\n        # Return anything that is not zero",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "scramble",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "peekOfCode": "def scramble(value, key):\n    '''Do NOT use this for cryptographic purposes!'''\n    if len(key) < 1:\n        raise ValueError('Key must be at least one byte')\n    value = to_bytes(value)\n    if PY2:\n        k = ord(key[0])\n        value = b''.join([chr(k ^ ord(b)) for b in value])\n    else:\n        k = key[0]",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "unscramble",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "peekOfCode": "def unscramble(value, key):\n    '''Do NOT use this for cryptographic purposes!'''\n    if len(key) < 1:\n        raise ValueError('Key must be at least one byte')\n    if not value.startswith(u'=S='):\n        raise ValueError('Value does not start with indicator')\n    value = base64.b64decode(value[3:])\n    if PY2:\n        k = ord(key[0])\n        value = b''.join([chr(k ^ ord(b)) for b in value])",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "peekOfCode": "__metaclass__ = type\nimport base64\nimport random\nfrom ansible.module_utils.common.text.converters import to_bytes, to_native, to_text\nfrom ansible.module_utils.six import PY2\ndef generate_insecure_key():\n    '''Do NOT use this for cryptographic purposes!'''\n    while True:\n        # Generate a one-byte key. Right now the functions below do not use more\n        # than one byte, so this is sufficient.",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils._scramble",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClientBase",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "class AnsibleDockerClientBase(Client):\n    def __init__(self, min_docker_version=None, min_docker_api_version=None):\n        if min_docker_version is None:\n            min_docker_version = MIN_DOCKER_VERSION\n        NEEDS_DOCKER_PY2 = (LooseVersion(min_docker_version) >= LooseVersion('2.0.0'))\n        self.docker_py_version = LooseVersion(docker_version)\n        if HAS_DOCKER_MODELS and HAS_DOCKER_SSLADAPTER:\n            self.fail(\"Cannot have both the docker-py and docker python modules (old and new version of Docker \"\n                      \"SDK for Python) installed together as they use the same namespace and cause a corrupt \"\n                      \"installation. Please uninstall both packages, and re-install only the docker-py or docker \"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "class AnsibleDockerClient(AnsibleDockerClientBase):\n    def __init__(self, argument_spec=None, supports_check_mode=False, mutually_exclusive=None,\n                 required_together=None, required_if=None, required_one_of=None, required_by=None,\n                 min_docker_version=None, min_docker_api_version=None, option_minimal_versions=None,\n                 option_minimal_versions_ignore_params=None, fail_results=None):\n        # Modules can put information in here which will always be returned\n        # in case client.fail() is called.\n        self.fail_results = fail_results or {}\n        merged_arg_spec = dict()\n        merged_arg_spec.update(DOCKER_COMMON_ARGS)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "is_using_tls",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "def is_using_tls(auth):\n    return auth['tls_verify'] or auth['tls']\ndef get_connect_params(auth, fail_function):\n    if is_using_tls(auth):\n        auth['docker_host'] = auth['docker_host'].replace('tcp://', 'https://')\n    result = dict(\n        base_url=auth['docker_host'],\n        version=auth['api_version'],\n        timeout=auth['timeout'],\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "get_connect_params",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "def get_connect_params(auth, fail_function):\n    if is_using_tls(auth):\n        auth['docker_host'] = auth['docker_host'].replace('tcp://', 'https://')\n    result = dict(\n        base_url=auth['docker_host'],\n        version=auth['api_version'],\n        timeout=auth['timeout'],\n    )\n    if auth['tls_verify']:\n        # TLS with verification",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "__metaclass__ = type\nimport abc\nimport os\nimport platform\nimport re\nimport sys\nimport traceback\nfrom ansible.module_utils.basic import AnsibleModule, missing_required_lib\nfrom ansible.module_utils.common._collections_compat import Mapping, Sequence\nfrom ansible.module_utils.six import string_types",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "HAS_DOCKER_PY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "HAS_DOCKER_PY = True\nHAS_DOCKER_PY_2 = False\nHAS_DOCKER_PY_3 = False\nHAS_DOCKER_ERROR = None\nHAS_DOCKER_TRACEBACK = None\ntry:\n    from requests.exceptions import SSLError\n    from docker import __version__ as docker_version\n    from docker.errors import APIError, NotFound, TLSParameterError\n    from docker.tls import TLSConfig",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "HAS_DOCKER_PY_2",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "HAS_DOCKER_PY_2 = False\nHAS_DOCKER_PY_3 = False\nHAS_DOCKER_ERROR = None\nHAS_DOCKER_TRACEBACK = None\ntry:\n    from requests.exceptions import SSLError\n    from docker import __version__ as docker_version\n    from docker.errors import APIError, NotFound, TLSParameterError\n    from docker.tls import TLSConfig\n    from docker import auth",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "HAS_DOCKER_PY_3",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "HAS_DOCKER_PY_3 = False\nHAS_DOCKER_ERROR = None\nHAS_DOCKER_TRACEBACK = None\ntry:\n    from requests.exceptions import SSLError\n    from docker import __version__ as docker_version\n    from docker.errors import APIError, NotFound, TLSParameterError\n    from docker.tls import TLSConfig\n    from docker import auth\n    if LooseVersion(docker_version) >= LooseVersion('3.0.0'):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "HAS_DOCKER_ERROR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "HAS_DOCKER_ERROR = None\nHAS_DOCKER_TRACEBACK = None\ntry:\n    from requests.exceptions import SSLError\n    from docker import __version__ as docker_version\n    from docker.errors import APIError, NotFound, TLSParameterError\n    from docker.tls import TLSConfig\n    from docker import auth\n    if LooseVersion(docker_version) >= LooseVersion('3.0.0'):\n        HAS_DOCKER_PY_3 = True",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "HAS_DOCKER_TRACEBACK",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "HAS_DOCKER_TRACEBACK = None\ntry:\n    from requests.exceptions import SSLError\n    from docker import __version__ as docker_version\n    from docker.errors import APIError, NotFound, TLSParameterError\n    from docker.tls import TLSConfig\n    from docker import auth\n    if LooseVersion(docker_version) >= LooseVersion('3.0.0'):\n        HAS_DOCKER_PY_3 = True\n        from docker import APIClient as Client",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "MIN_DOCKER_VERSION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "MIN_DOCKER_VERSION = \"1.8.0\"\nif not HAS_DOCKER_PY:\n    docker_version = None\n    # No Docker SDK for Python. Create a place holder client to allow\n    # instantiation of AnsibleModule and proper error handing\n    class Client(object):  # noqa: F811\n        def __init__(self, **kwargs):\n            pass\n    class APIError(Exception):  # noqa: F811\n        pass",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "DOCKERPYUPGRADE_SWITCH_TO_DOCKER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "DOCKERPYUPGRADE_SWITCH_TO_DOCKER = \"Try `pip uninstall docker-py` followed by `pip install docker`.\"\nDOCKERPYUPGRADE_UPGRADE_DOCKER = \"Use `pip install --upgrade docker` to upgrade.\"\nDOCKERPYUPGRADE_RECOMMEND_DOCKER = \"Use `pip install --upgrade docker-py` to upgrade.\"\nclass AnsibleDockerClientBase(Client):\n    def __init__(self, min_docker_version=None, min_docker_api_version=None):\n        if min_docker_version is None:\n            min_docker_version = MIN_DOCKER_VERSION\n        NEEDS_DOCKER_PY2 = (LooseVersion(min_docker_version) >= LooseVersion('2.0.0'))\n        self.docker_py_version = LooseVersion(docker_version)\n        if HAS_DOCKER_MODELS and HAS_DOCKER_SSLADAPTER:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "DOCKERPYUPGRADE_UPGRADE_DOCKER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "DOCKERPYUPGRADE_UPGRADE_DOCKER = \"Use `pip install --upgrade docker` to upgrade.\"\nDOCKERPYUPGRADE_RECOMMEND_DOCKER = \"Use `pip install --upgrade docker-py` to upgrade.\"\nclass AnsibleDockerClientBase(Client):\n    def __init__(self, min_docker_version=None, min_docker_api_version=None):\n        if min_docker_version is None:\n            min_docker_version = MIN_DOCKER_VERSION\n        NEEDS_DOCKER_PY2 = (LooseVersion(min_docker_version) >= LooseVersion('2.0.0'))\n        self.docker_py_version = LooseVersion(docker_version)\n        if HAS_DOCKER_MODELS and HAS_DOCKER_SSLADAPTER:\n            self.fail(\"Cannot have both the docker-py and docker python modules (old and new version of Docker \"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "DOCKERPYUPGRADE_RECOMMEND_DOCKER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "peekOfCode": "DOCKERPYUPGRADE_RECOMMEND_DOCKER = \"Use `pip install --upgrade docker-py` to upgrade.\"\nclass AnsibleDockerClientBase(Client):\n    def __init__(self, min_docker_version=None, min_docker_api_version=None):\n        if min_docker_version is None:\n            min_docker_version = MIN_DOCKER_VERSION\n        NEEDS_DOCKER_PY2 = (LooseVersion(min_docker_version) >= LooseVersion('2.0.0'))\n        self.docker_py_version = LooseVersion(docker_version)\n        if HAS_DOCKER_MODELS and HAS_DOCKER_SSLADAPTER:\n            self.fail(\"Cannot have both the docker-py and docker python modules (old and new version of Docker \"\n                      \"SDK for Python) installed together as they use the same namespace and cause a corrupt \"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClientBase",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "peekOfCode": "class AnsibleDockerClientBase(Client):\n    def __init__(self, min_docker_api_version=None):\n        self._connect_params = get_connect_params(self.auth_params, fail_function=self.fail)\n        try:\n            super(AnsibleDockerClientBase, self).__init__(**self._connect_params)\n            self.docker_api_version_str = self.api_version\n        except MissingRequirementException as exc:\n            self.fail(missing_required_lib(exc.requirement), exception=exc.import_exception)\n        except APIError as exc:\n            self.fail(\"Docker API error: %s\" % exc)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "peekOfCode": "class AnsibleDockerClient(AnsibleDockerClientBase):\n    def __init__(self, argument_spec=None, supports_check_mode=False, mutually_exclusive=None,\n                 required_together=None, required_if=None, required_one_of=None, required_by=None,\n                 min_docker_api_version=None, option_minimal_versions=None,\n                 option_minimal_versions_ignore_params=None, fail_results=None):\n        # Modules can put information in here which will always be returned\n        # in case client.fail() is called.\n        self.fail_results = fail_results or {}\n        merged_arg_spec = dict()\n        merged_arg_spec.update(DOCKER_COMMON_ARGS)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "is_using_tls",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "peekOfCode": "def is_using_tls(auth_data):\n    return auth_data['tls_verify'] or auth_data['tls']\ndef get_connect_params(auth_data, fail_function):\n    if is_using_tls(auth_data):\n        auth_data['docker_host'] = auth_data['docker_host'].replace('tcp://', 'https://')\n    result = dict(\n        base_url=auth_data['docker_host'],\n        version=auth_data['api_version'],\n        timeout=auth_data['timeout'],\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "get_connect_params",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "peekOfCode": "def get_connect_params(auth_data, fail_function):\n    if is_using_tls(auth_data):\n        auth_data['docker_host'] = auth_data['docker_host'].replace('tcp://', 'https://')\n    result = dict(\n        base_url=auth_data['docker_host'],\n        version=auth_data['api_version'],\n        timeout=auth_data['timeout'],\n    )\n    if auth_data['tls_verify']:\n        # TLS with verification",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "peekOfCode": "__metaclass__ = type\nimport abc\nimport os\nimport re\nfrom ansible.module_utils.basic import AnsibleModule, missing_required_lib\nfrom ansible.module_utils.common._collections_compat import Mapping, Sequence\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils.parsing.convert_bool import BOOLEANS_TRUE, BOOLEANS_FALSE\nfrom ansible_collections.community.docker.plugins.module_utils.version import LooseVersion\ntry:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_api",
        "documentation": {}
    },
    {
        "label": "DockerException",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "peekOfCode": "class DockerException(Exception):\n    pass\nclass AnsibleDockerClientBase(object):\n    def __init__(self, common_args, min_docker_api_version=None):\n        self._environment = {}\n        if common_args['tls_hostname']:\n            self._environment['DOCKER_TLS_HOSTNAME'] = common_args['tls_hostname']\n        if common_args['api_version'] and common_args['api_version'] != 'auto':\n            self._environment['DOCKER_API_VERSION'] = common_args['api_version']\n        self._cli = common_args.get('docker_cli')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClientBase",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "peekOfCode": "class AnsibleDockerClientBase(object):\n    def __init__(self, common_args, min_docker_api_version=None):\n        self._environment = {}\n        if common_args['tls_hostname']:\n            self._environment['DOCKER_TLS_HOSTNAME'] = common_args['tls_hostname']\n        if common_args['api_version'] and common_args['api_version'] != 'auto':\n            self._environment['DOCKER_API_VERSION'] = common_args['api_version']\n        self._cli = common_args.get('docker_cli')\n        if self._cli is None:\n            try:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "AnsibleModuleDockerClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "peekOfCode": "class AnsibleModuleDockerClient(AnsibleDockerClientBase):\n    def __init__(self, argument_spec=None, supports_check_mode=False, mutually_exclusive=None,\n                 required_together=None, required_if=None, required_one_of=None, required_by=None,\n                 min_docker_api_version=None, fail_results=None):\n        # Modules can put information in here which will always be returned\n        # in case client.fail() is called.\n        self.fail_results = fail_results or {}\n        merged_arg_spec = dict()\n        merged_arg_spec.update(DOCKER_COMMON_ARGS)\n        if argument_spec:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "peekOfCode": "__metaclass__ = type\nimport abc\nimport json\nimport shlex\nfrom ansible.module_utils.basic import AnsibleModule, env_fallback\nfrom ansible.module_utils.common.process import get_bin_path\nfrom ansible.module_utils.common.text.converters import to_native\nfrom ansible_collections.community.docker.plugins.module_utils.version import LooseVersion\nfrom ansible_collections.community.docker.plugins.module_utils._api.auth import resolve_repository_name\nfrom ansible_collections.community.docker.plugins.module_utils.util import (  # noqa: F401, pylint: disable=unused-import",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "peekOfCode": "DOCKER_COMMON_ARGS = dict(\n    docker_cli=dict(type='path'),\n    docker_host=dict(type='str', fallback=(env_fallback, ['DOCKER_HOST']), aliases=['docker_url']),\n    tls_hostname=dict(type='str', fallback=(env_fallback, ['DOCKER_TLS_HOSTNAME'])),\n    api_version=dict(type='str', default='auto', fallback=(env_fallback, ['DOCKER_API_VERSION']), aliases=['docker_api_version']),\n    ca_path=dict(type='path', aliases=['ca_cert', 'tls_ca_cert', 'cacert_path']),\n    client_cert=dict(type='path', aliases=['tls_client_cert', 'cert_path']),\n    client_key=dict(type='path', aliases=['tls_client_key', 'key_path']),\n    tls=dict(type='bool', default=DEFAULT_TLS, fallback=(env_fallback, ['DOCKER_TLS'])),\n    validate_certs=dict(type='bool', default=DEFAULT_TLS_VERIFY, fallback=(env_fallback, ['DOCKER_TLS_VERIFY']), aliases=['tls_verify']),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.common_cli",
        "documentation": {}
    },
    {
        "label": "ResourceType",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "class ResourceType(object):\n    UNKNOWN = \"unknown\"\n    NETWORK = \"network\"\n    IMAGE = \"image\"\n    IMAGE_LAYER = \"image-layer\"\n    VOLUME = \"volume\"\n    CONTAINER = \"container\"\n    SERVICE = \"service\"\n    @classmethod\n    def from_docker_compose_event(cls, resource_type):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "BaseComposeManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "class BaseComposeManager(DockerBaseClass):\n    def __init__(self, client, min_version=MINIMUM_COMPOSE_VERSION):\n        super(BaseComposeManager, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        self.cleanup_dirs = set()\n        parameters = self.client.module.params\n        if parameters['definition'] is not None and not HAS_PYYAML:\n            self.fail(\n                missing_required_lib('PyYAML'),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "parse_events",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def parse_events(stderr, dry_run=False, warn_function=None):\n    events = []\n    error_event = None\n    stderr_lines = stderr.splitlines()\n    if stderr_lines and stderr_lines[-1] == b'':\n        del stderr_lines[-1]\n    for line in stderr_lines:\n        line = to_native(line.strip())\n        if not line:\n            continue",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "has_changes",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def has_changes(events, ignore_service_pull_events=False):\n    for event in events:\n        if event.status in DOCKER_STATUS_WORKING:\n            if ignore_service_pull_events and event.status in DOCKER_STATUS_PULL:\n                continue\n            return True\n        if event.resource_type == ResourceType.IMAGE_LAYER and event.status in DOCKER_PULL_PROGRESS_WORKING:\n            return True\n    return False\ndef extract_actions(events):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "extract_actions",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def extract_actions(events):\n    actions = []\n    pull_actions = set()\n    for event in events:\n        if event.resource_type == ResourceType.IMAGE_LAYER and event.status in DOCKER_PULL_PROGRESS_WORKING:\n            pull_id = (event.resource_id, event.status)\n            if pull_id not in pull_actions:\n                pull_actions.add(pull_id)\n                actions.append({\n                    'what': event.resource_type,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "emit_warnings",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def emit_warnings(events, warn_function):\n    for event in events:\n        # If a message is present, assume it is a warning\n        if event.status is None and event.msg is not None:\n            warn_function('Docker compose: {resource_type} {resource_id}: {msg}'.format(\n                resource_type=event.resource_type,\n                resource_id=event.resource_id,\n                msg=event.msg,\n            ))\ndef is_failed(events, rc):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "is_failed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def is_failed(events, rc):\n    if rc:\n        return True\n    return False\ndef update_failed(result, events, args, stdout, stderr, rc, cli):\n    if not rc:\n        return False\n    errors = []\n    for event in events:\n        if event.status in DOCKER_STATUS_ERROR:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "update_failed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def update_failed(result, events, args, stdout, stderr, rc, cli):\n    if not rc:\n        return False\n    errors = []\n    for event in events:\n        if event.status in DOCKER_STATUS_ERROR:\n            msg = 'Error when processing {resource_type} {resource_id}: '\n            if event.resource_type == 'unknown':\n                msg = 'Error when processing {resource_id}: '\n                if event.resource_id == '':",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "common_compose_argspec",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def common_compose_argspec():\n    return dict(\n        project_src=dict(type='path'),\n        project_name=dict(type='str'),\n        files=dict(type='list', elements='path'),\n        definition=dict(type='dict'),\n        env_files=dict(type='list', elements='path'),\n        profiles=dict(type='list', elements='str'),\n        check_files_existing=dict(type='bool', default=True),\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "common_compose_argspec_ex",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def common_compose_argspec_ex():\n    return dict(\n        argspec=common_compose_argspec(),\n        mutually_exclusive=[\n            ('definition', 'project_src'),\n            ('definition', 'files')\n        ],\n        required_one_of=[\n            ('definition', 'project_src'),\n        ],",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "combine_binary_output",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def combine_binary_output(*outputs):\n    return b'\\n'.join(out for out in outputs if out)\ndef combine_text_output(*outputs):\n    return '\\n'.join(out for out in outputs if out)\nclass BaseComposeManager(DockerBaseClass):\n    def __init__(self, client, min_version=MINIMUM_COMPOSE_VERSION):\n        super(BaseComposeManager, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        self.cleanup_dirs = set()",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "combine_text_output",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "def combine_text_output(*outputs):\n    return '\\n'.join(out for out in outputs if out)\nclass BaseComposeManager(DockerBaseClass):\n    def __init__(self, client, min_version=MINIMUM_COMPOSE_VERSION):\n        super(BaseComposeManager, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        self.cleanup_dirs = set()\n        parameters = self.client.module.params\n        if parameters['definition'] is not None and not HAS_PYYAML:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport re\nimport shutil\nimport tempfile\nimport traceback\nfrom collections import namedtuple\nfrom ansible.module_utils.basic import missing_required_lib\nfrom ansible.module_utils.common.text.converters import to_native\nfrom ansible.module_utils.six.moves import shlex_quote",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMPOSE_FILES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_COMPOSE_FILES = ('compose.yaml', 'compose.yml', 'docker-compose.yaml', 'docker-compose.yml')\nDOCKER_STATUS_DONE = frozenset((\n    'Started',\n    'Healthy',\n    'Exited',\n    'Restarted',\n    'Running',\n    'Created',\n    'Stopped',\n    'Killed',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_STATUS_DONE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_STATUS_DONE = frozenset((\n    'Started',\n    'Healthy',\n    'Exited',\n    'Restarted',\n    'Running',\n    'Created',\n    'Stopped',\n    'Killed',\n    'Removed',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_STATUS_WORKING",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_STATUS_WORKING = frozenset((\n    'Creating',\n    'Starting',\n    'Restarting',\n    'Stopping',\n    'Killing',\n    'Removing',\n    # An extra, specific to containers\n    'Recreate',\n    # Extras for pull events",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_STATUS_PULL",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_STATUS_PULL = frozenset((\n    'Pulled',\n    'Pulling',\n))\nDOCKER_STATUS_ERROR = frozenset((\n    'Error',\n))\nDOCKER_STATUS_WARNING = frozenset((\n    'Warning',\n))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_STATUS_ERROR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_STATUS_ERROR = frozenset((\n    'Error',\n))\nDOCKER_STATUS_WARNING = frozenset((\n    'Warning',\n))\nDOCKER_STATUS_WAITING = frozenset((\n    'Waiting',\n))\nDOCKER_STATUS = frozenset(DOCKER_STATUS_DONE | DOCKER_STATUS_WORKING | DOCKER_STATUS_PULL | DOCKER_STATUS_ERROR | DOCKER_STATUS_WAITING)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_STATUS_WARNING",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_STATUS_WARNING = frozenset((\n    'Warning',\n))\nDOCKER_STATUS_WAITING = frozenset((\n    'Waiting',\n))\nDOCKER_STATUS = frozenset(DOCKER_STATUS_DONE | DOCKER_STATUS_WORKING | DOCKER_STATUS_PULL | DOCKER_STATUS_ERROR | DOCKER_STATUS_WAITING)\nDOCKER_PULL_PROGRESS_DONE = frozenset((\n    'Already exists',\n    'Download complete',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_STATUS_WAITING",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_STATUS_WAITING = frozenset((\n    'Waiting',\n))\nDOCKER_STATUS = frozenset(DOCKER_STATUS_DONE | DOCKER_STATUS_WORKING | DOCKER_STATUS_PULL | DOCKER_STATUS_ERROR | DOCKER_STATUS_WAITING)\nDOCKER_PULL_PROGRESS_DONE = frozenset((\n    'Already exists',\n    'Download complete',\n    'Pull complete',\n))\nDOCKER_PULL_PROGRESS_WORKING = frozenset((",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_STATUS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_STATUS = frozenset(DOCKER_STATUS_DONE | DOCKER_STATUS_WORKING | DOCKER_STATUS_PULL | DOCKER_STATUS_ERROR | DOCKER_STATUS_WAITING)\nDOCKER_PULL_PROGRESS_DONE = frozenset((\n    'Already exists',\n    'Download complete',\n    'Pull complete',\n))\nDOCKER_PULL_PROGRESS_WORKING = frozenset((\n    'Pulling fs layer',\n    'Waiting',\n    'Downloading',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_PULL_PROGRESS_DONE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_PULL_PROGRESS_DONE = frozenset((\n    'Already exists',\n    'Download complete',\n    'Pull complete',\n))\nDOCKER_PULL_PROGRESS_WORKING = frozenset((\n    'Pulling fs layer',\n    'Waiting',\n    'Downloading',\n    'Verifying Checksum',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCKER_PULL_PROGRESS_WORKING",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "DOCKER_PULL_PROGRESS_WORKING = frozenset((\n    'Pulling fs layer',\n    'Waiting',\n    'Downloading',\n    'Verifying Checksum',\n    'Extracting',\n))\nclass ResourceType(object):\n    UNKNOWN = \"unknown\"\n    NETWORK = \"network\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "Event",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "Event = namedtuple(\n    'Event',\n    ['resource_type', 'resource_id', 'status', 'msg']\n)\n_DRY_RUN_MARKER = 'DRY-RUN MODE -'\n_RE_RESOURCE_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<resource_type>Network|Image|Volume|Container)'\n    r'\\s+'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_DRY_RUN_MARKER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_DRY_RUN_MARKER = 'DRY-RUN MODE -'\n_RE_RESOURCE_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<resource_type>Network|Image|Volume|Container)'\n    r'\\s+'\n    r'(?P<resource_id>\\S+)'\n    r'\\s+'\n    r'(?P<status>\\S(?:|.*\\S))'\n    r'\\s*'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_RESOURCE_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_RESOURCE_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<resource_type>Network|Image|Volume|Container)'\n    r'\\s+'\n    r'(?P<resource_id>\\S+)'\n    r'\\s+'\n    r'(?P<status>\\S(?:|.*\\S))'\n    r'\\s*'\n    r'$'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_PULL_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_PULL_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<service>\\S+)'\n    r'\\s+'\n    r'(?P<status>%s)'\n    r'\\s*'\n    r'$'\n    % '|'.join(re.escape(status) for status in DOCKER_STATUS_PULL)\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_PULL_PROGRESS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_PULL_PROGRESS = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<layer>\\S+)'\n    r'\\s+'\n    r'(?P<status>%s)'\n    r'\\s*'\n    r'(?:|\\s\\[[^]]+\\]\\s+\\S+\\s*|\\s+[0-9.kKmMgGbB]+/[0-9.kKmMgGbB]+\\s*)'\n    r'$'\n    % '|'.join(re.escape(status) for status in sorted(DOCKER_PULL_PROGRESS_DONE | DOCKER_PULL_PROGRESS_WORKING))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_ERROR_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_ERROR_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<resource_id>\\S+)'\n    r'\\s+'\n    r'(?P<status>%s)'\n    r'\\s*'\n    r'(?P<msg>\\S.*\\S)?'\n    r'$'\n    % '|'.join(re.escape(status) for status in DOCKER_STATUS_ERROR)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_WARNING_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_WARNING_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<resource_id>\\S+)'\n    r'\\s+'\n    r'(?P<status>%s)'\n    r'\\s*'\n    r'(?P<msg>\\S.*\\S)?'\n    r'$'\n    % '|'.join(re.escape(status) for status in DOCKER_STATUS_WARNING)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_CONTINUE_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_CONTINUE_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<resource_id>\\S+)'\n    r'\\s+'\n    r'-'\n    r'\\s*'\n    r'(?P<msg>\\S(?:|.*\\S))'\n    r'$'\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_SKIPPED_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_SKIPPED_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'(?P<resource_id>\\S+)'\n    r'\\s+'\n    r'Skipped(?: -'\n    r'\\s*'\n    r'(?P<msg>\\S(?:|.*\\S))|\\s*)'\n    r'$'\n)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_BUILD_START_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_BUILD_START_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'build service'\n    r'\\s+'\n    r'(?P<resource_id>\\S+)'\n    r'$'\n)\n_RE_BUILD_PROGRESS_EVENT = re.compile(\n    r'^'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "_RE_BUILD_PROGRESS_EVENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "_RE_BUILD_PROGRESS_EVENT = re.compile(\n    r'^'\n    r'\\s*'\n    r'==>'\n    r'\\s+'\n    r'(?P<msg>.*)'\n    r'$'\n)\n# The following needs to be kept in sync with the MINIMUM_VERSION compose_v2 docs fragment\nMINIMUM_COMPOSE_VERSION = '2.18.0'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "MINIMUM_COMPOSE_VERSION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "peekOfCode": "MINIMUM_COMPOSE_VERSION = '2.18.0'\ndef _extract_event(line, warn_function=None):\n    match = _RE_RESOURCE_EVENT.match(line)\n    if match is not None:\n        status = match.group('status')\n        msg = None\n        if status not in DOCKER_STATUS:\n            status, msg = msg, status\n        return Event(\n            ResourceType.from_docker_compose_event(match.group('resource_type')),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.compose_v2",
        "documentation": {}
    },
    {
        "label": "DockerFileCopyError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "class DockerFileCopyError(Exception):\n    pass\nclass DockerUnexpectedError(DockerFileCopyError):\n    pass\nclass DockerFileNotFound(DockerFileCopyError):\n    pass\ndef _put_archive(client, container, path, data):\n    # data can also be file object for streaming. This is because _put uses requests's put().\n    # See https://requests.readthedocs.io/en/latest/user/advanced/#streaming-uploads\n    url = client._url('/containers/{0}/archive', container)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "DockerUnexpectedError",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "class DockerUnexpectedError(DockerFileCopyError):\n    pass\nclass DockerFileNotFound(DockerFileCopyError):\n    pass\ndef _put_archive(client, container, path, data):\n    # data can also be file object for streaming. This is because _put uses requests's put().\n    # See https://requests.readthedocs.io/en/latest/user/advanced/#streaming-uploads\n    url = client._url('/containers/{0}/archive', container)\n    res = client._put(url, params={'path': path}, data=data)\n    client._raise_for_status(res)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "DockerFileNotFound",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "class DockerFileNotFound(DockerFileCopyError):\n    pass\ndef _put_archive(client, container, path, data):\n    # data can also be file object for streaming. This is because _put uses requests's put().\n    # See https://requests.readthedocs.io/en/latest/user/advanced/#streaming-uploads\n    url = client._url('/containers/{0}/archive', container)\n    res = client._put(url, params={'path': path}, data=data)\n    client._raise_for_status(res)\n    return res.status_code == 200\ndef _symlink_tar_creator(b_in_path, file_stat, out_file, user_id, group_id, mode=None, user_name=None):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "_RawGeneratorFileobj",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "class _RawGeneratorFileobj(io.RawIOBase):\n    def __init__(self, stream):\n        self._stream = stream\n        self._buf = b''\n    def readable(self):\n        return True\n    def _readinto_from_buf(self, b, index, length):\n        cpy = min(length - index, len(self._buf))\n        if cpy:\n            b[index:index + cpy] = self._buf[:cpy]",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "put_file",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "def put_file(client, container, in_path, out_path, user_id, group_id, mode=None, user_name=None, follow_links=False):\n    \"\"\"Transfer a file from local to Docker container.\"\"\"\n    if not os.path.exists(to_bytes(in_path, errors='surrogate_or_strict')):\n        raise DockerFileNotFound(\n            \"file or module does not exist: %s\" % to_native(in_path))\n    b_in_path = to_bytes(in_path, errors='surrogate_or_strict')\n    out_dir, out_file = os.path.split(out_path)\n    if follow_links:\n        file_stat = os.stat(b_in_path)\n    else:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "put_file_content",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "def put_file_content(client, container, content, out_path, user_id, group_id, mode, user_name=None):\n    \"\"\"Transfer a file from local to Docker container.\"\"\"\n    out_dir, out_file = os.path.split(out_path)\n    stream = _regular_content_tar_generator(content, out_file, user_id, group_id, mode, user_name=user_name)\n    ok = _put_archive(client, container, out_dir, stream)\n    if not ok:\n        raise DockerUnexpectedError('Unknown error while creating file \"{0}\" in container \"{1}\".'.format(out_path, container))\ndef stat_file(client, container, in_path, follow_links=False, log=None):\n    \"\"\"Fetch information on a file from a Docker container to local.\n    Return a tuple ``(path, stat_data, link_target)`` where:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "stat_file",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "def stat_file(client, container, in_path, follow_links=False, log=None):\n    \"\"\"Fetch information on a file from a Docker container to local.\n    Return a tuple ``(path, stat_data, link_target)`` where:\n    :path: is the resolved path in case ``follow_links=True``;\n    :stat_data: is ``None`` if the file does not exist, or a dictionary with fields\n        ``name`` (string), ``size`` (integer), ``mode`` (integer, see https://pkg.go.dev/io/fs#FileMode),\n        ``mtime`` (string), and ``linkTarget`` (string);\n    :link_target: is ``None`` if the file is not a symlink or when ``follow_links=False``,\n        and a string with the symlink target otherwise.\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "fetch_file_ex",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "def fetch_file_ex(client, container, in_path, process_none, process_regular, process_symlink, process_other, follow_links=False, log=None):\n    \"\"\"Fetch a file (as a tar file entry) from a Docker container to local.\"\"\"\n    considered_in_paths = set()\n    while True:\n        if in_path in considered_in_paths:\n            raise DockerFileCopyError('Found infinite symbolic link loop when trying to fetch \"{0}\"'.format(in_path))\n        considered_in_paths.add(in_path)\n        if log:\n            log('FETCH: Fetching \"%s\"' % in_path)\n        try:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "fetch_file",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "def fetch_file(client, container, in_path, out_path, follow_links=False, log=None):\n    b_out_path = to_bytes(out_path, errors='surrogate_or_strict')\n    def process_none(in_path):\n        raise DockerFileNotFound(\n            'File {in_path} does not exist in container {container}'\n            .format(in_path=in_path, container=container)\n        )\n    def process_regular(in_path, tar, member):\n        if not follow_links and os.path.exists(b_out_path):\n            os.unlink(b_out_path)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "determine_user_group",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "def determine_user_group(client, container, log=None):\n    dummy, stdout, stderr = _execute_command(client, container, ['/bin/sh', '-c', 'id -u && id -g'], check_rc=True, log=log)\n    stdout_lines = stdout.splitlines()\n    if len(stdout_lines) != 2:\n        raise DockerUnexpectedError(\n            'Expected two-line output to obtain user and group ID for container {container}, but got {lc} lines:\\n{stdout}'\n            .format(container=container, lc=len(stdout_lines), stdout=stdout)\n        )\n    user_id, group_id = stdout_lines\n    try:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "peekOfCode": "__metaclass__ = type\nimport base64\nimport datetime\nimport io\nimport json\nimport os\nimport os.path\nimport shutil\nimport stat\nimport tarfile",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.copy",
        "documentation": {}
    },
    {
        "label": "ImageArchiveManifestSummary",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "peekOfCode": "class ImageArchiveManifestSummary(object):\n    '''\n    Represents data extracted from a manifest.json found in the tar archive output of the\n    \"docker image save some:tag > some.tar\" command.\n    '''\n    def __init__(self, image_id, repo_tags):\n        '''\n        :param image_id:  File name portion of Config entry, e.g. abcde12345 from abcde12345.json\n        :type image_id: str\n        :param repo_tags  Docker image names, e.g. [\"hello-world:latest\"]",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "ImageArchiveInvalidException",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "peekOfCode": "class ImageArchiveInvalidException(Exception):\n    def __init__(self, message, cause):\n        '''\n        :param message: Exception message\n        :type message: str\n        :param cause: Inner exception that this exception wraps\n        :type cause: Exception | None\n        '''\n        super(ImageArchiveInvalidException, self).__init__(message)\n        # Python 2 doesn't support causes",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "api_image_id",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "peekOfCode": "def api_image_id(archive_image_id):\n    '''\n    Accepts an image hash in the format stored in manifest.json, and returns an equivalent identifier\n    that represents the same image hash, but in the format presented by the Docker Engine API.\n    :param archive_image_id: plain image hash\n    :type archive_image_id: str\n    :returns: Prefixed hash used by REST api\n    :rtype: str\n    '''\n    return 'sha256:%s' % archive_image_id",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "load_archived_image_manifest",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "peekOfCode": "def load_archived_image_manifest(archive_path):\n    '''\n    Attempts to get image IDs and image names from metadata stored in the image\n    archive tar file.\n    The tar should contain a file \"manifest.json\" with an array with one or more entries,\n    and every entry should have a Config field with the image ID in its file name, as\n    well as a RepoTags list, which typically has only one entry.\n    :raises:\n        ImageArchiveInvalidException: A file already exists at archive_path, but could not extract an image ID from it.\n    :param archive_path: Tar file to read",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "archived_image_manifest",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "peekOfCode": "def archived_image_manifest(archive_path):\n    '''\n    Attempts to get Image.Id and image name from metadata stored in the image\n    archive tar file.\n    The tar should contain a file \"manifest.json\" with an array with a single entry,\n    and the entry should have a Config field with the image ID in its file name, as\n    well as a RepoTags list, which typically has only one entry.\n    :raises:\n        ImageArchiveInvalidException: A file already exists at archive_path, but could not extract an image ID from it.\n    :param archive_path: Tar file to read",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport os\nimport tarfile\nfrom ansible.module_utils.common.text.converters import to_native\nclass ImageArchiveManifestSummary(object):\n    '''\n    Represents data extracted from a manifest.json found in the tar archive output of the\n    \"docker image save some:tag > some.tar\" command.\n    '''",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.image_archive",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.selectors",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.selectors",
        "peekOfCode": "__metaclass__ = type\n# Once we drop support for ansible-core 2.16, we can remove the try/except.\nfrom sys import version_info as _python_version_info\nif _python_version_info < (3, 4):\n    from ansible.module_utils.compat import selectors  # noqa: F401, pylint: disable=unused-import\nelse:\n    import selectors  # noqa: F401, pylint: disable=unused-import",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.selectors",
        "documentation": {}
    },
    {
        "label": "DockerSocketHandlerBase",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "peekOfCode": "class DockerSocketHandlerBase(object):\n    def __init__(self, sock, selectors, log=None):\n        make_unblocking(sock)\n        self._selectors = selectors\n        if log is not None:\n            self._log = log\n        else:\n            self._log = lambda msg: True\n        self._paramiko_read_workaround = hasattr(sock, 'send_ready') and 'paramiko' in str(type(sock))\n        self._sock = sock",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "DockerSocketHandlerModule",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "peekOfCode": "class DockerSocketHandlerModule(DockerSocketHandlerBase):\n    def __init__(self, sock, module, selectors):\n        super(DockerSocketHandlerModule, self).__init__(sock, selectors, module.debug)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport os.path\nimport socket as pysocket\nimport struct\nfrom ansible.module_utils.six import PY2\nfrom ansible_collections.community.docker.plugins.module_utils._api.utils import socket as docker_socket\nfrom ansible_collections.community.docker.plugins.module_utils.socket_helper import (\n    make_unblocking,\n    shutdown_writing,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "PARAMIKO_POLL_TIMEOUT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "peekOfCode": "PARAMIKO_POLL_TIMEOUT = 0.01  # 10 milliseconds\nclass DockerSocketHandlerBase(object):\n    def __init__(self, sock, selectors, log=None):\n        make_unblocking(sock)\n        self._selectors = selectors\n        if log is not None:\n            self._log = log\n        else:\n            self._log = lambda msg: True\n        self._paramiko_read_workaround = hasattr(sock, 'send_ready') and 'paramiko' in str(type(sock))",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "make_file_unblocking",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "peekOfCode": "def make_file_unblocking(file):\n    fcntl.fcntl(file.fileno(), fcntl.F_SETFL, fcntl.fcntl(file.fileno(), fcntl.F_GETFL) | os.O_NONBLOCK)\ndef make_file_blocking(file):\n    fcntl.fcntl(file.fileno(), fcntl.F_SETFL, fcntl.fcntl(file.fileno(), fcntl.F_GETFL) & ~os.O_NONBLOCK)\ndef make_unblocking(sock):\n    if hasattr(sock, '_sock'):\n        sock._sock.setblocking(0)\n    elif hasattr(sock, 'setblocking'):\n        sock.setblocking(0)\n    else:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "make_file_blocking",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "peekOfCode": "def make_file_blocking(file):\n    fcntl.fcntl(file.fileno(), fcntl.F_SETFL, fcntl.fcntl(file.fileno(), fcntl.F_GETFL) & ~os.O_NONBLOCK)\ndef make_unblocking(sock):\n    if hasattr(sock, '_sock'):\n        sock._sock.setblocking(0)\n    elif hasattr(sock, 'setblocking'):\n        sock.setblocking(0)\n    else:\n        make_file_unblocking(sock)\ndef _empty_writer(msg):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "make_unblocking",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "peekOfCode": "def make_unblocking(sock):\n    if hasattr(sock, '_sock'):\n        sock._sock.setblocking(0)\n    elif hasattr(sock, 'setblocking'):\n        sock.setblocking(0)\n    else:\n        make_file_unblocking(sock)\ndef _empty_writer(msg):\n    pass\ndef shutdown_writing(sock, log=_empty_writer):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "shutdown_writing",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "peekOfCode": "def shutdown_writing(sock, log=_empty_writer):\n    # FIXME: This does **not work with SSLSocket**! Apparently SSLSocket does not allow to send\n    #        a close_notify TLS alert without completely shutting down the connection.\n    #        Calling sock.shutdown(pysocket.SHUT_WR) simply turns of TLS encryption and from that\n    #        point on the raw encrypted data is returned when sock.recv() is called. :-(\n    if hasattr(sock, 'shutdown_write'):\n        sock.shutdown_write()\n    elif hasattr(sock, 'shutdown'):\n        try:\n            sock.shutdown(pysocket.SHUT_WR)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "write_to_socket",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "peekOfCode": "def write_to_socket(sock, data):\n    if hasattr(sock, '_send_until_done'):\n        # WrappedSocket (urllib3/contrib/pyopenssl) doesn't have `send`, but\n        # only `sendall`, which uses `_send_until_done` under the hood.\n        return sock._send_until_done(data)\n    elif hasattr(sock, 'send'):\n        return sock.send(data)\n    else:\n        return os.write(sock.fileno(), data)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "peekOfCode": "__metaclass__ = type\nimport fcntl\nimport os\nimport os.path\nimport socket as pysocket\nfrom ansible.module_utils.six import PY2\ndef make_file_unblocking(file):\n    fcntl.fcntl(file.fileno(), fcntl.F_SETFL, fcntl.fcntl(file.fileno(), fcntl.F_GETFL) | os.O_NONBLOCK)\ndef make_file_blocking(file):\n    fcntl.fcntl(file.fileno(), fcntl.F_SETFL, fcntl.fcntl(file.fileno(), fcntl.F_GETFL) & ~os.O_NONBLOCK)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.socket_helper",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerSwarmClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.swarm",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.swarm",
        "peekOfCode": "class AnsibleDockerSwarmClient(AnsibleDockerClient):\n    def __init__(self, **kwargs):\n        super(AnsibleDockerSwarmClient, self).__init__(**kwargs)\n    def get_swarm_node_id(self):\n        \"\"\"\n        Get the 'NodeID' of the Swarm node or 'None' if host is not in Swarm. It returns the NodeID\n        of Docker host the module is executed on\n        :return:\n            NodeID of host or 'None' if not part of Swarm\n        \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.swarm",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.swarm",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.swarm",
        "peekOfCode": "__metaclass__ = type\nimport json\nfrom time import sleep\ntry:\n    from docker.errors import APIError, NotFound\nexcept ImportError:\n    # missing Docker SDK for Python handled in ansible.module_utils.docker.common\n    pass\nfrom ansible.module_utils.common.text.converters import to_native\nfrom ansible_collections.community.docker.plugins.module_utils.version import LooseVersion",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.swarm",
        "documentation": {}
    },
    {
        "label": "DockerBaseClass",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "class DockerBaseClass(object):\n    def __init__(self):\n        self.debug = False\n    def log(self, msg, pretty_print=False):\n        pass\n        # if self.debug:\n        #     log_debug(msg, pretty_print=pretty_print)\ndef update_tls_hostname(result, old_behavior=False, deprecate_function=None, uses_tls=True):\n    if result['tls_hostname'] is None:\n        # get default machine name from the url",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DifferenceTracker",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "class DifferenceTracker(object):\n    def __init__(self):\n        self._diff = []\n    def add(self, name, parameter=None, active=None):\n        self._diff.append(dict(\n            name=name,\n            parameter=parameter,\n            active=active,\n        ))\n    def merge(self, other_tracker):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_image_name_id",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def is_image_name_id(name):\n    \"\"\"Check whether the given image name is in fact an image ID (hash).\"\"\"\n    if re.match('^sha256:[0-9a-fA-F]{64}$', name):\n        return True\n    return False\ndef is_valid_tag(tag, allow_empty=False):\n    \"\"\"Check whether the given string is a valid docker tag name.\"\"\"\n    if not tag:\n        return allow_empty\n    # See here (\"Extended description\") for a definition what tags can be:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "is_valid_tag",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def is_valid_tag(tag, allow_empty=False):\n    \"\"\"Check whether the given string is a valid docker tag name.\"\"\"\n    if not tag:\n        return allow_empty\n    # See here (\"Extended description\") for a definition what tags can be:\n    # https://docs.docker.com/engine/reference/commandline/tag/\n    return bool(re.match('^[a-zA-Z0-9_][a-zA-Z0-9_.-]{0,127}$', tag))\ndef sanitize_result(data):\n    \"\"\"Sanitize data object for return to Ansible.\n    When the data object contains types such as docker.types.containers.HostConfig,",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "sanitize_result",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def sanitize_result(data):\n    \"\"\"Sanitize data object for return to Ansible.\n    When the data object contains types such as docker.types.containers.HostConfig,\n    Ansible will fail when these are returned via exit_json or fail_json.\n    HostConfig is derived from dict, but its constructor requires additional\n    arguments. This function sanitizes data structures by recursively converting\n    everything derived from dict to dict and everything derived from list (and tuple)\n    to a list.\n    \"\"\"\n    if isinstance(data, dict):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "log_debug",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def log_debug(msg, pretty_print=False):\n    \"\"\"Write a log message to docker.log.\n    If ``pretty_print=True``, the message will be pretty-printed as JSON.\n    \"\"\"\n    with open('docker.log', 'a') as log_file:\n        if pretty_print:\n            log_file.write(json.dumps(msg, sort_keys=True, indent=4, separators=(',', ': ')))\n            log_file.write(u'\\n')\n        else:\n            log_file.write(msg + u'\\n')",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "update_tls_hostname",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def update_tls_hostname(result, old_behavior=False, deprecate_function=None, uses_tls=True):\n    if result['tls_hostname'] is None:\n        # get default machine name from the url\n        parsed_url = urlparse(result['docker_host'])\n        result['tls_hostname'] = parsed_url.netloc.rsplit(':', 1)[0]\ndef compare_dict_allow_more_present(av, bv):\n    '''\n    Compare two dictionaries for whether every entry of the first is in the second.\n    '''\n    for key, value in av.items():",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_dict_allow_more_present",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def compare_dict_allow_more_present(av, bv):\n    '''\n    Compare two dictionaries for whether every entry of the first is in the second.\n    '''\n    for key, value in av.items():\n        if key not in bv:\n            return False\n        if bv[key] != value:\n            return False\n    return True",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "compare_generic",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def compare_generic(a, b, method, datatype):\n    '''\n    Compare values a and b as described by method and datatype.\n    Returns ``True`` if the values compare equal, and ``False`` if not.\n    ``a`` is usually the module's parameter, while ``b`` is a property\n    of the current object. ``a`` must not be ``None`` (except for\n    ``datatype == 'value'``).\n    Valid values for ``method`` are:\n    - ``ignore`` (always compare as equal);\n    - ``strict`` (only compare if really equal)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "clean_dict_booleans_for_docker_api",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def clean_dict_booleans_for_docker_api(data, allow_sequences=False):\n    '''\n    Go doesn't like Python booleans 'True' or 'False', while Ansible is just\n    fine with them in YAML. As such, they need to be converted in cases where\n    we pass dictionaries to the Docker API (e.g. docker_network's\n    driver_options and docker_prune's filters). When `allow_sequences=True`\n    YAML sequences (lists, tuples) are converted to [str] instead of str([...])\n    which is the expected format of filters which accept lists such as labels.\n    '''\n    def sanitize(value):",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "convert_duration_to_nanosecond",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def convert_duration_to_nanosecond(time_str):\n    \"\"\"\n    Return time duration in nanosecond.\n    \"\"\"\n    if not isinstance(time_str, str):\n        raise ValueError('Missing unit in duration - %s' % time_str)\n    regex = re.compile(\n        r'^(((?P<hours>\\d+)h)?'\n        r'((?P<minutes>\\d+)m(?!s))?'\n        r'((?P<seconds>\\d+)s)?'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "normalize_healthcheck_test",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def normalize_healthcheck_test(test):\n    if isinstance(test, (tuple, list)):\n        return [str(e) for e in test]\n    return ['CMD-SHELL', str(test)]\ndef normalize_healthcheck(healthcheck, normalize_test=False):\n    \"\"\"\n    Return dictionary of healthcheck parameters.\n    \"\"\"\n    result = dict()\n    # All supported healthcheck parameters",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "normalize_healthcheck",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def normalize_healthcheck(healthcheck, normalize_test=False):\n    \"\"\"\n    Return dictionary of healthcheck parameters.\n    \"\"\"\n    result = dict()\n    # All supported healthcheck parameters\n    options = ('test', 'test_cli_compatible', 'interval', 'timeout', 'start_period', 'start_interval', 'retries')\n    duration_options = ('interval', 'timeout', 'start_period', 'start_interval')\n    for key in options:\n        if key in healthcheck:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "parse_healthcheck",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def parse_healthcheck(healthcheck):\n    \"\"\"\n    Return dictionary of healthcheck parameters and boolean if\n    healthcheck defined in image was requested to be disabled.\n    \"\"\"\n    if (not healthcheck) or (not healthcheck.get('test')):\n        return None, None\n    result = normalize_healthcheck(healthcheck, normalize_test=True)\n    if result['test'] == ['NONE']:\n        # If the user explicitly disables the healthcheck, return None",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "omit_none_from_dict",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "def omit_none_from_dict(d):\n    \"\"\"\n    Return a copy of the dictionary with all keys with value None omitted.\n    \"\"\"\n    return dict((k, v) for (k, v) in d.items() if v is not None)",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport re\nfrom datetime import timedelta\nfrom ansible.module_utils.basic import env_fallback\nfrom ansible.module_utils.common.collections import is_sequence\nfrom ansible.module_utils.six.moves.urllib.parse import urlparse\nDEFAULT_DOCKER_HOST = 'unix:///var/run/docker.sock'\nDEFAULT_TLS = False\nDEFAULT_TLS_VERIFY = False",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_HOST",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DEFAULT_DOCKER_HOST = 'unix:///var/run/docker.sock'\nDEFAULT_TLS = False\nDEFAULT_TLS_VERIFY = False\nDEFAULT_TLS_HOSTNAME = 'localhost'  # deprecated\nDEFAULT_TIMEOUT_SECONDS = 60\nDOCKER_COMMON_ARGS = dict(\n    docker_host=dict(type='str', default=DEFAULT_DOCKER_HOST, fallback=(env_fallback, ['DOCKER_HOST']), aliases=['docker_url']),\n    tls_hostname=dict(type='str', fallback=(env_fallback, ['DOCKER_TLS_HOSTNAME'])),\n    api_version=dict(type='str', default='auto', fallback=(env_fallback, ['DOCKER_API_VERSION']), aliases=['docker_api_version']),\n    timeout=dict(type='int', default=DEFAULT_TIMEOUT_SECONDS, fallback=(env_fallback, ['DOCKER_TIMEOUT'])),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DEFAULT_TLS = False\nDEFAULT_TLS_VERIFY = False\nDEFAULT_TLS_HOSTNAME = 'localhost'  # deprecated\nDEFAULT_TIMEOUT_SECONDS = 60\nDOCKER_COMMON_ARGS = dict(\n    docker_host=dict(type='str', default=DEFAULT_DOCKER_HOST, fallback=(env_fallback, ['DOCKER_HOST']), aliases=['docker_url']),\n    tls_hostname=dict(type='str', fallback=(env_fallback, ['DOCKER_TLS_HOSTNAME'])),\n    api_version=dict(type='str', default='auto', fallback=(env_fallback, ['DOCKER_API_VERSION']), aliases=['docker_api_version']),\n    timeout=dict(type='int', default=DEFAULT_TIMEOUT_SECONDS, fallback=(env_fallback, ['DOCKER_TIMEOUT'])),\n    ca_path=dict(type='path', aliases=['ca_cert', 'tls_ca_cert', 'cacert_path']),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS_VERIFY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DEFAULT_TLS_VERIFY = False\nDEFAULT_TLS_HOSTNAME = 'localhost'  # deprecated\nDEFAULT_TIMEOUT_SECONDS = 60\nDOCKER_COMMON_ARGS = dict(\n    docker_host=dict(type='str', default=DEFAULT_DOCKER_HOST, fallback=(env_fallback, ['DOCKER_HOST']), aliases=['docker_url']),\n    tls_hostname=dict(type='str', fallback=(env_fallback, ['DOCKER_TLS_HOSTNAME'])),\n    api_version=dict(type='str', default='auto', fallback=(env_fallback, ['DOCKER_API_VERSION']), aliases=['docker_api_version']),\n    timeout=dict(type='int', default=DEFAULT_TIMEOUT_SECONDS, fallback=(env_fallback, ['DOCKER_TIMEOUT'])),\n    ca_path=dict(type='path', aliases=['ca_cert', 'tls_ca_cert', 'cacert_path']),\n    client_cert=dict(type='path', aliases=['tls_client_cert', 'cert_path']),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TLS_HOSTNAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DEFAULT_TLS_HOSTNAME = 'localhost'  # deprecated\nDEFAULT_TIMEOUT_SECONDS = 60\nDOCKER_COMMON_ARGS = dict(\n    docker_host=dict(type='str', default=DEFAULT_DOCKER_HOST, fallback=(env_fallback, ['DOCKER_HOST']), aliases=['docker_url']),\n    tls_hostname=dict(type='str', fallback=(env_fallback, ['DOCKER_TLS_HOSTNAME'])),\n    api_version=dict(type='str', default='auto', fallback=(env_fallback, ['DOCKER_API_VERSION']), aliases=['docker_api_version']),\n    timeout=dict(type='int', default=DEFAULT_TIMEOUT_SECONDS, fallback=(env_fallback, ['DOCKER_TIMEOUT'])),\n    ca_path=dict(type='path', aliases=['ca_cert', 'tls_ca_cert', 'cacert_path']),\n    client_cert=dict(type='path', aliases=['tls_client_cert', 'cert_path']),\n    client_key=dict(type='path', aliases=['tls_client_key', 'key_path']),",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUT_SECONDS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DEFAULT_TIMEOUT_SECONDS = 60\nDOCKER_COMMON_ARGS = dict(\n    docker_host=dict(type='str', default=DEFAULT_DOCKER_HOST, fallback=(env_fallback, ['DOCKER_HOST']), aliases=['docker_url']),\n    tls_hostname=dict(type='str', fallback=(env_fallback, ['DOCKER_TLS_HOSTNAME'])),\n    api_version=dict(type='str', default='auto', fallback=(env_fallback, ['DOCKER_API_VERSION']), aliases=['docker_api_version']),\n    timeout=dict(type='int', default=DEFAULT_TIMEOUT_SECONDS, fallback=(env_fallback, ['DOCKER_TIMEOUT'])),\n    ca_path=dict(type='path', aliases=['ca_cert', 'tls_ca_cert', 'cacert_path']),\n    client_cert=dict(type='path', aliases=['tls_client_cert', 'cert_path']),\n    client_key=dict(type='path', aliases=['tls_client_key', 'key_path']),\n    ssl_version=dict(",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DOCKER_COMMON_ARGS = dict(\n    docker_host=dict(type='str', default=DEFAULT_DOCKER_HOST, fallback=(env_fallback, ['DOCKER_HOST']), aliases=['docker_url']),\n    tls_hostname=dict(type='str', fallback=(env_fallback, ['DOCKER_TLS_HOSTNAME'])),\n    api_version=dict(type='str', default='auto', fallback=(env_fallback, ['DOCKER_API_VERSION']), aliases=['docker_api_version']),\n    timeout=dict(type='int', default=DEFAULT_TIMEOUT_SECONDS, fallback=(env_fallback, ['DOCKER_TIMEOUT'])),\n    ca_path=dict(type='path', aliases=['ca_cert', 'tls_ca_cert', 'cacert_path']),\n    client_cert=dict(type='path', aliases=['tls_client_cert', 'cert_path']),\n    client_key=dict(type='path', aliases=['tls_client_key', 'key_path']),\n    ssl_version=dict(\n        type='str',",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_COMMON_ARGS_VARS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DOCKER_COMMON_ARGS_VARS = dict([\n    [option_name, 'ansible_docker_%s' % option_name]\n    for option_name in DOCKER_COMMON_ARGS\n    if option_name != 'debug'\n])\nDOCKER_MUTUALLY_EXCLUSIVE = []\nDOCKER_REQUIRED_TOGETHER = [\n    ['client_cert', 'client_key']\n]\nDEFAULT_DOCKER_REGISTRY = 'https://index.docker.io/v1/'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_MUTUALLY_EXCLUSIVE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DOCKER_MUTUALLY_EXCLUSIVE = []\nDOCKER_REQUIRED_TOGETHER = [\n    ['client_cert', 'client_key']\n]\nDEFAULT_DOCKER_REGISTRY = 'https://index.docker.io/v1/'\nBYTE_SUFFIXES = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']\ndef is_image_name_id(name):\n    \"\"\"Check whether the given image name is in fact an image ID (hash).\"\"\"\n    if re.match('^sha256:[0-9a-fA-F]{64}$', name):\n        return True",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DOCKER_REQUIRED_TOGETHER",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DOCKER_REQUIRED_TOGETHER = [\n    ['client_cert', 'client_key']\n]\nDEFAULT_DOCKER_REGISTRY = 'https://index.docker.io/v1/'\nBYTE_SUFFIXES = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']\ndef is_image_name_id(name):\n    \"\"\"Check whether the given image name is in fact an image ID (hash).\"\"\"\n    if re.match('^sha256:[0-9a-fA-F]{64}$', name):\n        return True\n    return False",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "DEFAULT_DOCKER_REGISTRY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "DEFAULT_DOCKER_REGISTRY = 'https://index.docker.io/v1/'\nBYTE_SUFFIXES = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']\ndef is_image_name_id(name):\n    \"\"\"Check whether the given image name is in fact an image ID (hash).\"\"\"\n    if re.match('^sha256:[0-9a-fA-F]{64}$', name):\n        return True\n    return False\ndef is_valid_tag(tag, allow_empty=False):\n    \"\"\"Check whether the given string is a valid docker tag name.\"\"\"\n    if not tag:",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "BYTE_SUFFIXES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "peekOfCode": "BYTE_SUFFIXES = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']\ndef is_image_name_id(name):\n    \"\"\"Check whether the given image name is in fact an image ID (hash).\"\"\"\n    if re.match('^sha256:[0-9a-fA-F]{64}$', name):\n        return True\n    return False\ndef is_valid_tag(tag, allow_empty=False):\n    \"\"\"Check whether the given string is a valid docker tag name.\"\"\"\n    if not tag:\n        return allow_empty",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.util",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.module_utils.version",
        "description": "collections.ansible_collections.community.docker.plugins.module_utils.version",
        "peekOfCode": "__metaclass__ = type\n# Once we drop support for ansible-core 2.11, we can remove the try/except.\nfrom ansible.module_utils.six import raise_from\ntry:\n    from ansible.module_utils.compat.version import LooseVersion, StrictVersion  # noqa: F401, pylint: disable=unused-import\nexcept ImportError:\n    try:\n        from distutils.version import LooseVersion, StrictVersion  # noqa: F401, pylint: disable=unused-import\n    except ImportError as exc:\n        msg = 'To use this plugin or module with ansible-core 2.11, you need to use Python < 3.12 with distutils.version present'",
        "detail": "collections.ansible_collections.community.docker.plugins.module_utils.version",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "description": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "peekOfCode": "def main():\n    module = AnsibleModule(dict(), supports_check_mode=True)\n    cpuset_path = '/proc/self/cpuset'\n    mountinfo_path = '/proc/self/mountinfo'\n    container_id = ''\n    container_type = ''\n    contents = None\n    if os.path.exists(cpuset_path):\n        # File content varies based on the environment:\n        #   No Container: /",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "description": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = r'''\n---\nmodule: current_container_facts\nshort_description: Return facts about whether the module runs in a container\nversion_added: 1.1.0\ndescription:\n  - Return facts about whether the module runs in a Docker or podman container.\n  - This module attempts a best-effort detection. There might be special cases where\n    it does not work; if you encounter one, L(please file an issue,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "description": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "peekOfCode": "DOCUMENTATION = r'''\n---\nmodule: current_container_facts\nshort_description: Return facts about whether the module runs in a container\nversion_added: 1.1.0\ndescription:\n  - Return facts about whether the module runs in a Docker or podman container.\n  - This module attempts a best-effort detection. There might be special cases where\n    it does not work; if you encounter one, L(please file an issue,\n    https://github.com/ansible-collections/community.docker/issues/new?assignees=&labels=&template=bug_report.md).",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "description": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "peekOfCode": "EXAMPLES = '''\n- name: Get facts on current container\n  community.docker.current_container_facts:\n- name: Print information on current container when running in a container\n  ansible.builtin.debug:\n    msg: \"Container ID is {{ ansible_module_container_id }}\"\n  when: ansible_module_running_in_container\n'''\nRETURN = r'''\nansible_facts:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "description": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "peekOfCode": "RETURN = r'''\nansible_facts:\n    description: Ansible facts returned by the module\n    type: dict\n    returned: always\n    contains:\n        ansible_module_running_in_container:\n            description:\n              - Whether the module was able to detect that it runs in a container or not.\n            returned: always",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.current_container_facts",
        "documentation": {}
    },
    {
        "label": "ContainerManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "class ContainerManager(DockerBaseClass):\n    def __init__(self, client):\n        super(ContainerManager, self).__init__()\n        self.client = client\n        self.project_src = None\n        self.files = None\n        self.project_name = None\n        self.state = None\n        self.definition = None\n        self.hostname_check = None",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "stdout_redirector",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def stdout_redirector(path_name):\n    old_stdout = sys.stdout\n    fd = open(path_name, 'w')\n    sys.stdout = fd\n    try:\n        yield\n    finally:\n        sys.stdout = old_stdout\n@contextmanager\ndef stderr_redirector(path_name):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "stderr_redirector",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def stderr_redirector(path_name):\n    old_fh = sys.stderr\n    fd = open(path_name, 'w')\n    sys.stderr = fd\n    try:\n        yield\n    finally:\n        sys.stderr = old_fh\ndef make_redirection_tempfiles():\n    dummy, out_redir_name = tempfile.mkstemp(prefix=\"ansible\")",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "make_redirection_tempfiles",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def make_redirection_tempfiles():\n    dummy, out_redir_name = tempfile.mkstemp(prefix=\"ansible\")\n    dummy, err_redir_name = tempfile.mkstemp(prefix=\"ansible\")\n    return (out_redir_name, err_redir_name)\ndef cleanup_redirection_tempfiles(out_name, err_name):\n    for i in [out_name, err_name]:\n        os.remove(i)\ndef get_redirected_output(path_name):\n    output = []\n    with open(path_name, 'r') as fd:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "cleanup_redirection_tempfiles",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def cleanup_redirection_tempfiles(out_name, err_name):\n    for i in [out_name, err_name]:\n        os.remove(i)\ndef get_redirected_output(path_name):\n    output = []\n    with open(path_name, 'r') as fd:\n        for line in fd:\n            # strip terminal format/color chars\n            new_line = re.sub(r'\\x1b\\[.+m', '', line)\n            output.append(new_line)",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "get_redirected_output",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def get_redirected_output(path_name):\n    output = []\n    with open(path_name, 'r') as fd:\n        for line in fd:\n            # strip terminal format/color chars\n            new_line = re.sub(r'\\x1b\\[.+m', '', line)\n            output.append(new_line)\n    os.remove(path_name)\n    return output\ndef attempt_extract_errors(exc_str, stdout, stderr):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "attempt_extract_errors",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def attempt_extract_errors(exc_str, stdout, stderr):\n    errors = [l.strip() for l in stderr if l.strip().startswith('ERROR:')]\n    errors.extend([l.strip() for l in stdout if l.strip().startswith('ERROR:')])\n    warnings = [l.strip() for l in stderr if l.strip().startswith('WARNING:')]\n    warnings.extend([l.strip() for l in stdout if l.strip().startswith('WARNING:')])\n    # assume either the exception body (if present) or the last warning was the 'most'\n    # fatal.\n    if exc_str.strip():\n        msg = exc_str.strip()\n    elif errors:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "get_failure_info",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def get_failure_info(exc, out_name, err_name=None, msg_format='%s'):\n    if err_name is None:\n        stderr = []\n    else:\n        stderr = get_redirected_output(err_name)\n    stdout = get_redirected_output(out_name)\n    reason = attempt_extract_errors(str(exc), stdout, stderr)\n    reason['msg'] = msg_format % reason['msg']\n    return reason\nclass ContainerManager(DockerBaseClass):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        project_src=dict(type='path'),\n        project_name=dict(type='str',),\n        env_file=dict(type='path'),\n        files=dict(type='list', elements='path'),\n        profiles=dict(type='list', elements='str'),\n        state=dict(type='str', default='present', choices=['absent', 'present']),\n        definition=dict(type='dict'),\n        hostname_check=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nmodule: docker_compose\nshort_description: Manage multi-container Docker applications with Docker Compose V1\ndeprecated:\n  removed_in: 4.0.0\n  why: This module uses docker-compose v1, which is End of Life since July 2022.\n  alternative: Migrate to M(community.docker.docker_compose_v2)\nauthor: \"Chris Houseknecht (@chouseknecht)\"\ndescription:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "DOCUMENTATION = '''\nmodule: docker_compose\nshort_description: Manage multi-container Docker applications with Docker Compose V1\ndeprecated:\n  removed_in: 4.0.0\n  why: This module uses docker-compose v1, which is End of Life since July 2022.\n  alternative: Migrate to M(community.docker.docker_compose_v2)\nauthor: \"Chris Houseknecht (@chouseknecht)\"\ndescription:\n  - Uses Docker Compose to start, shutdown and scale services. B(This module requires docker-compose < 2.0.0.)",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "EXAMPLES = '''\n# Examples use the django example at https://docs.docker.com/compose/django. Follow it to create the\n# flask directory\n- name: Run using a project directory\n  hosts: localhost\n  gather_facts: false\n  tasks:\n    - name: Tear down existing services\n      community.docker.docker_compose:\n        project_src: flask",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "RETURN = '''\nservices:\n  description:\n  - A dictionary mapping the service's name to a dictionary of containers.\n  returned: success\n  type: complex\n  contains:\n      container_name:\n          description: Name of the container. Format is C(project_service_#).\n          returned: success",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "AUTH_PARAM_MAPPING",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "peekOfCode": "AUTH_PARAM_MAPPING = {\n    u'docker_host': u'--host',\n    u'tls': u'--tls',\n    u'cacert_path': u'--tlscacert',\n    u'cert_path': u'--tlscert',\n    u'key_path': u'--tlskey',\n    u'tls_verify': u'--tlsverify'\n}\n@contextmanager\ndef stdout_redirector(path_name):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose",
        "documentation": {}
    },
    {
        "label": "ServicesManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "peekOfCode": "class ServicesManager(BaseComposeManager):\n    def __init__(self, client):\n        super(ServicesManager, self).__init__(client)\n        parameters = self.client.module.params\n        self.state = parameters['state']\n        self.dependencies = parameters['dependencies']\n        self.pull = parameters['pull']\n        self.build = parameters['build']\n        self.recreate = parameters['recreate']\n        self.remove_images = parameters['remove_images']",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        state=dict(type='str', default='present', choices=['absent', 'present', 'stopped', 'restarted']),\n        dependencies=dict(type='bool', default=True),\n        pull=dict(type='str', choices=['always', 'missing', 'never', 'policy'], default='policy'),\n        build=dict(type='str', choices=['always', 'never', 'policy'], default='policy'),\n        recreate=dict(type='str', default='auto', choices=['always', 'never', 'auto']),\n        remove_images=dict(type='str', choices=['all', 'local']),\n        remove_volumes=dict(type='bool', default=False),\n        remove_orphans=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nmodule: docker_compose_v2\nshort_description: Manage multi-container Docker applications with Docker Compose CLI plugin\nversion_added: 3.6.0\ndescription:\n  - Uses Docker Compose to start or shutdown services.\nextends_documentation_fragment:\n  - community.docker.compose_v2\n  - community.docker.compose_v2.minimum_version",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "peekOfCode": "DOCUMENTATION = '''\nmodule: docker_compose_v2\nshort_description: Manage multi-container Docker applications with Docker Compose CLI plugin\nversion_added: 3.6.0\ndescription:\n  - Uses Docker Compose to start or shutdown services.\nextends_documentation_fragment:\n  - community.docker.compose_v2\n  - community.docker.compose_v2.minimum_version\n  - community.docker.docker.cli_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "peekOfCode": "EXAMPLES = '''\n# Examples use the django example at https://docs.docker.com/compose/django. Follow it to create the\n# flask directory\n- name: Run using a project directory\n  hosts: localhost\n  gather_facts: false\n  tasks:\n    - name: Tear down existing services\n      community.docker.docker_compose_v2:\n        project_src: flask",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "peekOfCode": "RETURN = '''\ncontainers:\n  description:\n    - A list of containers associated to the service.\n  returned: success\n  type: list\n  elements: dict\n  contains:\n    Command:\n      description:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2",
        "documentation": {}
    },
    {
        "label": "PullManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "peekOfCode": "class PullManager(BaseComposeManager):\n    def __init__(self, client):\n        super(PullManager, self).__init__(client)\n        parameters = self.client.module.params\n        self.policy = parameters['policy']\n        if self.policy != 'always' and self.compose_version < LooseVersion('2.22.0'):\n            # https://github.com/docker/compose/pull/10981 - 2.22.0\n            self.fail('A pull policy other than always is only supported since Docker Compose 2.22.0. {0} has version {1}'.format(\n                self.client.get_cli(), self.compose_version))\n    def get_pull_cmd(self, dry_run, no_start=False):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        policy=dict(type='str', choices=['always', 'missing'], default='always'),\n    )\n    argspec_ex = common_compose_argspec_ex()\n    argument_spec.update(argspec_ex.pop('argspec'))\n    client = AnsibleModuleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n        **argspec_ex",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nmodule: docker_compose_v2_pull\nshort_description: Pull a Docker compose project\nversion_added: 3.6.0\ndescription:\n  - Uses Docker Compose to pull images for a project.\nextends_documentation_fragment:\n  - community.docker.compose_v2\n  - community.docker.compose_v2.minimum_version",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "peekOfCode": "DOCUMENTATION = '''\nmodule: docker_compose_v2_pull\nshort_description: Pull a Docker compose project\nversion_added: 3.6.0\ndescription:\n  - Uses Docker Compose to pull images for a project.\nextends_documentation_fragment:\n  - community.docker.compose_v2\n  - community.docker.compose_v2.minimum_version\n  - community.docker.docker.cli_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "peekOfCode": "EXAMPLES = '''\n- name: Pull images for flask project\n  community.docker.docker_compose_v2_pull:\n    project_src: /path/to/flask\n'''\nRETURN = '''\nactions:\n  description:\n    - A list of actions that have been applied.\n  returned: success",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "peekOfCode": "RETURN = '''\nactions:\n  description:\n    - A list of actions that have been applied.\n  returned: success\n  type: list\n  elements: dict\n  contains:\n    what:\n      description:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_compose_v2_pull",
        "documentation": {}
    },
    {
        "label": "ConfigManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "peekOfCode": "class ConfigManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(ConfigManager, self).__init__()\n        self.client = client\n        self.results = results\n        self.check_mode = self.client.check_mode\n        parameters = self.client.module.params\n        self.name = parameters.get('name')\n        self.state = parameters.get('state')\n        self.data = parameters.get('data')",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        state=dict(type='str', default='present', choices=['absent', 'present']),\n        data=dict(type='str'),\n        data_is_b64=dict(type='bool', default=False),\n        data_src=dict(type='path'),\n        labels=dict(type='dict'),\n        force=dict(type='bool', default=False),\n        rolling_versions=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_config\nshort_description: Manage docker configs.\ndescription:\n  - Create and remove Docker configs in a Swarm environment. Similar to C(docker config create) and C(docker config rm).\n  - Adds to the metadata of new configs 'ansible_key', an encrypted hash representation of the data, which is then used\n    in future runs to test if a config has changed. If 'ansible_key' is not present, then a config will not be updated\n    unless the O(force) option is set.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_config\nshort_description: Manage docker configs.\ndescription:\n  - Create and remove Docker configs in a Swarm environment. Similar to C(docker config create) and C(docker config rm).\n  - Adds to the metadata of new configs 'ansible_key', an encrypted hash representation of the data, which is then used\n    in future runs to test if a config has changed. If 'ansible_key' is not present, then a config will not be updated\n    unless the O(force) option is set.\n  - Updates to configs are performed by removing the config and creating it again.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "peekOfCode": "EXAMPLES = '''\n- name: Create config foo (from a file on the control machine)\n  community.docker.docker_config:\n    name: foo\n    # If the file is JSON or binary, Ansible might modify it (because\n    # it is first decoded and later re-encoded). Base64-encoding the\n    # file directly after reading it prevents this to happen.\n    data: \"{{ lookup('file', '/path/to/config/file') | b64encode }}\"\n    data_is_b64: true\n    state: present",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "peekOfCode": "RETURN = '''\nconfig_id:\n  description:\n    - The ID assigned by Docker to the config object.\n  returned: success and O(state=present)\n  type: str\n  sample: 'hzehrmyjigmcp2gb6nlhmjqcv'\nconfig_name:\n  description:\n    - The name of the created config object.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_config",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "peekOfCode": "def main():\n    engine_driver = DockerAPIEngineDriver()\n    run_module(engine_driver)\nif __name__ == '__main__':\n    main()",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_container\nshort_description: manage Docker containers\ndescription:\n  - Manage the life cycle of Docker containers.\n  - Supports check mode. Run with C(--check) and C(--diff) to view config difference and list of actions to be taken.\nnotes:\n  - For most config changes, the container needs to be recreated. This means that the existing container has to be destroyed and",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_container\nshort_description: manage Docker containers\ndescription:\n  - Manage the life cycle of Docker containers.\n  - Supports check mode. Run with C(--check) and C(--diff) to view config difference and list of actions to be taken.\nnotes:\n  - For most config changes, the container needs to be recreated. This means that the existing container has to be destroyed and\n    a new one created. This can cause unexpected data loss and downtime. You can use the O(comparisons) option to",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "peekOfCode": "EXAMPLES = '''\n- name: Create a data container\n  community.docker.docker_container:\n    name: mydata\n    image: busybox\n    volumes:\n      - /data\n- name: Re-create a redis container\n  community.docker.docker_container:\n    name: myredis",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "peekOfCode": "RETURN = '''\ncontainer:\n    description:\n      - Facts representing the current state of the container. Matches the docker inspection output.\n      - Empty if O(state=absent).\n      - If O(detach=false), will include C(Output) attribute containing any output from container run.\n    returned: success; or when O(state=started) and O(detach=false), and when waiting for the container result did not fail\n    type: dict\n    sample: '{\n        \"AppArmorProfile\": \"\",",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container",
        "documentation": {}
    },
    {
        "label": "are_fileobjs_equal",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def are_fileobjs_equal(f1, f2):\n    '''Given two (buffered) file objects, compare their contents.'''\n    blocksize = 65536\n    b1buf = b''\n    b2buf = b''\n    while True:\n        if f1 and len(b1buf) < blocksize:\n            f1b = f1.read(blocksize)\n            if not f1b:\n                # f1 is EOF, so stop reading from it",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "are_fileobjs_equal_read_first",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def are_fileobjs_equal_read_first(f1, f2):\n    '''Given two (buffered) file objects, compare their contents.\n    Returns a tuple (is_equal, content_of_f1), where the first element indicates\n    whether the two file objects have the same content, and the second element is\n    the content of the first file object.'''\n    blocksize = 65536\n    b1buf = b''\n    b2buf = b''\n    is_equal = True\n    content = []",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "is_container_file_not_regular_file",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def is_container_file_not_regular_file(container_stat):\n    for bit in (\n        # https://pkg.go.dev/io/fs#FileMode\n        32 - 1,  # ModeDir\n        32 - 4,  # ModeTemporary\n        32 - 5,  # ModeSymlink\n        32 - 6,  # ModeDevice\n        32 - 7,  # ModeNamedPipe\n        32 - 8,  # ModeSocket\n        32 - 11,  # ModeCharDevice",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "get_container_file_mode",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def get_container_file_mode(container_stat):\n    mode = container_stat['mode'] & 0xFFF\n    if container_stat['mode'] & (1 << (32 - 9)) != 0:  # ModeSetuid\n        mode |= stat.S_ISUID  # set UID bit\n    if container_stat['mode'] & (1 << (32 - 10)) != 0:  # ModeSetgid\n        mode |= stat.S_ISGID  # set GID bit\n    if container_stat['mode'] & (1 << (32 - 12)) != 0:  # ModeSticky\n        mode |= stat.S_ISVTX  # sticky bit\n    return mode\ndef add_other_diff(diff, in_path, member):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "add_other_diff",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def add_other_diff(diff, in_path, member):\n    if diff is None:\n        return\n    diff['before_header'] = in_path\n    if member.isdir():\n        diff['before'] = '(directory)'\n    elif member.issym() or member.islnk():\n        diff['before'] = member.linkname\n    elif member.ischr():\n        diff['before'] = '(character device)'",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "retrieve_diff",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def retrieve_diff(client, container, container_path, follow_links, diff, max_file_size_for_diff, regular_stat=None, link_target=None):\n    if diff is None:\n        return\n    if regular_stat is not None:\n        # First handle all filesystem object types that are not regular files\n        if regular_stat['mode'] & (1 << (32 - 1)) != 0:\n            diff['before_header'] = container_path\n            diff['before'] = '(directory)'\n            return\n        elif regular_stat['mode'] & (1 << (32 - 4)) != 0:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "is_binary",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def is_binary(content):\n    if b'\\x00' in content:\n        return True\n    # TODO: better detection\n    # (ansible-core also just checks for 0x00, and even just sticks to the first 8k, so this isn't too bad...)\n    return False\ndef are_fileobjs_equal_with_diff_of_first(f1, f2, size, diff, max_file_size_for_diff, container_path):\n    if diff is None:\n        return are_fileobjs_equal(f1, f2)\n    if size > max_file_size_for_diff > 0:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "are_fileobjs_equal_with_diff_of_first",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def are_fileobjs_equal_with_diff_of_first(f1, f2, size, diff, max_file_size_for_diff, container_path):\n    if diff is None:\n        return are_fileobjs_equal(f1, f2)\n    if size > max_file_size_for_diff > 0:\n        diff['dst_larger'] = max_file_size_for_diff\n        return are_fileobjs_equal(f1, f2)\n    is_equal, content = are_fileobjs_equal_read_first(f1, f2)\n    if is_binary(content):\n        diff['dst_binary'] = 1\n    else:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "add_diff_dst_from_regular_member",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def add_diff_dst_from_regular_member(diff, max_file_size_for_diff, container_path, tar, member):\n    if diff is None:\n        return\n    if member.size > max_file_size_for_diff > 0:\n        diff['dst_larger'] = max_file_size_for_diff\n        return\n    tar_f = tar.extractfile(member)  # in Python 2, this *cannot* be used in `with`...\n    content = tar_f.read()\n    if is_binary(content):\n        diff['dst_binary'] = 1",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "copy_dst_to_src",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def copy_dst_to_src(diff):\n    if diff is None:\n        return\n    for f, t in [\n        ('dst_size', 'src_size'),\n        ('dst_binary', 'src_binary'),\n        ('before_header', 'after_header'),\n        ('before', 'after'),\n    ]:\n        if f in diff:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "is_file_idempotent",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def is_file_idempotent(client, container, managed_path, container_path, follow_links, local_follow_links, owner_id, group_id, mode,\n                       force=False, diff=None, max_file_size_for_diff=1):\n    # Retrieve information of local file\n    try:\n        file_stat = os.stat(managed_path) if local_follow_links else os.lstat(managed_path)\n    except OSError as exc:\n        if exc.errno == 2:\n            raise DockerFileNotFound('Cannot find local file {managed_path}'.format(managed_path=managed_path))\n        raise\n    if mode is None:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "copy_file_into_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def copy_file_into_container(client, container, managed_path, container_path, follow_links, local_follow_links,\n                             owner_id, group_id, mode, force=False, diff=False, max_file_size_for_diff=1):\n    if diff:\n        diff = {}\n    else:\n        diff = None\n    container_path, mode, idempotent = is_file_idempotent(\n        client,\n        container,\n        managed_path,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "is_content_idempotent",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def is_content_idempotent(client, container, content, container_path, follow_links, owner_id, group_id, mode,\n                          force=False, diff=None, max_file_size_for_diff=1):\n    if diff is not None:\n        if len(content) > max_file_size_for_diff > 0:\n            diff['src_larger'] = max_file_size_for_diff\n        elif is_binary(content):\n            diff['src_binary'] = 1\n        else:\n            diff['after_header'] = 'dynamically generated'\n            diff['after'] = to_text(content)",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "copy_content_into_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def copy_content_into_container(client, container, content, container_path, follow_links,\n                                owner_id, group_id, mode, force=False, diff=False, max_file_size_for_diff=1):\n    if diff:\n        diff = {}\n    else:\n        diff = None\n    container_path, mode, idempotent = is_content_idempotent(\n        client,\n        container,\n        content,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        container=dict(type='str', required=True),\n        path=dict(type='path'),\n        container_path=dict(type='str', required=True),\n        follow=dict(type='bool', default=False),\n        local_follow=dict(type='bool', default=True),\n        owner_id=dict(type='int'),\n        group_id=dict(type='int'),\n        mode=dict(type='int'),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_container_copy_into\nshort_description: Copy a file into a Docker container\nversion_added: 3.4.0\ndescription:\n  - Copy a file into a Docker container.\n  - Similar to C(docker cp).\n  - To copy files in a non-running container, you must provide the O(owner_id) and O(group_id) options.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_container_copy_into\nshort_description: Copy a file into a Docker container\nversion_added: 3.4.0\ndescription:\n  - Copy a file into a Docker container.\n  - Similar to C(docker cp).\n  - To copy files in a non-running container, you must provide the O(owner_id) and O(group_id) options.\n    This is also necessary if the container does not contain a C(/bin/sh) shell with an C(id) tool.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "EXAMPLES = '''\n- name: Copy a file into the container\n  community.docker.docker_container_copy_into:\n    container: mydata\n    path: /home/user/data.txt\n    container_path: /data/input.txt\n- name: Copy a file into the container with owner, group, and mode set\n  community.docker.docker_container_copy_into:\n    container: mydata\n    path: /home/user/bin/runme.o",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "peekOfCode": "RETURN = '''\ncontainer_path:\n  description:\n    - The actual path in the container.\n    - Can only be different from O(container_path) when O(follow=true).\n  type: str\n  returned: success\n'''\nimport base64\nimport io",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_copy_into",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        container=dict(type='str', required=True),\n        argv=dict(type='list', elements='str'),\n        command=dict(type='str'),\n        chdir=dict(type='str'),\n        detach=dict(type='bool', default=False),\n        user=dict(type='str'),\n        stdin=dict(type='str'),\n        stdin_add_newline=dict(type='bool', default=True),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_container_exec\nshort_description: Execute command in a docker container\nversion_added: 1.5.0\ndescription:\n  - Executes a command in a Docker container.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_container_exec\nshort_description: Execute command in a docker container\nversion_added: 1.5.0\ndescription:\n  - Executes a command in a Docker container.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "peekOfCode": "EXAMPLES = '''\n- name: Run a simple command (command)\n  community.docker.docker_container_exec:\n    container: foo\n    command: /bin/bash -c \"ls -lah\"\n    chdir: /root\n  register: result\n- name: Print stdout\n  ansible.builtin.debug:\n    var: result.stdout",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "peekOfCode": "RETURN = '''\nstdout:\n    type: str\n    returned: success and O(detach=false)\n    description:\n      - The standard output of the container command.\nstderr:\n    type: str\n    returned: success and O(detach=false)\n    description:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_exec",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n    )\n    try:\n        container = client.get_container(client.module.params['name'])",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_container_info\nshort_description: Retrieves facts about docker container\ndescription:\n  - Retrieves facts about a docker container.\n  - Essentially returns the output of C(docker inspect <name>), similar to what M(community.docker.docker_container)\n    returns for a non-absent container.\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_container_info\nshort_description: Retrieves facts about docker container\ndescription:\n  - Retrieves facts about a docker container.\n  - Essentially returns the output of C(docker inspect <name>), similar to what M(community.docker.docker_container)\n    returns for a non-absent container.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Get infos on container\n  community.docker.docker_container_info:\n    name: mydata\n  register: result\n- name: Does container exist?\n  ansible.builtin.debug:\n    msg: \"The container {{ 'exists' if result.exists else 'does not exist' }}\"\n- name: Print information about container\n  ansible.builtin.debug:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "peekOfCode": "RETURN = '''\nexists:\n    description:\n      - Returns whether the container exists.\n    type: bool\n    returned: always\n    sample: true\ncontainer:\n    description:\n      - Facts representing the current state of the container. Matches the docker inspection output.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_container_info",
        "documentation": {}
    },
    {
        "label": "DockerHostManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "peekOfCode": "class DockerHostManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(DockerHostManager, self).__init__()\n        self.client = client\n        self.results = results\n        self.verbose_output = self.client.module.params['verbose_output']\n        listed_objects = ['volumes', 'networks', 'containers', 'images']\n        self.results['host_info'] = self.get_docker_host_info()\n        if self.client.module.params['disk_usage']:\n            self.results['disk_usage'] = self.get_docker_disk_usage_facts()",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        containers=dict(type='bool', default=False),\n        containers_all=dict(type='bool', default=False),\n        containers_filters=dict(type='dict'),\n        images=dict(type='bool', default=False),\n        images_filters=dict(type='dict'),\n        networks=dict(type='bool', default=False),\n        networks_filters=dict(type='dict'),\n        volumes=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_host_info\nshort_description: Retrieves facts about docker host and lists of objects of the services.\ndescription:\n  - Retrieves facts about a docker host.\n  - Essentially returns the output of C(docker system info).\n  - The module also allows to list object names for containers, images, networks and volumes.\n    It also allows to query information on disk usage.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_host_info\nshort_description: Retrieves facts about docker host and lists of objects of the services.\ndescription:\n  - Retrieves facts about a docker host.\n  - Essentially returns the output of C(docker system info).\n  - The module also allows to list object names for containers, images, networks and volumes.\n    It also allows to query information on disk usage.\n  - The output differs depending on API version of the docker daemon.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Get info on docker host\n  community.docker.docker_host_info:\n  register: result\n- name: Get info on docker host and list images\n  community.docker.docker_host_info:\n    images: true\n  register: result\n- name: Get info on docker host and list images matching the filter\n  community.docker.docker_host_info:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "peekOfCode": "RETURN = '''\ncan_talk_to_docker:\n    description:\n      - Will be V(true) if the module can talk to the docker daemon.\n    returned: both on success and on error\n    type: bool\nhost_info:\n    description:\n      - Facts representing the basic state of the docker host. Matches the C(docker system info) output.\n    returned: always",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_host_info",
        "documentation": {}
    },
    {
        "label": "ImageManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "peekOfCode": "class ImageManager(DockerBaseClass):\n    def __init__(self, client, results):\n        '''\n        Configure a docker_image task.\n        :param client: Ansible Docker Client wrapper over Docker client\n        :type client: AnsibleDockerClient\n        :param results: This task adds its output values to this dictionary\n        :type results: dict\n        '''\n        super(ImageManager, self).__init__()",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "convert_to_bytes",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "peekOfCode": "def convert_to_bytes(value, module, name, unlimited_value=None):\n    if value is None:\n        return value\n    try:\n        if unlimited_value is not None and value in ('unlimited', str(unlimited_value)):\n            return unlimited_value\n        return human_to_bytes(value)\n    except ValueError as exc:\n        module.fail_json(msg='Failed to convert %s to bytes: %s' % (name, to_native(exc)))\nclass ImageManager(DockerBaseClass):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        source=dict(type='str', choices=['build', 'load', 'pull', 'local']),\n        build=dict(type='dict', options=dict(\n            cache_from=dict(type='list', elements='str'),\n            container_limits=dict(type='dict', options=dict(\n                memory=dict(type='str'),\n                memswap=dict(type='str'),\n                cpushares=dict(type='int'),\n                cpusetcpus=dict(type='str'),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image\nshort_description: Manage docker images\ndescription:\n  - Build, load or pull an image, making the image available for creating containers. Also supports tagging\n    an image, pushing an image, and archiving an image to a C(.tar) file.\nnotes:\n  - Building images is done using Docker daemon's API. It is not possible to use BuildKit / buildx this way.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image\nshort_description: Manage docker images\ndescription:\n  - Build, load or pull an image, making the image available for creating containers. Also supports tagging\n    an image, pushing an image, and archiving an image to a C(.tar) file.\nnotes:\n  - Building images is done using Docker daemon's API. It is not possible to use BuildKit / buildx this way.\n    Use M(community.docker.docker_image_build) to build images with BuildKit.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "peekOfCode": "EXAMPLES = '''\n- name: Pull an image\n  community.docker.docker_image:\n    name: pacur/centos-7\n    source: pull\n    # Select platform for pulling. If not specified, will pull whatever docker prefers.\n    pull:\n      platform: amd64\n- name: Tag and push to docker hub\n  community.docker.docker_image:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "peekOfCode": "RETURN = '''\nimage:\n    description: Image inspection results for the affected image.\n    returned: success\n    type: dict\n    sample: {}\nstdout:\n    description: Docker build output when building an image.\n    returned: success\n    type: str",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image",
        "documentation": {}
    },
    {
        "label": "ImageBuilder",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "class ImageBuilder(DockerBaseClass):\n    def __init__(self, client):\n        super(ImageBuilder, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        parameters = self.client.module.params\n        self.cache_from = parameters['cache_from']\n        self.pull = parameters['pull']\n        self.network = parameters['network']\n        self.nocache = parameters['nocache']",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "convert_to_bytes",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "def convert_to_bytes(value, module, name, unlimited_value=None):\n    if value is None:\n        return value\n    try:\n        if unlimited_value is not None and value in ('unlimited', str(unlimited_value)):\n            return unlimited_value\n        return human_to_bytes(value)\n    except ValueError as exc:\n        module.fail_json(msg='Failed to convert %s to bytes: %s' % (name, to_native(exc)))\ndef dict_to_list(dictionary, concat='='):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "dict_to_list",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "def dict_to_list(dictionary, concat='='):\n    return ['%s%s%s' % (k, concat, v) for k, v in sorted(dictionary.items())]\nclass ImageBuilder(DockerBaseClass):\n    def __init__(self, client):\n        super(ImageBuilder, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        parameters = self.client.module.params\n        self.cache_from = parameters['cache_from']\n        self.pull = parameters['pull']",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        tag=dict(type='str', default='latest'),\n        path=dict(type='path', required=True),\n        dockerfile=dict(type='str'),\n        cache_from=dict(type='list', elements='str'),\n        pull=dict(type='bool', default=False),\n        network=dict(type='str'),\n        nocache=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_build\nshort_description: Build Docker images using Docker buildx\nversion_added: 3.6.0\ndescription:\n  - This module allows you to build Docker images using Docker's buildx plugin (BuildKit).\n  - Note that the module is B(not idempotent) in the sense of classical Ansible modules.\n    The only idempotence check is whether the built image already exists. This check can",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_build\nshort_description: Build Docker images using Docker buildx\nversion_added: 3.6.0\ndescription:\n  - This module allows you to build Docker images using Docker's buildx plugin (BuildKit).\n  - Note that the module is B(not idempotent) in the sense of classical Ansible modules.\n    The only idempotence check is whether the built image already exists. This check can\n    be disabled with the O(rebuild) option.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "EXAMPLES = '''\n- name: Build Python 3.12 image\n  community.docker.docker_image_build:\n    name: localhost/python/3.12:latest\n    path: /home/user/images/python\n    dockerfile: Dockerfile-3.12\n- name: Build multi-platform image\n  community.docker.docker_image_build:\n    name: multi-platform-image\n    tag: \"1.5.2\"",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "peekOfCode": "RETURN = '''\nimage:\n    description: Image inspection results for the affected image.\n    returned: success\n    type: dict\n    sample: {}\n'''\nimport base64\nimport os\nimport traceback",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_build",
        "documentation": {}
    },
    {
        "label": "ImageExportManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "peekOfCode": "class ImageExportManager(DockerBaseClass):\n    def __init__(self, client):\n        super(ImageExportManager, self).__init__()\n        self.client = client\n        parameters = self.client.module.params\n        self.check_mode = self.client.check_mode\n        self.path = parameters['path']\n        self.force = parameters['force']\n        self.tag = parameters['tag']\n        if not is_valid_tag(self.tag, allow_empty=True):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        path=dict(type='path'),\n        force=dict(type='bool', default=False),\n        names=dict(type='list', elements='str', required=True, aliases=['name']),\n        tag=dict(type='str', default='latest'),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_export\nshort_description: Export (archive) Docker images\nversion_added: 3.7.0\ndescription:\n  - Creates an archive (tarball) from one or more Docker images.\n  - This can be copied to another machine and loaded with M(community.docker.docker_image_load).\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_export\nshort_description: Export (archive) Docker images\nversion_added: 3.7.0\ndescription:\n  - Creates an archive (tarball) from one or more Docker images.\n  - This can be copied to another machine and loaded with M(community.docker.docker_image_load).\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "peekOfCode": "EXAMPLES = '''\n- name: Export an image\n  community.docker.docker_image_export:\n    name: pacur/centos-7\n    path: /tmp/centos-7.tar\n- name: Export multiple images\n  community.docker.docker_image_export:\n    names:\n      - hello-world:latest\n      - pacur/centos-7:latest",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "peekOfCode": "RETURN = '''\nimages:\n    description: Image inspection results for the affected images.\n    returned: success\n    type: list\n    elements: dict\n    sample: []\n'''\nimport traceback\nfrom ansible.module_utils.common.text.converters import to_native",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_export",
        "documentation": {}
    },
    {
        "label": "ImageManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "peekOfCode": "class ImageManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(ImageManager, self).__init__()\n        self.client = client\n        self.results = results\n        self.name = self.client.module.params.get('name')\n        self.log(\"Gathering facts for images: %s\" % (str(self.name)))\n        if self.name:\n            self.results['images'] = self.get_facts()\n        else:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='list', elements='str'),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n    )\n    try:\n        results = dict(",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_info\nshort_description: Inspect docker images\ndescription:\n  - Provide one or more image names, and the module will inspect each, returning an array of inspection results.\n  - If an image does not exist locally, it will not appear in the results. If you want to check whether an image exists\n    locally, you can call the module with the image name, then check whether the result list is empty (image does not\n    exist) or has one element (the image exists locally).",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_info\nshort_description: Inspect docker images\ndescription:\n  - Provide one or more image names, and the module will inspect each, returning an array of inspection results.\n  - If an image does not exist locally, it will not appear in the results. If you want to check whether an image exists\n    locally, you can call the module with the image name, then check whether the result list is empty (image does not\n    exist) or has one element (the image exists locally).\n  - The module will not attempt to pull images from registries. Use M(community.docker.docker_image) with",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Inspect a single image\n  community.docker.docker_image_info:\n    name: pacur/centos-7\n- name: Inspect multiple images\n  community.docker.docker_image_info:\n    name:\n      - pacur/centos-7\n      - sinatra\n  register: result",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "peekOfCode": "RETURN = '''\nimages:\n    description:\n      - Inspection results for the selected images.\n      - The list only contains inspection results of images existing locally.\n    returned: always\n    type: list\n    elements: dict\n    sample: [\n        {",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_info",
        "documentation": {}
    },
    {
        "label": "ImageManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "peekOfCode": "class ImageManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(ImageManager, self).__init__()\n        self.client = client\n        self.results = results\n        parameters = self.client.module.params\n        self.check_mode = self.client.check_mode\n        self.path = parameters['path']\n        self.load_images()\n    @staticmethod",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "peekOfCode": "def main():\n    client = AnsibleDockerClient(\n        argument_spec=dict(\n            path=dict(type='path', required=True),\n        ),\n        supports_check_mode=False,\n    )\n    try:\n        results = dict(\n            image_names=[],",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_load\nshort_description: Load docker image(s) from archives\nversion_added: 1.3.0\ndescription:\n  - Load one or multiple Docker images from a C(.tar) archive, and return information on\n    the loaded image(s).\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_load\nshort_description: Load docker image(s) from archives\nversion_added: 1.3.0\ndescription:\n  - Load one or multiple Docker images from a C(.tar) archive, and return information on\n    the loaded image(s).\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "peekOfCode": "EXAMPLES = '''\n- name: Load all image(s) from the given tar file\n  community.docker.docker_image_load:\n    path: /path/to/images.tar\n  register: result\n- name: Print the loaded image names\n  ansible.builtin.debug:\n    msg: \"Loaded the following images: {{ result.image_names | join(', ') }}\"\n'''\nRETURN = '''",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "peekOfCode": "RETURN = '''\nimage_names:\n    description: List of image names and IDs loaded from the archive.\n    returned: success\n    type: list\n    elements: str\n    sample:\n      - 'hello-world:latest'\n      - 'sha256:e004c2cc521c95383aebb1fb5893719aa7a8eae2e7a71f316a4410784edb00a9'\nimages:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_load",
        "documentation": {}
    },
    {
        "label": "ImagePuller",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "peekOfCode": "class ImagePuller(DockerBaseClass):\n    def __init__(self, client):\n        super(ImagePuller, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        parameters = self.client.module.params\n        self.name = parameters['name']\n        self.tag = parameters['tag']\n        self.platform = parameters['platform']\n        self.pull_mode = parameters['pull']",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "documentation": {}
    },
    {
        "label": "image_info",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "peekOfCode": "def image_info(image):\n    result = {}\n    if image:\n        result['id'] = image['Id']\n    else:\n        result['exists'] = False\n    return result\nclass ImagePuller(DockerBaseClass):\n    def __init__(self, client):\n        super(ImagePuller, self).__init__()",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        tag=dict(type='str', default='latest'),\n        platform=dict(type='str'),\n        pull=dict(type='str', choices=['always', 'not_present'], default='always'),\n    )\n    option_minimal_versions = dict(\n        platform=dict(docker_api_version='1.32'),\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_pull\nshort_description: Pull Docker images from registries\nversion_added: 3.6.0\ndescription:\n  - Pulls a Docker image from a registry.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_pull\nshort_description: Pull Docker images from registries\nversion_added: 3.6.0\ndescription:\n  - Pulls a Docker image from a registry.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "peekOfCode": "EXAMPLES = '''\n- name: Pull an image\n  community.docker.docker_image_pull:\n    name: pacur/centos-7\n    # Select platform for pulling. If not specified, will pull whatever docker prefers.\n    platform: amd64\n'''\nRETURN = '''\nimage:\n    description: Image inspection results for the affected image.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "peekOfCode": "RETURN = '''\nimage:\n    description: Image inspection results for the affected image.\n    returned: success\n    type: dict\n    sample: {}\n'''\nimport traceback\nfrom ansible.module_utils.common.text.converters import to_native\nfrom ansible_collections.community.docker.plugins.module_utils.common_api import (",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_pull",
        "documentation": {}
    },
    {
        "label": "ImagePusher",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "peekOfCode": "class ImagePusher(DockerBaseClass):\n    def __init__(self, client):\n        super(ImagePusher, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        parameters = self.client.module.params\n        self.name = parameters['name']\n        self.tag = parameters['tag']\n        if is_image_name_id(self.name):\n            self.client.fail(\"Cannot push an image by ID\")",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        tag=dict(type='str', default='latest'),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=False,\n    )\n    try:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_push\nshort_description: Push Docker images to registries\nversion_added: 3.6.0\ndescription:\n  - Pushes a Docker image to a registry.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_push\nshort_description: Push Docker images to registries\nversion_added: 3.6.0\ndescription:\n  - Pushes a Docker image to a registry.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "peekOfCode": "EXAMPLES = '''\n- name: Push an image\n  community.docker.docker_image_push:\n    name: registry.example.com:5000/repo/image\n    tag: latest\n'''\nRETURN = '''\nimage:\n    description: Image inspection results for the affected image.\n    returned: success",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "peekOfCode": "RETURN = '''\nimage:\n    description: Image inspection results for the affected image.\n    returned: success\n    type: dict\n    sample: {}\n'''\nimport traceback\nfrom ansible.module_utils.common.text.converters import to_native\nfrom ansible_collections.community.docker.plugins.module_utils.common_api import (",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_push",
        "documentation": {}
    },
    {
        "label": "ImageRemover",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "peekOfCode": "class ImageRemover(DockerBaseClass):\n    def __init__(self, client):\n        super(ImageRemover, self).__init__()\n        self.client = client\n        self.check_mode = self.client.check_mode\n        self.diff = self.client.module._diff\n        parameters = self.client.module.params\n        self.name = parameters['name']\n        self.tag = parameters['tag']\n        self.force = parameters['force']",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        tag=dict(type='str', default='latest'),\n        force=dict(type='bool', default=False),\n        prune=dict(type='bool', default=True),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_remove\nshort_description: Remove Docker images\nversion_added: 3.6.0\ndescription:\n  - Remove Docker images from the Docker daemon.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_remove\nshort_description: Remove Docker images\nversion_added: 3.6.0\ndescription:\n  - Remove Docker images from the Docker daemon.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "peekOfCode": "EXAMPLES = '''\n- name: Remove an image\n  community.docker.docker_image_remove:\n    name: pacur/centos-7\n'''\nRETURN = '''\nimage:\n    description:\n      - Image inspection results for the affected image before removal.\n      - Empty if the image was not found.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "peekOfCode": "RETURN = '''\nimage:\n    description:\n      - Image inspection results for the affected image before removal.\n      - Empty if the image was not found.\n    returned: success\n    type: dict\n    sample: {}\ndeleted:\n    description:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_remove",
        "documentation": {}
    },
    {
        "label": "ImageTagger",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "class ImageTagger(DockerBaseClass):\n    def __init__(self, client):\n        super(ImageTagger, self).__init__()\n        self.client = client\n        parameters = self.client.module.params\n        self.check_mode = self.client.check_mode\n        self.name = parameters['name']\n        self.tag = parameters['tag']\n        if not is_valid_tag(self.tag, allow_empty=True):\n            self.fail('\"{0}\" is not a valid docker tag'.format(self.tag))",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "convert_to_bytes",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "def convert_to_bytes(value, module, name, unlimited_value=None):\n    if value is None:\n        return value\n    try:\n        if unlimited_value is not None and value in ('unlimited', str(unlimited_value)):\n            return unlimited_value\n        return human_to_bytes(value)\n    except ValueError as exc:\n        module.fail_json(msg='Failed to convert %s to bytes: %s' % (name, to_native(exc)))\ndef image_info(name, tag, image):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "image_info",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "def image_info(name, tag, image):\n    result = dict(name=name, tag=tag)\n    if image:\n        result['id'] = image['Id']\n    else:\n        result['exists'] = False\n    return result\nclass ImageTagger(DockerBaseClass):\n    def __init__(self, client):\n        super(ImageTagger, self).__init__()",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        tag=dict(type='str', default='latest'),\n        repository=dict(type='list', elements='str', required=True),\n        existing_images=dict(type='str', choices=['keep', 'overwrite'], default='overwrite'),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_image_tag\nshort_description: Tag Docker images with new names and/or tags\nversion_added: 3.6.0\ndescription:\n  - This module allows to tag Docker images with new names and/or tags.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_image_tag\nshort_description: Tag Docker images with new names and/or tags\nversion_added: 3.6.0\ndescription:\n  - This module allows to tag Docker images with new names and/or tags.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "EXAMPLES = '''\n- name: Tag Python 3.12 image with two new names\n  community.docker.docker_image_tag:\n    name: python:3.12\n    repository:\n      - python-3:3.12\n      - local-registry:5000/python-3/3.12:latest\n'''\nRETURN = '''\nimage:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "peekOfCode": "RETURN = '''\nimage:\n    description: Image inspection results for the affected image.\n    returned: success\n    type: dict\n    sample: {}\ntagged_images:\n    description:\n      - A list of images that got tagged.\n    returned: success",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_image_tag",
        "documentation": {}
    },
    {
        "label": "DockerFileStore",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "peekOfCode": "class DockerFileStore(object):\n    '''\n    A custom credential store class that implements only the functionality we need to\n    update the docker config file when no credential helpers is provided.\n    '''\n    program = \"<legacy config>\"\n    def __init__(self, config_path):\n        self._config_path = config_path\n        # Make sure we have a minimal config if none is available.\n        self._config = dict(",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "documentation": {}
    },
    {
        "label": "LoginManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "peekOfCode": "class LoginManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(LoginManager, self).__init__()\n        self.client = client\n        self.results = results\n        parameters = self.client.module.params\n        self.check_mode = self.client.check_mode\n        self.registry_url = parameters.get('registry_url')\n        self.username = parameters.get('username')\n        self.password = parameters.get('password')",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        registry_url=dict(type='str', default=DEFAULT_DOCKER_REGISTRY, aliases=['registry', 'url']),\n        username=dict(type='str'),\n        password=dict(type='str', no_log=True),\n        reauthorize=dict(type='bool', default=False, aliases=['reauth']),\n        state=dict(type='str', default='present', choices=['present', 'absent']),\n        config_path=dict(type='path', default='~/.docker/config.json', aliases=['dockercfg_path']),\n    )\n    required_if = [",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_login\nshort_description: Log into a Docker registry.\ndescription:\n  - Provides functionality similar to the C(docker login) command.\n  - Authenticate with a docker registry and add the credentials to your local Docker config file respectively the\n    credentials store associated to the registry. Adding the credentials to the config files resp. the credential\n    store allows future connections to the registry using tools such as Ansible's Docker modules, the Docker CLI",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_login\nshort_description: Log into a Docker registry.\ndescription:\n  - Provides functionality similar to the C(docker login) command.\n  - Authenticate with a docker registry and add the credentials to your local Docker config file respectively the\n    credentials store associated to the registry. Adding the credentials to the config files resp. the credential\n    store allows future connections to the registry using tools such as Ansible's Docker modules, the Docker CLI\n    and Docker SDK for Python without needing to provide credentials.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "peekOfCode": "EXAMPLES = '''\n- name: Log into DockerHub\n  community.docker.docker_login:\n    username: docker\n    password: rekcod\n- name: Log into private registry and force re-authorization\n  community.docker.docker_login:\n    registry_url: your.private.registry.io\n    username: yourself\n    password: secrets3",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "peekOfCode": "RETURN = '''\nlogin_results:\n    description: Results from the login.\n    returned: when O(state=present)\n    type: dict\n    sample: {\n        \"serveraddress\": \"localhost:5000\",\n        \"username\": \"testuser\"\n    }\n'''",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_login",
        "documentation": {}
    },
    {
        "label": "TaskParameters",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "class TaskParameters(DockerBaseClass):\n    def __init__(self, client):\n        super(TaskParameters, self).__init__()\n        self.client = client\n        self.name = None\n        self.connected = None\n        self.config_from = None\n        self.config_only = None\n        self.driver = None\n        self.driver_options = None",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "DockerNetworkManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "class DockerNetworkManager(object):\n    def __init__(self, client):\n        self.client = client\n        self.parameters = TaskParameters(client)\n        self.check_mode = self.client.check_mode\n        self.results = {\n            u'changed': False,\n            u'actions': []\n        }\n        self.diff = self.client.module._diff",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "container_names_in_network",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "def container_names_in_network(network):\n    return [c['Name'] for c in network['Containers'].values()] if network['Containers'] else []\nCIDR_IPV4 = re.compile(r'^([0-9]{1,3}\\.){3}[0-9]{1,3}/([0-9]|[1-2][0-9]|3[0-2])$')\nCIDR_IPV6 = re.compile(r'^[0-9a-fA-F:]+/([0-9]|[1-9][0-9]|1[0-2][0-9])$')\ndef validate_cidr(cidr):\n    \"\"\"Validate CIDR. Return IP version of a CIDR string on success.\n    :param cidr: Valid CIDR\n    :type cidr: str\n    :return: ``ipv4`` or ``ipv6``\n    :rtype: str",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "validate_cidr",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "def validate_cidr(cidr):\n    \"\"\"Validate CIDR. Return IP version of a CIDR string on success.\n    :param cidr: Valid CIDR\n    :type cidr: str\n    :return: ``ipv4`` or ``ipv6``\n    :rtype: str\n    :raises ValueError: If ``cidr`` is not a valid CIDR\n    \"\"\"\n    if CIDR_IPV4.match(cidr):\n        return 'ipv4'",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "normalize_ipam_config_key",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "def normalize_ipam_config_key(key):\n    \"\"\"Normalizes IPAM config keys returned by Docker API to match Ansible keys.\n    :param key: Docker API key\n    :type key: str\n    :return Ansible module key\n    :rtype str\n    \"\"\"\n    special_cases = {\n        'AuxiliaryAddresses': 'aux_addresses'\n    }",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "dicts_are_essentially_equal",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "def dicts_are_essentially_equal(a, b):\n    \"\"\"Make sure that a is a subset of b, where None entries of a are ignored.\"\"\"\n    for k, v in a.items():\n        if v is None:\n            continue\n        if b.get(k) != v:\n            return False\n    return True\nclass DockerNetworkManager(object):\n    def __init__(self, client):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True, aliases=['network_name']),\n        config_from=dict(type='str'),\n        config_only=dict(type='bool'),\n        connected=dict(type='list', default=[], elements='str', aliases=['containers']),\n        state=dict(type='str', default='present', choices=['present', 'absent']),\n        driver=dict(type='str', default='bridge'),\n        driver_options=dict(type='dict', default={}),\n        force=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nmodule: docker_network\nshort_description: Manage Docker networks\ndescription:\n  - Create/remove Docker networks and connect containers to them.\n  - Performs largely the same function as the C(docker network) CLI subcommand.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "DOCUMENTATION = '''\nmodule: docker_network\nshort_description: Manage Docker networks\ndescription:\n  - Create/remove Docker networks and connect containers to them.\n  - Performs largely the same function as the C(docker network) CLI subcommand.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes\n  - community.docker.attributes.actiongroup_docker",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "EXAMPLES = '''\n- name: Create a network\n  community.docker.docker_network:\n    name: network_one\n- name: Remove all but selected list of containers\n  community.docker.docker_network:\n    name: network_one\n    connected:\n      - container_a\n      - container_b",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "RETURN = '''\nnetwork:\n    description:\n    - Network inspection results for the affected network.\n    returned: success\n    type: dict\n    sample: {}\n'''\nimport re\nimport traceback",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "CIDR_IPV4",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "CIDR_IPV4 = re.compile(r'^([0-9]{1,3}\\.){3}[0-9]{1,3}/([0-9]|[1-2][0-9]|3[0-2])$')\nCIDR_IPV6 = re.compile(r'^[0-9a-fA-F:]+/([0-9]|[1-9][0-9]|1[0-2][0-9])$')\ndef validate_cidr(cidr):\n    \"\"\"Validate CIDR. Return IP version of a CIDR string on success.\n    :param cidr: Valid CIDR\n    :type cidr: str\n    :return: ``ipv4`` or ``ipv6``\n    :rtype: str\n    :raises ValueError: If ``cidr`` is not a valid CIDR\n    \"\"\"",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "CIDR_IPV6",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "peekOfCode": "CIDR_IPV6 = re.compile(r'^[0-9a-fA-F:]+/([0-9]|[1-9][0-9]|1[0-2][0-9])$')\ndef validate_cidr(cidr):\n    \"\"\"Validate CIDR. Return IP version of a CIDR string on success.\n    :param cidr: Valid CIDR\n    :type cidr: str\n    :return: ``ipv4`` or ``ipv6``\n    :rtype: str\n    :raises ValueError: If ``cidr`` is not a valid CIDR\n    \"\"\"\n    if CIDR_IPV4.match(cidr):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n    )\n    try:\n        network = client.get_network(client.module.params['name'])",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_network_info\nshort_description: Retrieves facts about docker network\ndescription:\n  - Retrieves facts about a docker network.\n  - Essentially returns the output of C(docker network inspect <name>), similar to what M(community.docker.docker_network)\n    returns for a non-absent network.\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_network_info\nshort_description: Retrieves facts about docker network\ndescription:\n  - Retrieves facts about a docker network.\n  - Essentially returns the output of C(docker network inspect <name>), similar to what M(community.docker.docker_network)\n    returns for a non-absent network.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Get infos on network\n  community.docker.docker_network_info:\n    name: mydata\n  register: result\n- name: Does network exist?\n  ansible.builtin.debug:\n    msg: \"The network {{ 'exists' if result.exists else 'does not exist' }}\"\n- name: Print information about network\n  ansible.builtin.debug:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "peekOfCode": "RETURN = '''\nexists:\n    description:\n      - Returns whether the network exists.\n    type: bool\n    returned: always\n    sample: true\nnetwork:\n    description:\n      - Facts representing the current state of the network. Matches the docker inspection output.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_network_info",
        "documentation": {}
    },
    {
        "label": "TaskParameters",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "peekOfCode": "class TaskParameters(DockerBaseClass):\n    def __init__(self, client):\n        super(TaskParameters, self).__init__()\n        # Spec\n        self.name = None\n        self.labels = None\n        self.labels_state = None\n        self.labels_to_remove = None\n        # Node\n        self.availability = None",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "documentation": {}
    },
    {
        "label": "SwarmNodeManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "peekOfCode": "class SwarmNodeManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(SwarmNodeManager, self).__init__()\n        self.client = client\n        self.results = results\n        self.check_mode = self.client.check_mode\n        self.client.fail_task_if_not_swarm_manager()\n        self.parameters = TaskParameters(client)\n        self.node_update()\n    def node_update(self):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        hostname=dict(type='str', required=True),\n        labels=dict(type='dict'),\n        labels_state=dict(type='str', default='merge', choices=['merge', 'replace']),\n        labels_to_remove=dict(type='list', elements='str'),\n        availability=dict(type='str', choices=['active', 'pause', 'drain']),\n        role=dict(type='str', choices=['worker', 'manager']),\n    )\n    client = AnsibleDockerSwarmClient(",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_node\nshort_description: Manage Docker Swarm node\ndescription:\n    - Manages the Docker nodes via Swarm Manager.\n    - This module allows to change the node's role, its availability, and to modify, add or remove node labels.\nextends_documentation_fragment:\n  - community.docker.docker",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_node\nshort_description: Manage Docker Swarm node\ndescription:\n    - Manages the Docker nodes via Swarm Manager.\n    - This module allows to change the node's role, its availability, and to modify, add or remove node labels.\nextends_documentation_fragment:\n  - community.docker.docker\n  - community.docker.docker.docker_py_1_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "peekOfCode": "EXAMPLES = '''\n- name: Set node role\n  community.docker.docker_node:\n    hostname: mynode\n    role: manager\n- name: Set node availability\n  community.docker.docker_node:\n    hostname: mynode\n    availability: drain\n- name: Replace node labels with new labels",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "peekOfCode": "RETURN = '''\nnode:\n  description: Information about node after 'update' operation\n  returned: success\n  type: dict\n'''\nimport traceback\ntry:\n    from docker.errors import DockerException, APIError\nexcept ImportError:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node",
        "documentation": {}
    },
    {
        "label": "get_node_facts",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "peekOfCode": "def get_node_facts(client):\n    results = []\n    if client.module.params['self'] is True:\n        self_node_id = client.get_swarm_node_id()\n        node_info = client.get_node_inspect(node_id=self_node_id)\n        results.append(node_info)\n        return results\n    if client.module.params['name'] is None:\n        node_info = client.get_all_nodes_inspect()\n        return node_info",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='list', elements='str'),\n        self=dict(type='bool', default=False),\n    )\n    client = AnsibleDockerSwarmClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n        min_docker_version='2.4.0',\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_node_info\nshort_description: Retrieves facts about docker swarm node from Swarm Manager\ndescription:\n  - Retrieves facts about a docker node.\n  - Essentially returns the output of C(docker node inspect <name>).\n  - Must be executed on a host running as Swarm Manager, otherwise the module will fail.\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_node_info\nshort_description: Retrieves facts about docker swarm node from Swarm Manager\ndescription:\n  - Retrieves facts about a docker node.\n  - Essentially returns the output of C(docker node inspect <name>).\n  - Must be executed on a host running as Swarm Manager, otherwise the module will fail.\nextends_documentation_fragment:\n  - community.docker.docker",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Get info on all nodes\n  community.docker.docker_node_info:\n  register: result\n- name: Get info on node\n  community.docker.docker_node_info:\n    name: mynode\n  register: result\n- name: Get info on list of nodes\n  community.docker.docker_node_info:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "peekOfCode": "RETURN = '''\nnodes:\n    description:\n      - Facts representing the current state of the nodes. Matches the C(docker node inspect) output.\n      - Can contain multiple entries if more than one node provided in O(name), or O(name) is not provided.\n      - If O(name) contains a list of nodes, the output will provide information on all nodes registered\n        at the swarm, including nodes that left the swarm but have not been removed from the cluster on swarm\n        managers and nodes that are unreachable.\n    returned: always\n    type: list",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_node_info",
        "documentation": {}
    },
    {
        "label": "TaskParameters",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "class TaskParameters(DockerBaseClass):\n    def __init__(self, client):\n        super(TaskParameters, self).__init__()\n        self.client = client\n        self.plugin_name = None\n        self.alias = None\n        self.plugin_options = None\n        self.debug = None\n        self.force_remove = None\n        self.enable_timeout = None",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "DockerPluginManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "class DockerPluginManager(object):\n    def __init__(self, client):\n        self.client = client\n        self.parameters = TaskParameters(client)\n        self.preferred_name = self.parameters.alias or self.parameters.plugin_name\n        self.check_mode = self.client.check_mode\n        self.diff = self.client.module._diff\n        self.diff_tracker = DifferenceTracker()\n        self.diff_result = dict()\n        self.actions = []",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "prepare_options",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "def prepare_options(options):\n    return ['%s=%s' % (k, v if v is not None else \"\") for k, v in options.items()] if options else []\ndef parse_options(options_list):\n    return dict(x.split('=', 1) for x in options_list) if options_list else {}\nclass DockerPluginManager(object):\n    def __init__(self, client):\n        self.client = client\n        self.parameters = TaskParameters(client)\n        self.preferred_name = self.parameters.alias or self.parameters.plugin_name\n        self.check_mode = self.client.check_mode",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "parse_options",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "def parse_options(options_list):\n    return dict(x.split('=', 1) for x in options_list) if options_list else {}\nclass DockerPluginManager(object):\n    def __init__(self, client):\n        self.client = client\n        self.parameters = TaskParameters(client)\n        self.preferred_name = self.parameters.alias or self.parameters.plugin_name\n        self.check_mode = self.client.check_mode\n        self.diff = self.client.module._diff\n        self.diff_tracker = DifferenceTracker()",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        alias=dict(type='str'),\n        plugin_name=dict(type='str', required=True),\n        state=dict(type='str', default='present', choices=['present', 'absent', 'enable', 'disable']),\n        plugin_options=dict(type='dict', default={}),\n        debug=dict(type='bool', default=False),\n        force_remove=dict(type='bool', default=False),\n        enable_timeout=dict(type='int', default=0),\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nmodule: docker_plugin\nshort_description: Manage Docker plugins\nversion_added: 1.3.0\ndescription:\n  - This module allows to install, delete, enable and disable Docker plugins.\n  - Performs largely the same function as the C(docker plugin) CLI subcommand.\nnotes:\n  - The C(--grant-all-permissions) CLI flag is true by default in this module.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "DOCUMENTATION = '''\nmodule: docker_plugin\nshort_description: Manage Docker plugins\nversion_added: 1.3.0\ndescription:\n  - This module allows to install, delete, enable and disable Docker plugins.\n  - Performs largely the same function as the C(docker plugin) CLI subcommand.\nnotes:\n  - The C(--grant-all-permissions) CLI flag is true by default in this module.\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "EXAMPLES = '''\n- name: Install a plugin\n  community.docker.docker_plugin:\n    plugin_name: plugin_one\n    state: present\n- name: Remove a plugin\n  community.docker.docker_plugin:\n    plugin_name: plugin_one\n    state: absent\n- name: Enable the plugin",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "peekOfCode": "RETURN = '''\nplugin:\n    description:\n      - Plugin inspection results for the affected plugin.\n    returned: success\n    type: dict\n    sample: {}\nactions:\n    description:\n      - List of actions performed during task execution.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_plugin",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        containers=dict(type='bool', default=False),\n        containers_filters=dict(type='dict'),\n        images=dict(type='bool', default=False),\n        images_filters=dict(type='dict'),\n        networks=dict(type='bool', default=False),\n        networks_filters=dict(type='dict'),\n        volumes=dict(type='bool', default=False),\n        volumes_filters=dict(type='dict'),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_prune\nshort_description: Allows to prune various docker objects\ndescription:\n  - Allows to run C(docker container prune), C(docker image prune), C(docker network prune)\n    and C(docker volume prune) via the Docker API.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_prune\nshort_description: Allows to prune various docker objects\ndescription:\n  - Allows to run C(docker container prune), C(docker image prune), C(docker network prune)\n    and C(docker volume prune) via the Docker API.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "peekOfCode": "EXAMPLES = '''\n- name: Prune containers older than 24h\n  community.docker.docker_prune:\n    containers: true\n    containers_filters:\n      # only consider containers created more than 24 hours ago\n      until: 24h\n- name: Prune everything\n  community.docker.docker_prune:\n    containers: true",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "peekOfCode": "RETURN = '''\n# containers\ncontainers:\n    description:\n      - List of IDs of deleted containers.\n    returned: O(containers=true)\n    type: list\n    elements: str\n    sample: []\ncontainers_space_reclaimed:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_prune",
        "documentation": {}
    },
    {
        "label": "SecretManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "peekOfCode": "class SecretManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(SecretManager, self).__init__()\n        self.client = client\n        self.results = results\n        self.check_mode = self.client.check_mode\n        parameters = self.client.module.params\n        self.name = parameters.get('name')\n        self.state = parameters.get('state')\n        self.data = parameters.get('data')",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        state=dict(type='str', default='present', choices=['absent', 'present']),\n        data=dict(type='str', no_log=True),\n        data_is_b64=dict(type='bool', default=False),\n        data_src=dict(type='path'),\n        labels=dict(type='dict'),\n        force=dict(type='bool', default=False),\n        rolling_versions=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_secret\nshort_description: Manage docker secrets.\ndescription:\n  - Create and remove Docker secrets in a Swarm environment. Similar to C(docker secret create) and C(docker secret rm).\n  - Adds to the metadata of new secrets C(ansible_key), an encrypted hash representation of the data, which is then used\n    in future runs to test if a secret has changed. If C(ansible_key) is not present, then a secret will not be updated\n    unless the O(force) option is set.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_secret\nshort_description: Manage docker secrets.\ndescription:\n  - Create and remove Docker secrets in a Swarm environment. Similar to C(docker secret create) and C(docker secret rm).\n  - Adds to the metadata of new secrets C(ansible_key), an encrypted hash representation of the data, which is then used\n    in future runs to test if a secret has changed. If C(ansible_key) is not present, then a secret will not be updated\n    unless the O(force) option is set.\n  - Updates to secrets are performed by removing the secret and creating it again.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "peekOfCode": "EXAMPLES = '''\n- name: Create secret foo (from a file on the control machine)\n  community.docker.docker_secret:\n    name: foo\n    # If the file is JSON or binary, Ansible might modify it (because\n    # it is first decoded and later re-encoded). Base64-encoding the\n    # file directly after reading it prevents this to happen.\n    data: \"{{ lookup('file', '/path/to/secret/file') | b64encode }}\"\n    data_is_b64: true\n    state: present",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "peekOfCode": "RETURN = '''\nsecret_id:\n  description:\n    - The ID assigned by Docker to the secret object.\n  returned: success and O(state=present)\n  type: str\n  sample: 'hzehrmyjigmcp2gb6nlhmjqcv'\nsecret_name:\n  description:\n    - The name of the created secret object.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_secret",
        "documentation": {}
    },
    {
        "label": "docker_stack_services",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "def docker_stack_services(client, stack_name):\n    rc, out, err = client.call_cli(\"stack\", \"services\", stack_name, \"--format\", \"{{.Name}}\")\n    if to_native(err) == \"Nothing found in stack: %s\\n\" % stack_name:\n        return []\n    return to_native(out).strip().split('\\n')\ndef docker_service_inspect(client, service_name):\n    rc, out, err = client.call_cli(\"service\", \"inspect\", service_name)\n    if rc != 0:\n        return None\n    else:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "docker_service_inspect",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "def docker_service_inspect(client, service_name):\n    rc, out, err = client.call_cli(\"service\", \"inspect\", service_name)\n    if rc != 0:\n        return None\n    else:\n        ret = json.loads(out)[0]['Spec']\n        return ret\ndef docker_stack_deploy(client, stack_name, compose_files):\n    command = [\"stack\", \"deploy\"]\n    if client.module.params[\"prune\"]:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "docker_stack_deploy",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "def docker_stack_deploy(client, stack_name, compose_files):\n    command = [\"stack\", \"deploy\"]\n    if client.module.params[\"prune\"]:\n        command += [\"--prune\"]\n    if client.module.params[\"with_registry_auth\"]:\n        command += [\"--with-registry-auth\"]\n    if client.module.params[\"resolve_image\"]:\n        command += [\"--resolve-image\",\n                    client.module.params[\"resolve_image\"]]\n    for compose_file in compose_files:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "docker_stack_inspect",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "def docker_stack_inspect(client, stack_name):\n    ret = {}\n    for service_name in docker_stack_services(client, stack_name):\n        ret[service_name] = docker_service_inspect(client, service_name)\n    return ret\ndef docker_stack_rm(client, stack_name, retries, interval):\n    command = [\"stack\", \"rm\", stack_name]\n    rc, out, err = client.call_cli(*command)\n    while to_native(err) != \"Nothing found in stack: %s\\n\" % stack_name and retries > 0:\n        sleep(interval)",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "docker_stack_rm",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "def docker_stack_rm(client, stack_name, retries, interval):\n    command = [\"stack\", \"rm\", stack_name]\n    rc, out, err = client.call_cli(*command)\n    while to_native(err) != \"Nothing found in stack: %s\\n\" % stack_name and retries > 0:\n        sleep(interval)\n        retries = retries - 1\n        rc, out, err = client.call_cli(*command)\n    return rc, to_native(out), to_native(err)\ndef main():\n    client = AnsibleModuleDockerClient(",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "def main():\n    client = AnsibleModuleDockerClient(\n        argument_spec={\n            'name': dict(type='str', required=True),\n            'compose': dict(type='list', elements='raw', default=[]),\n            'prune': dict(type='bool', default=False),\n            'with_registry_auth': dict(type='bool', default=False),\n            'resolve_image': dict(type='str', choices=['always', 'changed', 'never']),\n            'state': dict(type='str', default='present', choices=['present', 'absent']),\n            'absent_retries': dict(type='int', default=0),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_stack\nauthor: \"Dario Zanzico (@dariko)\"\nshort_description: docker stack module\ndescription:\n  - Manage docker stacks using the C(docker stack) command\n    on the target node (see examples).\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_stack\nauthor: \"Dario Zanzico (@dariko)\"\nshort_description: docker stack module\ndescription:\n  - Manage docker stacks using the C(docker stack) command\n    on the target node (see examples).\nextends_documentation_fragment:\n  - community.docker.docker.cli_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "RETURN = '''\nstack_spec_diff:\n    description: |\n        dictionary containing the differences between the 'Spec' field\n        of the stack services before and after applying the new stack\n        definition.\n    sample: >\n        \"stack_spec_diff\":\n        {'test_stack_test_service': {u'TaskTemplate': {u'ContainerSpec': {delete: [u'Env']}}}}\n    returned: on change",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "peekOfCode": "EXAMPLES = '''\n  - name: Deploy stack from a compose file\n    community.docker.docker_stack:\n      state: present\n      name: mystack\n      compose:\n        - /opt/docker-compose.yml\n  - name: Deploy stack from base compose file and override the web service\n    community.docker.docker_stack:\n      state: present",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack",
        "documentation": {}
    },
    {
        "label": "docker_stack_list",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "peekOfCode": "def docker_stack_list(module):\n    docker_bin = module.get_bin_path('docker', required=True)\n    rc, out, err = module.run_command(\n        [docker_bin, \"stack\", \"ls\", \"--format={{json .}}\"])\n    return rc, out.strip(), err.strip()\ndef main():\n    client = AnsibleModuleDockerClient(\n        argument_spec={\n        },\n        supports_check_mode=True,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "peekOfCode": "def main():\n    client = AnsibleModuleDockerClient(\n        argument_spec={\n        },\n        supports_check_mode=True,\n    )\n    try:\n        rc, ret, stderr = client.call_cli_json_stream('stack', 'ls', '--format={{json .}}', check_rc=True)\n        client.module.exit_json(\n            changed=False,",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_stack_info\nauthor: \"Jose Angel Munoz (@imjoseangel)\"\nshort_description: Return information on all docker stacks\ndescription:\n  - Retrieve information on docker stacks using the C(docker stack) command\n    on the target node (see examples).\nrequirements:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_stack_info\nauthor: \"Jose Angel Munoz (@imjoseangel)\"\nshort_description: Return information on all docker stacks\ndescription:\n  - Retrieve information on docker stacks using the C(docker stack) command\n    on the target node (see examples).\nrequirements:\n  - Docker CLI tool C(docker)",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "peekOfCode": "RETURN = '''\nresults:\n    description:\n        - List of dictionaries containing the list of stacks on the target node\n    sample:\n        - {\"name\":\"grafana\",\"namespace\":\"default\",\"orchestrator\":\"Kubernetes\",\"services\":\"2\"}\n    returned: always\n    type: list\n    elements: dict\n'''",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "peekOfCode": "EXAMPLES = '''\n  - name: Shows stack info\n    community.docker.docker_stack_info:\n    register: result\n  - name: Show results\n    ansible.builtin.debug:\n      var: result.results\n'''\nimport json\nimport traceback",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_info",
        "documentation": {}
    },
    {
        "label": "docker_stack_task",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "peekOfCode": "def docker_stack_task(module, stack_name):\n    docker_bin = module.get_bin_path('docker', required=True)\n    rc, out, err = module.run_command(\n        [docker_bin, \"stack\", \"ps\", stack_name, \"--format={{json .}}\"])\n    return rc, out.strip(), err.strip()\ndef main():\n    client = AnsibleModuleDockerClient(\n        argument_spec={\n            'name': dict(type='str', required=True)\n        },",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "peekOfCode": "def main():\n    client = AnsibleModuleDockerClient(\n        argument_spec={\n            'name': dict(type='str', required=True)\n        },\n        supports_check_mode=True,\n    )\n    try:\n        name = client.module.params['name']\n        rc, ret, stderr = client.call_cli_json_stream('stack', 'ps', name, '--format={{json .}}', check_rc=True)",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_stack_task_info\nauthor: \"Jose Angel Munoz (@imjoseangel)\"\nshort_description: Return information of the tasks on a docker stack\ndescription:\n  - Retrieve information on docker stacks tasks using the C(docker stack) command\n    on the target node (see examples).\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_stack_task_info\nauthor: \"Jose Angel Munoz (@imjoseangel)\"\nshort_description: Return information of the tasks on a docker stack\ndescription:\n  - Retrieve information on docker stacks tasks using the C(docker stack) command\n    on the target node (see examples).\nextends_documentation_fragment:\n  - community.docker.docker.cli_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "peekOfCode": "RETURN = '''\nresults:\n    description:\n        - List of dictionaries containing the list of tasks associated\n          to a stack name.\n    sample:\n        - {\"CurrentState\":\"Running\",\"DesiredState\":\"Running\",\"Error\":\"\",\"ID\":\"7wqv6m02ugkw\",\"Image\":\"busybox\",\"Name\":\"test_stack.1\",\"Node\":\"swarm\",\"Ports\":\"\"}\n    returned: always\n    type: list\n    elements: dict",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "peekOfCode": "EXAMPLES = '''\n  - name: Shows stack info\n    community.docker.docker_stack_task_info:\n      name: test_stack\n    register: result\n  - name: Show results\n    ansible.builtin.debug:\n      var: result.results\n'''\nimport json",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_stack_task_info",
        "documentation": {}
    },
    {
        "label": "TaskParameters",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "peekOfCode": "class TaskParameters(DockerBaseClass):\n    def __init__(self):\n        super(TaskParameters, self).__init__()\n        self.advertise_addr = None\n        self.listen_addr = None\n        self.remote_addrs = None\n        self.join_token = None\n        self.data_path_addr = None\n        self.data_path_port = None\n        # Spec",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "documentation": {}
    },
    {
        "label": "SwarmManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "peekOfCode": "class SwarmManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(SwarmManager, self).__init__()\n        self.client = client\n        self.results = results\n        self.check_mode = self.client.check_mode\n        self.swarm_info = {}\n        self.state = client.module.params['state']\n        self.force = client.module.params['force']\n        self.node_id = client.module.params['node_id']",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        advertise_addr=dict(type='str'),\n        data_path_addr=dict(type='str'),\n        data_path_port=dict(type='int'),\n        state=dict(type='str', default='present', choices=['present', 'join', 'absent', 'remove']),\n        force=dict(type='bool', default=False),\n        listen_addr=dict(type='str', default='0.0.0.0:2377'),\n        remote_addrs=dict(type='list', elements='str'),\n        join_token=dict(type='str', no_log=True),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_swarm\nshort_description: Manage Swarm cluster\ndescription:\n  - Create a new Swarm cluster.\n  - Add/Remove nodes or managers to an existing cluster.\nextends_documentation_fragment:\n  - community.docker.docker",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_swarm\nshort_description: Manage Swarm cluster\ndescription:\n  - Create a new Swarm cluster.\n  - Add/Remove nodes or managers to an existing cluster.\nextends_documentation_fragment:\n  - community.docker.docker\n  - community.docker.docker.docker_py_1_documentation",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "peekOfCode": "EXAMPLES = '''\n- name: Init a new swarm with default parameters\n  community.docker.docker_swarm:\n    state: present\n- name: Update swarm configuration\n  community.docker.docker_swarm:\n    state: present\n    election_tick: 5\n- name: Add nodes\n  community.docker.docker_swarm:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "peekOfCode": "RETURN = '''\nswarm_facts:\n  description: Information about swarm.\n  returned: success\n  type: dict\n  contains:\n      JoinTokens:\n          description: Tokens to connect to the Swarm.\n          returned: success\n          type: dict",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm",
        "documentation": {}
    },
    {
        "label": "DockerSwarmManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "peekOfCode": "class DockerSwarmManager(DockerBaseClass):\n    def __init__(self, client, results):\n        super(DockerSwarmManager, self).__init__()\n        self.client = client\n        self.results = results\n        self.verbose_output = self.client.module.params['verbose_output']\n        listed_objects = ['tasks', 'services', 'nodes']\n        self.client.fail_task_if_not_swarm_manager()\n        self.results['swarm_facts'] = self.get_docker_swarm_facts()\n        for docker_object in listed_objects:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        nodes=dict(type='bool', default=False),\n        nodes_filters=dict(type='dict'),\n        tasks=dict(type='bool', default=False),\n        tasks_filters=dict(type='dict'),\n        services=dict(type='bool', default=False),\n        services_filters=dict(type='dict'),\n        unlock_key=dict(type='bool', default=False),\n        verbose_output=dict(type='bool', default=False),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_swarm_info\nshort_description: Retrieves facts about Docker Swarm cluster.\ndescription:\n  - Retrieves facts about a Docker Swarm.\n  - Returns lists of swarm objects names for the services - nodes, services, tasks.\n  - The output differs depending on API version available on docker host.\n  - Must be run on Swarm Manager node; otherwise module fails with error message.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_swarm_info\nshort_description: Retrieves facts about Docker Swarm cluster.\ndescription:\n  - Retrieves facts about a Docker Swarm.\n  - Returns lists of swarm objects names for the services - nodes, services, tasks.\n  - The output differs depending on API version available on docker host.\n  - Must be run on Swarm Manager node; otherwise module fails with error message.\n    It does return boolean flags in on both error and success which indicate whether",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Get info on Docker Swarm\n  community.docker.docker_swarm_info:\n  ignore_errors: true\n  register: result\n- name: Inform about basic flags\n  ansible.builtin.debug:\n    msg: |\n      Was able to talk to docker daemon: {{ result.can_talk_to_docker }}\n      Docker in Swarm mode: {{ result.docker_swarm_active }}",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "peekOfCode": "RETURN = '''\ncan_talk_to_docker:\n    description:\n      - Will be V(true) if the module can talk to the docker daemon.\n    returned: both on success and on error\n    type: bool\ndocker_swarm_active:\n    description:\n      - Will be V(true) if the module can talk to the docker daemon,\n        and the docker daemon is in Swarm mode.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_info",
        "documentation": {}
    },
    {
        "label": "DockerService",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "class DockerService(DockerBaseClass):\n    def __init__(self, docker_api_version, docker_py_version):\n        super(DockerService, self).__init__()\n        self.image = \"\"\n        self.command = None\n        self.args = None\n        self.endpoint_mode = None\n        self.dns = None\n        self.healthcheck = None\n        self.healthcheck_disabled = None",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "DockerServiceManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "class DockerServiceManager(object):\n    def __init__(self, client):\n        self.client = client\n        self.retries = 2\n        self.diff_tracker = None\n    def get_service(self, name):\n        try:\n            raw_data = self.client.inspect_service(name)\n        except NotFound:\n            return None",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "get_docker_environment",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def get_docker_environment(env, env_files):\n    \"\"\"\n    Will return a list of \"KEY=VALUE\" items. Supplied env variable can\n    be either a list or a dictionary.\n    If environment files are combined with explicit environment variables,\n    the explicit environment variables take precedence.\n    \"\"\"\n    env_dict = {}\n    if env_files:\n        for env_file in env_files:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "get_docker_networks",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def get_docker_networks(networks, network_ids):\n    \"\"\"\n    Validate a list of network names or a list of network dictionaries.\n    Network names will be resolved to ids by using the network_ids mapping.\n    \"\"\"\n    if networks is None:\n        return None\n    parsed_networks = []\n    for network in networks:\n        if isinstance(network, string_types):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "get_nanoseconds_from_raw_option",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def get_nanoseconds_from_raw_option(name, value):\n    if value is None:\n        return None\n    elif isinstance(value, int):\n        return value\n    elif isinstance(value, string_types):\n        try:\n            return int(value)\n        except ValueError:\n            return convert_duration_to_nanosecond(value)",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "get_value",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def get_value(key, values, default=None):\n    value = values.get(key)\n    return value if value is not None else default\ndef has_dict_changed(new_dict, old_dict):\n    \"\"\"\n    Check if new_dict has differences compared to old_dict while\n    ignoring keys in old_dict which are None in new_dict.\n    \"\"\"\n    if new_dict is None:\n        return False",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "has_dict_changed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def has_dict_changed(new_dict, old_dict):\n    \"\"\"\n    Check if new_dict has differences compared to old_dict while\n    ignoring keys in old_dict which are None in new_dict.\n    \"\"\"\n    if new_dict is None:\n        return False\n    if not new_dict and old_dict:\n        return True\n    if not old_dict and new_dict:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "has_list_changed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def has_list_changed(new_list, old_list, sort_lists=True, sort_key=None):\n    \"\"\"\n    Check two lists have differences. Sort lists by default.\n    \"\"\"\n    def sort_list(unsorted_list):\n        \"\"\"\n        Sort a given list.\n        The list may contain dictionaries, so use the sort key to handle them.\n        \"\"\"\n        if unsorted_list and isinstance(unsorted_list[0], dict):",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "have_networks_changed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def have_networks_changed(new_networks, old_networks):\n    \"\"\"Special case list checking for networks to sort aliases\"\"\"\n    if new_networks is None:\n        return False\n    old_networks = old_networks or []\n    if len(new_networks) != len(old_networks):\n        return True\n    zip_data = zip(\n        sorted(new_networks, key=lambda k: k['id']),\n        sorted(old_networks, key=lambda k: k['id'])",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n        image=dict(type='str'),\n        state=dict(type='str', default='present', choices=['present', 'absent']),\n        mounts=dict(type='list', elements='dict', options=dict(\n            source=dict(type='str'),\n            target=dict(type='str', required=True),\n            type=dict(\n                type='str',",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_swarm_service\nauthor:\n  - \"Dario Zanzico (@dariko)\"\n  - \"Jason Witkowski (@jwitko)\"\n  - \"Hannes Ljungberg (@hannseman)\"\n  - \"Piotr Wojciechowski (@wojciechowskipiotr)\"\nshort_description: docker swarm service",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_swarm_service\nauthor:\n  - \"Dario Zanzico (@dariko)\"\n  - \"Jason Witkowski (@jwitko)\"\n  - \"Hannes Ljungberg (@hannseman)\"\n  - \"Piotr Wojciechowski (@wojciechowskipiotr)\"\nshort_description: docker swarm service\ndescription:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "RETURN = '''\nswarm_service:\n  returned: always\n  type: dict\n  description:\n    - Dictionary of variables representing the current state of the service.\n      Matches the module parameters format.\n    - Note that facts are not part of registered vars but accessible directly.\n    - Note that before Ansible 2.7.9, the return variable was documented as C(ansible_swarm_service),\n      while the module actually returned a variable called C(ansible_docker_service). The variable",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "peekOfCode": "EXAMPLES = '''\n- name: Set command and arguments\n  community.docker.docker_swarm_service:\n    name: myservice\n    image: alpine\n    command: sleep\n    args:\n      - \"3600\"\n- name: Set a bind mount\n  community.docker.docker_swarm_service:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "get_service_info",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "peekOfCode": "def get_service_info(client):\n    service = client.module.params['name']\n    return client.get_service_inspect(\n        service_id=service,\n        skip_missing=True\n    )\ndef main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True),\n    )\n    client = AnsibleDockerSwarmClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n        min_docker_version='2.0.0',\n    )\n    client.fail_task_if_not_swarm_manager()",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\n---\nmodule: docker_swarm_service_info\nshort_description: Retrieves information about docker services from a Swarm Manager\ndescription:\n  - Retrieves information about a docker service.\n  - Essentially returns the output of C(docker service inspect <name>).\n  - Must be executed on a host running as Swarm Manager, otherwise the module will fail.\nextends_documentation_fragment:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "peekOfCode": "DOCUMENTATION = '''\n---\nmodule: docker_swarm_service_info\nshort_description: Retrieves information about docker services from a Swarm Manager\ndescription:\n  - Retrieves information about a docker service.\n  - Essentially returns the output of C(docker service inspect <name>).\n  - Must be executed on a host running as Swarm Manager, otherwise the module will fail.\nextends_documentation_fragment:\n  - community.docker.docker",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Get info from a service\n  community.docker.docker_swarm_service_info:\n    name: myservice\n  register: result\n'''\nRETURN = '''\nexists:\n    description:\n      - Returns whether the service exists.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "peekOfCode": "RETURN = '''\nexists:\n    description:\n      - Returns whether the service exists.\n    type: bool\n    returned: always\n    sample: true\nservice:\n    description:\n      - A dictionary representing the current state of the service. Matches the C(docker service inspect) output.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_swarm_service_info",
        "documentation": {}
    },
    {
        "label": "TaskParameters",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "peekOfCode": "class TaskParameters(DockerBaseClass):\n    def __init__(self, client):\n        super(TaskParameters, self).__init__()\n        self.client = client\n        self.volume_name = None\n        self.driver = None\n        self.driver_options = None\n        self.labels = None\n        self.recreate = None\n        self.debug = None",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "documentation": {}
    },
    {
        "label": "DockerVolumeManager",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "peekOfCode": "class DockerVolumeManager(object):\n    def __init__(self, client):\n        self.client = client\n        self.parameters = TaskParameters(client)\n        self.check_mode = self.client.check_mode\n        self.results = {\n            u'changed': False,\n            u'actions': []\n        }\n        self.diff = self.client.module._diff",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        volume_name=dict(type='str', required=True, aliases=['name']),\n        state=dict(type='str', default='present', choices=['present', 'absent']),\n        driver=dict(type='str', default='local'),\n        driver_options=dict(type='dict', default={}),\n        labels=dict(type='dict'),\n        recreate=dict(type='str', default='never', choices=['always', 'never', 'options-changed']),\n        debug=dict(type='bool', default=False)\n    )",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nmodule: docker_volume\nshort_description: Manage Docker volumes\ndescription:\n  - Create/remove Docker volumes.\n  - Performs largely the same function as the C(docker volume) CLI subcommand.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "peekOfCode": "DOCUMENTATION = '''\nmodule: docker_volume\nshort_description: Manage Docker volumes\ndescription:\n  - Create/remove Docker volumes.\n  - Performs largely the same function as the C(docker volume) CLI subcommand.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes\n  - community.docker.attributes.actiongroup_docker",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "peekOfCode": "EXAMPLES = '''\n- name: Create a volume\n  community.docker.docker_volume:\n    name: volume_one\n- name: Remove a volume\n  community.docker.docker_volume:\n    name: volume_one\n    state: absent\n- name: Create a volume with options\n  community.docker.docker_volume:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "peekOfCode": "RETURN = '''\nvolume:\n    description:\n    - Volume inspection results for the affected volume.\n    returned: success\n    type: dict\n    sample: {}\n'''\nimport traceback\nfrom ansible.module_utils.common.text.converters import to_native",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume",
        "documentation": {}
    },
    {
        "label": "get_existing_volume",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "peekOfCode": "def get_existing_volume(client, volume_name):\n    try:\n        return client.get_json('/volumes/{0}', volume_name)\n    except NotFound as dummy:\n        return None\n    except Exception as exc:\n        client.fail(\"Error inspecting volume: %s\" % to_native(exc))\ndef main():\n    argument_spec = dict(\n        name=dict(type='str', required=True, aliases=['volume_name']),",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "peekOfCode": "def main():\n    argument_spec = dict(\n        name=dict(type='str', required=True, aliases=['volume_name']),\n    )\n    client = AnsibleDockerClient(\n        argument_spec=argument_spec,\n        supports_check_mode=True,\n    )\n    try:\n        volume = get_existing_volume(client, client.module.params['name'])",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "peekOfCode": "__metaclass__ = type\nDOCUMENTATION = '''\nmodule: docker_volume_info\nshort_description: Retrieve facts about Docker volumes\ndescription:\n  - Performs largely the same function as the C(docker volume inspect) CLI subcommand.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes\n  - community.docker.attributes.actiongroup_docker",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "documentation": {}
    },
    {
        "label": "DOCUMENTATION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "peekOfCode": "DOCUMENTATION = '''\nmodule: docker_volume_info\nshort_description: Retrieve facts about Docker volumes\ndescription:\n  - Performs largely the same function as the C(docker volume inspect) CLI subcommand.\nextends_documentation_fragment:\n  - community.docker.docker.api_documentation\n  - community.docker.attributes\n  - community.docker.attributes.actiongroup_docker\n  - community.docker.attributes.info_module",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "documentation": {}
    },
    {
        "label": "EXAMPLES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "peekOfCode": "EXAMPLES = '''\n- name: Get infos on volume\n  community.docker.docker_volume_info:\n    name: mydata\n  register: result\n- name: Does volume exist?\n  ansible.builtin.debug:\n    msg: \"The volume {{ 'exists' if result.exists else 'does not exist' }}\"\n- name: Print information about volume\n  ansible.builtin.debug:",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "documentation": {}
    },
    {
        "label": "RETURN",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "description": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "peekOfCode": "RETURN = '''\nexists:\n    description:\n      - Returns whether the volume exists.\n    type: bool\n    returned: always\n    sample: true\nvolume:\n    description:\n      - Volume inspection results for the affected volume.",
        "detail": "collections.ansible_collections.community.docker.plugins.modules.docker_volume_info",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.common",
        "peekOfCode": "class AnsibleDockerClient(AnsibleDockerClientBase):\n    def __init__(self, plugin, min_docker_version=None, min_docker_api_version=None):\n        self.plugin = plugin\n        self.display = Display()\n        super(AnsibleDockerClient, self).__init__(\n            min_docker_version=min_docker_version,\n            min_docker_api_version=min_docker_api_version)\n    def fail(self, msg, **kwargs):\n        if kwargs:\n            msg += '\\nContext:\\n' + '\\n'.join('  {0} = {1!r}'.format(k, v) for (k, v) in kwargs.items())",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.common",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.common",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.common",
        "peekOfCode": "__metaclass__ = type\nfrom ansible.errors import AnsibleConnectionFailure\nfrom ansible.utils.display import Display\nfrom ansible_collections.community.docker.plugins.module_utils.common import (\n    AnsibleDockerClientBase,\n)\nfrom ansible_collections.community.docker.plugins.module_utils.util import (\n    DOCKER_COMMON_ARGS,\n)\nclass AnsibleDockerClient(AnsibleDockerClientBase):",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.common",
        "documentation": {}
    },
    {
        "label": "AnsibleDockerClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "peekOfCode": "class AnsibleDockerClient(AnsibleDockerClientBase):\n    def __init__(self, plugin, min_docker_api_version=None):\n        self.plugin = plugin\n        self.display = Display()\n        super(AnsibleDockerClient, self).__init__(\n            min_docker_api_version=min_docker_api_version)\n    def fail(self, msg, **kwargs):\n        if kwargs:\n            msg += '\\nContext:\\n' + '\\n'.join('  {0} = {1!r}'.format(k, v) for (k, v) in kwargs.items())\n        raise AnsibleConnectionFailure(msg)",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "peekOfCode": "__metaclass__ = type\nfrom ansible.errors import AnsibleConnectionFailure\nfrom ansible.utils.display import Display\nfrom ansible_collections.community.docker.plugins.module_utils.common_api import (\n    AnsibleDockerClientBase,\n)\nfrom ansible_collections.community.docker.plugins.module_utils.util import (\n    DOCKER_COMMON_ARGS,\n)\nclass AnsibleDockerClient(AnsibleDockerClientBase):",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.common_api",
        "documentation": {}
    },
    {
        "label": "DockerSocketHandler",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "peekOfCode": "class DockerSocketHandler(DockerSocketHandlerBase):\n    def __init__(self, display, sock, log=None, container=None):\n        super(DockerSocketHandler, self).__init__(sock, selectors, log=lambda msg: display.vvvv(msg, host=container))",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "peekOfCode": "__metaclass__ = type\nfrom ansible_collections.community.docker.plugins.module_utils.selectors import selectors\nfrom ansible_collections.community.docker.plugins.module_utils.socket_handler import (\n    DockerSocketHandlerBase,\n)\nclass DockerSocketHandler(DockerSocketHandlerBase):\n    def __init__(self, display, sock, log=None, container=None):\n        super(DockerSocketHandler, self).__init__(sock, selectors, log=lambda msg: display.vvvv(msg, host=container))",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.socket_handler",
        "documentation": {}
    },
    {
        "label": "make_unsafe",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "peekOfCode": "def make_unsafe(value):\n    if value is None or isinstance(value, AnsibleUnsafe):\n        return value\n    if isinstance(value, Mapping):\n        return dict((make_unsafe(key), make_unsafe(val)) for key, val in value.items())\n    elif isinstance(value, Set):\n        return set(make_unsafe(elt) for elt in value)\n    elif is_sequence(value):\n        return type(value)(make_unsafe(elt) for elt in value)\n    elif isinstance(value, binary_type):",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "peekOfCode": "__metaclass__ = type\nimport re\nfrom ansible.module_utils.six import binary_type, text_type\nfrom ansible.module_utils.common._collections_compat import Mapping, Set\nfrom ansible.module_utils.common.collections import is_sequence\nfrom ansible.utils.unsafe_proxy import (\n    AnsibleUnsafe,\n    wrap_var as _make_unsafe,\n)\n_RE_TEMPLATE_CHARS = re.compile(u'[{}]')",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "_RE_TEMPLATE_CHARS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "peekOfCode": "_RE_TEMPLATE_CHARS = re.compile(u'[{}]')\n_RE_TEMPLATE_CHARS_BYTES = re.compile(b'[{}]')\ndef make_unsafe(value):\n    if value is None or isinstance(value, AnsibleUnsafe):\n        return value\n    if isinstance(value, Mapping):\n        return dict((make_unsafe(key), make_unsafe(val)) for key, val in value.items())\n    elif isinstance(value, Set):\n        return set(make_unsafe(elt) for elt in value)\n    elif is_sequence(value):",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "_RE_TEMPLATE_CHARS_BYTES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "description": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "peekOfCode": "_RE_TEMPLATE_CHARS_BYTES = re.compile(b'[{}]')\ndef make_unsafe(value):\n    if value is None or isinstance(value, AnsibleUnsafe):\n        return value\n    if isinstance(value, Mapping):\n        return dict((make_unsafe(key), make_unsafe(val)) for key, val in value.items())\n    elif isinstance(value, Set):\n        return set(make_unsafe(elt) for elt in value)\n    elif is_sequence(value):\n        return type(value)(make_unsafe(elt) for elt in value)",
        "detail": "collections.ansible_collections.community.docker.plugins.plugin_utils.unsafe",
        "documentation": {}
    },
    {
        "label": "FilterModule",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.integration.targets.docker_container.filter_plugins.ipaddr_tools",
        "description": "collections.ansible_collections.community.docker.tests.integration.targets.docker_container.filter_plugins.ipaddr_tools",
        "peekOfCode": "class FilterModule(object):\n    \"\"\" IP address and network manipulation filters \"\"\"\n    def filters(self):\n        return {\n            'normalize_ipaddr': _normalize_ipaddr,\n        }",
        "detail": "collections.ansible_collections.community.docker.tests.integration.targets.docker_container.filter_plugins.ipaddr_tools",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.integration.targets.docker_container.filter_plugins.ipaddr_tools",
        "description": "collections.ansible_collections.community.docker.tests.integration.targets.docker_container.filter_plugins.ipaddr_tools",
        "peekOfCode": "__metaclass__ = type\ndef _normalize_ipaddr(ipaddr):\n    # Import when needed, to allow installation of that module in the test setup\n    import ipaddress\n    return ipaddress.ip_address(ipaddr).compressed\nclass FilterModule(object):\n    \"\"\" IP address and network manipulation filters \"\"\"\n    def filters(self):\n        return {\n            'normalize_ipaddr': _normalize_ipaddr,",
        "detail": "collections.ansible_collections.community.docker.tests.integration.targets.docker_container.filter_plugins.ipaddr_tools",
        "documentation": {}
    },
    {
        "label": "FilterModule",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "description": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "peekOfCode": "class FilterModule:\n    def filters(self):\n        return {\n            'sanitize_host_info': sanitize_host_info,\n        }",
        "detail": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "documentation": {}
    },
    {
        "label": "sanitize_host_info",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "description": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "peekOfCode": "def sanitize_host_info(data):\n    data = data.copy()\n    for key in ('SystemTime', 'NFd', 'NGoroutines', ):\n        data.pop(key, None)\n    return data\nclass FilterModule:\n    def filters(self):\n        return {\n            'sanitize_host_info': sanitize_host_info,\n        }",
        "detail": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "description": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "peekOfCode": "__metaclass__ = type\ndef sanitize_host_info(data):\n    data = data.copy()\n    for key in ('SystemTime', 'NFd', 'NGoroutines', ):\n        data.pop(key, None)\n    return data\nclass FilterModule:\n    def filters(self):\n        return {\n            'sanitize_host_info': sanitize_host_info,",
        "detail": "collections.ansible_collections.community.docker.tests.integration.targets.generic_connection_tests.filter_plugins.filter_attr",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.action-group",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.action-group",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    # Load redirects\n    meta_runtime = 'meta/runtime.yml'\n    try:\n        with open(meta_runtime, 'rb') as f:\n            data = yaml.safe_load(f)\n        action_group = data['action_groups']['docker']\n    except Exception as exc:\n        print('%s: cannot load action group: %s' % (meta_runtime, exc))",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.action-group",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.action-group",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.action-group",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport yaml\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    # Load redirects\n    meta_runtime = 'meta/runtime.yml'\n    try:\n        with open(meta_runtime, 'rb') as f:\n            data = yaml.safe_load(f)",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.action-group",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.extra-docs",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.extra-docs",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    env = os.environ.copy()\n    suffix = ':{env}'.format(env=env[\"ANSIBLE_COLLECTIONS_PATH\"]) if 'ANSIBLE_COLLECTIONS_PATH' in env else ''\n    env['ANSIBLE_COLLECTIONS_PATH'] = '{root}{suffix}'.format(root=os.path.dirname(os.path.dirname(os.path.dirname(os.getcwd()))), suffix=suffix)\n    p = subprocess.run(\n        ['antsibull-docs', 'lint-collection-docs', '--plugin-docs', '--skip-rstcheck', '.'],\n        env=env,\n        check=False,\n    )",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.extra-docs",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.extra-docs",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.extra-docs",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport sys\nimport subprocess\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    env = os.environ.copy()\n    suffix = ':{env}'.format(env=env[\"ANSIBLE_COLLECTIONS_PATH\"]) if 'ANSIBLE_COLLECTIONS_PATH' in env else ''\n    env['ANSIBLE_COLLECTIONS_PATH'] = '{root}{suffix}'.format(root=os.path.dirname(os.path.dirname(os.path.dirname(os.getcwd()))), suffix=suffix)\n    p = subprocess.run(",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.extra-docs",
        "documentation": {}
    },
    {
        "label": "format_license_list",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "peekOfCode": "def format_license_list(licenses):\n    if not licenses:\n        return '(empty)'\n    return ', '.join(['\"%s\"' % license for license in licenses])\ndef find_licenses(filename, relax=False):\n    spdx_license_identifiers = []\n    other_license_identifiers = []\n    has_copyright = False\n    try:\n        with open(filename, 'r', encoding='utf-8') as f:",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "find_licenses",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "peekOfCode": "def find_licenses(filename, relax=False):\n    spdx_license_identifiers = []\n    other_license_identifiers = []\n    has_copyright = False\n    try:\n        with open(filename, 'r', encoding='utf-8') as f:\n            for line in f:\n                line = line.rstrip()\n                if 'Copyright ' in line:\n                    has_copyright = True",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n    # The following paths are allowed to have no license identifier\n    no_comments_allowed = [\n        'changelogs/fragments/*.yml',\n        'changelogs/fragments/*.yaml',\n    ]\n    # These files are completely ignored\n    ignore_paths = [",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport glob\nimport sys\ndef format_license_list(licenses):\n    if not licenses:\n        return '(empty)'\n    return ', '.join(['\"%s\"' % license for license in licenses])\ndef find_licenses(filename, relax=False):\n    spdx_license_identifiers = []",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.no-unwanted-files",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.no-unwanted-files",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n    allowed_extensions = (\n        '.cs',\n        '.ps1',\n        '.psm1',\n        '.py',\n    )\n    skip_paths = set([",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.no-unwanted-files",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.sanity.extra.no-unwanted-files",
        "description": "collections.ansible_collections.community.docker.tests.sanity.extra.no-unwanted-files",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport sys\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n    allowed_extensions = (\n        '.cs',\n        '.ps1',\n        '.psm1',",
        "detail": "collections.ansible_collections.community.docker.tests.sanity.extra.no-unwanted-files",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.compat.builtins",
        "description": "collections.ansible_collections.community.docker.tests.unit.compat.builtins",
        "peekOfCode": "__metaclass__ = type\n#\n# Compat for python2.7\n#\n# One unittest needs to import builtins via __import__() so we need to have\n# the string that represents it\ntry:\n    import __builtin__  # noqa: F401, pylint: disable=unused-import\nexcept ImportError:\n    BUILTINS = 'builtins'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.compat.builtins",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.compat.mock",
        "description": "collections.ansible_collections.community.docker.tests.unit.compat.mock",
        "peekOfCode": "__metaclass__ = type\n'''\nCompat module for Python3.x's unittest.mock module\n'''\nimport sys  # noqa: F401, pylint: disable=unused-import\n# Python 2.7\n# Note: Could use the pypi mock library on python3.x as well as python2.x.  It\n# is the same as the python3 stdlib mock library\ntry:\n    # Allow wildcard import because we really do want to import all of mock's",
        "detail": "collections.ansible_collections.community.docker.tests.unit.compat.mock",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.compat.unittest",
        "description": "collections.ansible_collections.community.docker.tests.unit.compat.unittest",
        "peekOfCode": "__metaclass__ = type\n'''\nCompat module for Python2.7's unittest module\n'''\nimport sys\n# Allow wildcard import because we really do want to import all of\n# unittests's symbols into this compat shim\n# pylint: disable=wildcard-import,unused-wildcard-import\nif sys.version_info < (2, 7):\n    try:",
        "detail": "collections.ansible_collections.community.docker.tests.unit.compat.unittest",
        "documentation": {}
    },
    {
        "label": "TestDockerConnectionClass",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.connection.test_docker",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.connection.test_docker",
        "peekOfCode": "class TestDockerConnectionClass(unittest.TestCase):\n    def setUp(self):\n        self.play_context = PlayContext()\n        self.play_context.prompt = (\n            '[sudo via ansible, key=ouzmdnewuhucvuaabtjmweasarviygqq] password: '\n        )\n        self.in_stream = StringIO()\n        with mock.patch('ansible_collections.community.docker.plugins.connection.docker.get_bin_path', return_value='docker'):\n            self.dc = connection_loader.get('community.docker.docker', self.play_context, self.in_stream)\n    def tearDown(self):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.connection.test_docker",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.connection.test_docker",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.connection.test_docker",
        "peekOfCode": "__metaclass__ = type\nfrom io import StringIO\nfrom ansible_collections.community.docker.tests.unit.compat import mock\nfrom ansible_collections.community.docker.tests.unit.compat import unittest\nfrom ansible.errors import AnsibleError\nfrom ansible.playbook.play_context import PlayContext\nfrom ansible.plugins.loader import connection_loader\nfrom ansible.module_utils.six import PY2\nclass TestDockerConnectionClass(unittest.TestCase):\n    def setUp(self):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.connection.test_docker",
        "documentation": {}
    },
    {
        "label": "FakeClient",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "class FakeClient(object):\n    def __init__(self, *hosts):\n        self.get_results = {}\n        list_reply = []\n        for host in hosts:\n            list_reply.append({\n                'Id': host['Id'],\n                'Names': [host['Name']] if host['Name'] else [],\n                'Image': host['Config']['Image'],\n                'ImageId': host['Image'],",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "templar",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def templar():\n    dataloader = create_autospec(DataLoader, instance=True)\n    return Templar(loader=dataloader)\n@pytest.fixture(scope=\"module\")\ndef inventory(templar):\n    r = InventoryModule()\n    r.inventory = InventoryData()\n    r.templar = templar\n    return r\nLOVING_THARP = {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "inventory",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def inventory(templar):\n    r = InventoryModule()\n    r.inventory = InventoryData()\n    r.templar = templar\n    return r\nLOVING_THARP = {\n    'Id': '7bd547963679e3209cafd52aff21840b755c96fd37abcd7a6e19da8da6a7f49a',\n    'Name': '/loving_tharp',\n    'Image': 'sha256:349f492ff18add678364a62a67ce9a13487f14293ae0af1baf02398aa432f385',\n    'State': {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "create_get_option",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def create_get_option(options, default=False):\n    def get_option(option):\n        if option in options:\n            return options[option]\n        return default\n    return get_option\nclass FakeClient(object):\n    def __init__(self, *hosts):\n        self.get_results = {}\n        list_reply = []",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "test_populate",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def test_populate(inventory, mocker):\n    client = FakeClient(LOVING_THARP)\n    inventory.get_option = mocker.MagicMock(side_effect=create_get_option({\n        'verbose_output': True,\n        'connection_type': 'docker-api',\n        'add_legacy_groups': False,\n        'compose': {},\n        'groups': {},\n        'keyed_groups': {},\n        'filters': None,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "test_populate_service",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def test_populate_service(inventory, mocker):\n    client = FakeClient(LOVING_THARP_SERVICE)\n    inventory.get_option = mocker.MagicMock(side_effect=create_get_option({\n        'verbose_output': False,\n        'connection_type': 'docker-cli',\n        'add_legacy_groups': True,\n        'compose': {},\n        'groups': {},\n        'keyed_groups': {},\n        'docker_host': 'unix://var/run/docker.sock',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "test_populate_stack",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def test_populate_stack(inventory, mocker):\n    client = FakeClient(LOVING_THARP_STACK)\n    inventory.get_option = mocker.MagicMock(side_effect=create_get_option({\n        'verbose_output': False,\n        'connection_type': 'ssh',\n        'add_legacy_groups': True,\n        'compose': {},\n        'groups': {},\n        'keyed_groups': {},\n        'docker_host': 'unix://var/run/docker.sock',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "test_populate_filter_none",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def test_populate_filter_none(inventory, mocker):\n    client = FakeClient(LOVING_THARP)\n    inventory.get_option = mocker.MagicMock(side_effect=create_get_option({\n        'verbose_output': True,\n        'connection_type': 'docker-api',\n        'add_legacy_groups': False,\n        'compose': {},\n        'groups': {},\n        'keyed_groups': {},\n        'filters': [",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "test_populate_filter",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "def test_populate_filter(inventory, mocker):\n    client = FakeClient(LOVING_THARP)\n    inventory.get_option = mocker.MagicMock(side_effect=create_get_option({\n        'verbose_output': True,\n        'connection_type': 'docker-api',\n        'add_legacy_groups': False,\n        'compose': {},\n        'groups': {},\n        'keyed_groups': {},\n        'filters': [",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible.inventory.data import InventoryData\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.template import Templar\nfrom ansible_collections.community.docker.plugins.inventory.docker_containers import InventoryModule\nfrom ansible_collections.community.docker.tests.unit.compat.mock import create_autospec\n@pytest.fixture(scope=\"module\")\ndef templar():\n    dataloader = create_autospec(DataLoader, instance=True)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "LOVING_THARP",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "LOVING_THARP = {\n    'Id': '7bd547963679e3209cafd52aff21840b755c96fd37abcd7a6e19da8da6a7f49a',\n    'Name': '/loving_tharp',\n    'Image': 'sha256:349f492ff18add678364a62a67ce9a13487f14293ae0af1baf02398aa432f385',\n    'State': {\n        'Running': True,\n    },\n    'Config': {\n        'Image': 'quay.io/ansible/ubuntu1804-test-container:1.21.0',\n    },",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "LOVING_THARP_STACK",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "LOVING_THARP_STACK = {\n    'Id': '7bd547963679e3209cafd52aff21840b755c96fd37abcd7a6e19da8da6a7f49a',\n    'Name': '/loving_tharp',\n    'Image': 'sha256:349f492ff18add678364a62a67ce9a13487f14293ae0af1baf02398aa432f385',\n    'State': {\n        'Running': True,\n    },\n    'Config': {\n        'Image': 'quay.io/ansible/ubuntu1804-test-container:1.21.0',\n        'Labels': {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "LOVING_THARP_SERVICE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "peekOfCode": "LOVING_THARP_SERVICE = {\n    'Id': '7bd547963679e3209cafd52aff21840b755c96fd37abcd7a6e19da8da6a7f49a',\n    'Name': '/loving_tharp',\n    'Image': 'sha256:349f492ff18add678364a62a67ce9a13487f14293ae0af1baf02398aa432f385',\n    'State': {\n        'Running': True,\n    },\n    'Config': {\n        'Image': 'quay.io/ansible/ubuntu1804-test-container:1.21.0',\n        'Labels': {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.inventory.test_docker_containers",
        "documentation": {}
    },
    {
        "label": "BaseAPIClientTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "class BaseAPIClientTest(unittest.TestCase):\n    def setUp(self):\n        self.patcher = mock.patch.multiple(\n            'ansible_collections.community.docker.plugins.module_utils._api.api.client.APIClient',\n            get=fake_get,\n            post=fake_post,\n            put=fake_put,\n            delete=fake_delete,\n            _read_from_socket=fake_read_from_socket\n        )",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "DockerApiTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "class DockerApiTest(BaseAPIClientTest):\n    def test_ctor(self):\n        with pytest.raises(errors.DockerException) as excinfo:\n            APIClient(version=1.12)\n        assert str(\n            excinfo.value\n        ) == 'Version parameter must be a string or None. Found float'\n    def test_url_valid_resource(self):\n        url = self.client._url('/hello/{0}/world', 'somename')\n        assert url == '{0}{1}'.format(url_prefix, 'hello/somename/world')",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "UnixSocketStreamTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "class UnixSocketStreamTest(unittest.TestCase):\n    def setUp(self):\n        socket_dir = tempfile.mkdtemp()\n        self.build_context = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, socket_dir)\n        self.addCleanup(shutil.rmtree, self.build_context)\n        self.socket_file = os.path.join(socket_dir, 'test_sock.sock')\n        self.server_socket = self._setup_socket()\n        self.stop_server = False\n        server_thread = threading.Thread(target=self.run_server)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "TCPSocketStreamTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "class TCPSocketStreamTest(unittest.TestCase):\n    stdout_data = b'''\n    Now, those children out there, they're jumping through the\n    flames in the hope that the god of the fire will make them fruitful.\n    Really, you can't blame them. After all, what girl would not prefer the\n    child of a god to that of some acne-scarred artisan?\n    '''\n    stderr_data = b'''\n    And what of the true God? To whose glory churches and monasteries have been\n    built on these islands for generations past? Now shall what of Him?",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "UserAgentTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "class UserAgentTest(unittest.TestCase):\n    def setUp(self):\n        self.patcher = mock.patch.object(\n            APIClient,\n            'send',\n            return_value=fake_resp(\"GET\", \"%s/version\" % fake_api.prefix)\n        )\n        self.mock_send = self.patcher.start()\n    def tearDown(self):\n        self.patcher.stop()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "DisableSocketTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "class DisableSocketTest(unittest.TestCase):\n    class DummySocket:\n        def __init__(self, timeout=60):\n            self.timeout = timeout\n        def settimeout(self, timeout):\n            self.timeout = timeout\n        def gettimeout(self):\n            return self.timeout\n    def setUp(self):\n        self.client = APIClient(version=DEFAULT_DOCKER_API_VERSION)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def response(status_code=200, content='', headers=None, reason=None, elapsed=0,\n             request=None, raw=None):\n    res = requests.Response()\n    res.status_code = status_code\n    if not isinstance(content, six.binary_type):\n        content = json.dumps(content).encode('ascii')\n    res._content = content\n    res.headers = requests.structures.CaseInsensitiveDict(headers or {})\n    res.reason = reason\n    res.elapsed = datetime.timedelta(elapsed)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_resolve_authconfig",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_resolve_authconfig(authconfig, registry=None, *args, **kwargs):\n    return None\ndef fake_inspect_container(self, container, tty=False):\n    return fake_api.get_fake_inspect_container(tty=tty)[1]\ndef fake_resp(method, url, *args, **kwargs):\n    key = None\n    if url in fake_api.fake_responses:\n        key = url\n    elif (url, method) in fake_api.fake_responses:\n        key = (url, method)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_inspect_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_inspect_container(self, container, tty=False):\n    return fake_api.get_fake_inspect_container(tty=tty)[1]\ndef fake_resp(method, url, *args, **kwargs):\n    key = None\n    if url in fake_api.fake_responses:\n        key = url\n    elif (url, method) in fake_api.fake_responses:\n        key = (url, method)\n    if not key:\n        raise Exception('{method} {url}'.format(method=method, url=url))",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_resp",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_resp(method, url, *args, **kwargs):\n    key = None\n    if url in fake_api.fake_responses:\n        key = url\n    elif (url, method) in fake_api.fake_responses:\n        key = (url, method)\n    if not key:\n        raise Exception('{method} {url}'.format(method=method, url=url))\n    status_code, content = fake_api.fake_responses[key]()\n    return response(status_code=status_code, content=content)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_get",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_get(self, url, *args, **kwargs):\n    return fake_request('GET', url, *args, **kwargs)\ndef fake_post(self, url, *args, **kwargs):\n    return fake_request('POST', url, *args, **kwargs)\ndef fake_put(self, url, *args, **kwargs):\n    return fake_request('PUT', url, *args, **kwargs)\ndef fake_delete(self, url, *args, **kwargs):\n    return fake_request('DELETE', url, *args, **kwargs)\ndef fake_read_from_socket(self, response, stream, tty=False, demux=False):\n    return six.binary_type()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_post",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_post(self, url, *args, **kwargs):\n    return fake_request('POST', url, *args, **kwargs)\ndef fake_put(self, url, *args, **kwargs):\n    return fake_request('PUT', url, *args, **kwargs)\ndef fake_delete(self, url, *args, **kwargs):\n    return fake_request('DELETE', url, *args, **kwargs)\ndef fake_read_from_socket(self, response, stream, tty=False, demux=False):\n    return six.binary_type()\nurl_base = '{prefix}/'.format(prefix=fake_api.prefix)\nurl_prefix = '{0}v{1}/'.format(",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_put",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_put(self, url, *args, **kwargs):\n    return fake_request('PUT', url, *args, **kwargs)\ndef fake_delete(self, url, *args, **kwargs):\n    return fake_request('DELETE', url, *args, **kwargs)\ndef fake_read_from_socket(self, response, stream, tty=False, demux=False):\n    return six.binary_type()\nurl_base = '{prefix}/'.format(prefix=fake_api.prefix)\nurl_prefix = '{0}v{1}/'.format(\n    url_base,\n    constants.DEFAULT_DOCKER_API_VERSION)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_delete",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_delete(self, url, *args, **kwargs):\n    return fake_request('DELETE', url, *args, **kwargs)\ndef fake_read_from_socket(self, response, stream, tty=False, demux=False):\n    return six.binary_type()\nurl_base = '{prefix}/'.format(prefix=fake_api.prefix)\nurl_prefix = '{0}v{1}/'.format(\n    url_base,\n    constants.DEFAULT_DOCKER_API_VERSION)\nclass BaseAPIClientTest(unittest.TestCase):\n    def setUp(self):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_read_from_socket",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "def fake_read_from_socket(self, response, stream, tty=False, demux=False):\n    return six.binary_type()\nurl_base = '{prefix}/'.format(prefix=fake_api.prefix)\nurl_prefix = '{0}v{1}/'.format(\n    url_base,\n    constants.DEFAULT_DOCKER_API_VERSION)\nclass BaseAPIClientTest(unittest.TestCase):\n    def setUp(self):\n        self.patcher = mock.patch.multiple(\n            'ansible_collections.community.docker.plugins.module_utils._api.api.client.APIClient',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "__metaclass__ = type\nimport datetime\nimport io\nimport json\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport tempfile",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUT_SECONDS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "DEFAULT_TIMEOUT_SECONDS = constants.DEFAULT_TIMEOUT_SECONDS\ndef response(status_code=200, content='', headers=None, reason=None, elapsed=0,\n             request=None, raw=None):\n    res = requests.Response()\n    res.status_code = status_code\n    if not isinstance(content, six.binary_type):\n        content = json.dumps(content).encode('ascii')\n    res._content = content\n    res.headers = requests.structures.CaseInsensitiveDict(headers or {})\n    res.reason = reason",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "fake_request",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "fake_request = mock.Mock(side_effect=fake_resp)\ndef fake_get(self, url, *args, **kwargs):\n    return fake_request('GET', url, *args, **kwargs)\ndef fake_post(self, url, *args, **kwargs):\n    return fake_request('POST', url, *args, **kwargs)\ndef fake_put(self, url, *args, **kwargs):\n    return fake_request('PUT', url, *args, **kwargs)\ndef fake_delete(self, url, *args, **kwargs):\n    return fake_request('DELETE', url, *args, **kwargs)\ndef fake_read_from_socket(self, response, stream, tty=False, demux=False):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "url_base",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "url_base = '{prefix}/'.format(prefix=fake_api.prefix)\nurl_prefix = '{0}v{1}/'.format(\n    url_base,\n    constants.DEFAULT_DOCKER_API_VERSION)\nclass BaseAPIClientTest(unittest.TestCase):\n    def setUp(self):\n        self.patcher = mock.patch.multiple(\n            'ansible_collections.community.docker.plugins.module_utils._api.api.client.APIClient',\n            get=fake_get,\n            post=fake_post,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "url_prefix",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "peekOfCode": "url_prefix = '{0}v{1}/'.format(\n    url_base,\n    constants.DEFAULT_DOCKER_API_VERSION)\nclass BaseAPIClientTest(unittest.TestCase):\n    def setUp(self):\n        self.patcher = mock.patch.multiple(\n            'ansible_collections.community.docker.plugins.module_utils._api.api.client.APIClient',\n            get=fake_get,\n            post=fake_post,\n            put=fake_put,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.api.test_client",
        "documentation": {}
    },
    {
        "label": "SSHAdapterTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_sshconn",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_sshconn",
        "peekOfCode": "class SSHAdapterTest(unittest.TestCase):\n    @staticmethod\n    def test_ssh_hostname_prefix_trim():\n        conn = SSHHTTPAdapter(\n            base_url=\"ssh://user@hostname:1234\", shell_out=True)\n        assert conn.ssh_host == \"user@hostname:1234\"\n    @staticmethod\n    def test_ssh_parse_url():\n        c = SSHSocket(host=\"user@hostname:1234\")\n        assert c.host == \"hostname\"",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_sshconn",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_sshconn",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_sshconn",
        "peekOfCode": "__metaclass__ = type\nimport unittest\nimport sys\nimport pytest\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')\nfrom ansible_collections.community.docker.plugins.module_utils._api.transport.sshconn import SSHSocket, SSHHTTPAdapter\nclass SSHAdapterTest(unittest.TestCase):\n    @staticmethod\n    def test_ssh_hostname_prefix_trim():",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_sshconn",
        "documentation": {}
    },
    {
        "label": "SSLAdapterTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "peekOfCode": "class SSLAdapterTest(unittest.TestCase):\n    def test_only_uses_tls(self):\n        ssl_context = ssladapter.urllib3.util.ssl_.create_urllib3_context()\n        assert ssl_context.options & OP_NO_SSLv3\n        # if OpenSSL is compiled without SSL2 support, OP_NO_SSLv2 will be 0\n        assert not bool(OP_NO_SSLv2) or ssl_context.options & OP_NO_SSLv2\n        assert not ssl_context.options & OP_NO_TLSv1\n@pytest.mark.skipif(not HAS_MATCH_HOSTNAME, reason='match_hostname is not available')\nclass MatchHostnameTest(unittest.TestCase):\n    cert = {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "documentation": {}
    },
    {
        "label": "MatchHostnameTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "peekOfCode": "class MatchHostnameTest(unittest.TestCase):\n    cert = {\n        'issuer': (\n            (('countryName', 'US'),),\n            (('stateOrProvinceName', 'California'),),\n            (('localityName', 'San Francisco'),),\n            (('organizationName', 'Docker Inc'),),\n            (('organizationalUnitName', 'Docker-Python'),),\n            (('commonName', 'localhost'),),\n            (('emailAddress', 'info@docker.com'),)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "peekOfCode": "__metaclass__ = type\nimport unittest\nimport sys\nimport pytest\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')\nfrom ansible_collections.community.docker.plugins.module_utils._api.transport import ssladapter\nHAS_MATCH_HOSTNAME = True\ntry:\n    from backports.ssl_match_hostname import (",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "documentation": {}
    },
    {
        "label": "HAS_MATCH_HOSTNAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "peekOfCode": "HAS_MATCH_HOSTNAME = True\ntry:\n    from backports.ssl_match_hostname import (\n        match_hostname, CertificateError\n    )\nexcept ImportError:\n    try:\n        from ssl import (\n            match_hostname, CertificateError\n        )",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.transport.test_ssladapter",
        "documentation": {}
    },
    {
        "label": "ExcludePathsTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "peekOfCode": "class ExcludePathsTest(unittest.TestCase):\n    dirs = [\n        'foo',\n        'foo/bar',\n        'bar',\n        'target',\n        'target/subdir',\n        'subdir',\n        'subdir/target',\n        'subdir/target/subdir',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "documentation": {}
    },
    {
        "label": "TarTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "peekOfCode": "class TarTest(unittest.TestCase):\n    def test_tar_with_excludes(self):\n        dirs = [\n            'foo',\n            'foo/bar',\n            'bar',\n        ]\n        files = [\n            'Dockerfile',\n            'Dockerfile.alt',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "documentation": {}
    },
    {
        "label": "make_tree",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "peekOfCode": "def make_tree(dirs, files):\n    base = tempfile.mkdtemp()\n    for path in dirs:\n        os.makedirs(os.path.join(base, path))\n    for path in files:\n        with open(os.path.join(base, path), 'w') as f:\n            f.write(\"content\")\n    return base\ndef convert_paths(collection):\n    return set(map(convert_path, collection))",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "documentation": {}
    },
    {
        "label": "convert_paths",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "peekOfCode": "def convert_paths(collection):\n    return set(map(convert_path, collection))\ndef convert_path(path):\n    return path.replace('/', os.path.sep)\nclass ExcludePathsTest(unittest.TestCase):\n    dirs = [\n        'foo',\n        'foo/bar',\n        'bar',\n        'target',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "documentation": {}
    },
    {
        "label": "convert_path",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "peekOfCode": "def convert_path(path):\n    return path.replace('/', os.path.sep)\nclass ExcludePathsTest(unittest.TestCase):\n    dirs = [\n        'foo',\n        'foo/bar',\n        'bar',\n        'target',\n        'target/subdir',\n        'subdir',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport os.path\nimport shutil\nimport socket\nimport tarfile\nimport tempfile\nimport unittest\nimport sys\nimport pytest",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_build",
        "documentation": {}
    },
    {
        "label": "FindConfigFileTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "peekOfCode": "class FindConfigFileTest(unittest.TestCase):\n    @fixture(autouse=True)\n    def tmpdir(self, tmpdir):\n        self.mkdir = tmpdir.mkdir\n    def test_find_config_fallback(self):\n        tmpdir = self.mkdir('test_find_config_fallback')\n        with mock.patch.dict(os.environ, {'HOME': str(tmpdir)}):\n            assert config.find_config_file() is None\n    def test_find_config_from_explicit_path(self):\n        tmpdir = self.mkdir('test_find_config_from_explicit_path')",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "documentation": {}
    },
    {
        "label": "LoadConfigTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "peekOfCode": "class LoadConfigTest(unittest.TestCase):\n    def test_load_config_no_file(self):\n        folder = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, folder)\n        cfg = config.load_general_config(folder)\n        assert cfg is not None\n        assert isinstance(cfg, dict)\n        assert not cfg\n    def test_load_config_custom_headers(self):\n        folder = tempfile.mkdtemp()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport unittest\nimport shutil\nimport tempfile\nimport json\nimport sys\nimport pytest\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_config",
        "documentation": {}
    },
    {
        "label": "DecoratorsTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_decorators",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_decorators",
        "peekOfCode": "class DecoratorsTest(unittest.TestCase):\n    def test_update_headers(self):\n        sample_headers = {\n            'X-Docker-Locale': 'en-US',\n        }\n        def f(self, headers=None):\n            return headers\n        client = APIClient(version=DEFAULT_DOCKER_API_VERSION)\n        client._general_configs = {}\n        g = update_headers(f)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_decorators",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_decorators",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_decorators",
        "peekOfCode": "__metaclass__ = type\nimport unittest\nimport sys\nimport pytest\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')\nfrom ansible_collections.community.docker.plugins.module_utils._api.api.client import APIClient\nfrom ansible_collections.community.docker.plugins.module_utils._api.constants import DEFAULT_DOCKER_API_VERSION\nfrom ansible_collections.community.docker.plugins.module_utils._api.utils.decorators import update_headers\nclass DecoratorsTest(unittest.TestCase):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_decorators",
        "documentation": {}
    },
    {
        "label": "TestJsonSplitter",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "peekOfCode": "class TestJsonSplitter:\n    def test_json_splitter_no_object(self):\n        data = '{\"foo\": \"bar'\n        assert json_splitter(data) is None\n    def test_json_splitter_with_object(self):\n        data = '{\"foo\": \"bar\"}\\n  \\n{\"next\": \"obj\"}'\n        assert json_splitter(data) == ({'foo': 'bar'}, '{\"next\": \"obj\"}')\n    def test_json_splitter_leading_whitespace(self):\n        data = '\\n   \\r{\"foo\": \"bar\"}\\n\\n   {\"next\": \"obj\"}'\n        assert json_splitter(data) == ({'foo': 'bar'}, '{\"next\": \"obj\"}')",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "documentation": {}
    },
    {
        "label": "TestStreamAsText",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "peekOfCode": "class TestStreamAsText:\n    def test_stream_with_non_utf_unicode_character(self):\n        stream = [b'\\xed\\xf3\\xf3']\n        output, = stream_as_text(stream)\n        assert output == u''\n    def test_stream_with_utf_character(self):\n        stream = [u''.encode('utf-8')]\n        output, = stream_as_text(stream)\n        assert output == u''\nclass TestJsonStream:",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "documentation": {}
    },
    {
        "label": "TestJsonStream",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "peekOfCode": "class TestJsonStream:\n    def test_with_falsy_entries(self):\n        stream = [\n            '{\"one\": \"two\"}\\n{}\\n',\n            \"[1, 2, 3]\\n[]\\n\",\n        ]\n        output = list(json_stream(stream))\n        assert output == [\n            {'one': 'two'},\n            {},",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "peekOfCode": "__metaclass__ = type\nimport sys\nimport pytest\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')\nfrom ansible_collections.community.docker.plugins.module_utils._api.utils.json_stream import json_splitter, stream_as_text, json_stream\nclass TestJsonSplitter:\n    def test_json_splitter_no_object(self):\n        data = '{\"foo\": \"bar'\n        assert json_splitter(data) is None",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_json_stream",
        "documentation": {}
    },
    {
        "label": "PortsTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_ports",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_ports",
        "peekOfCode": "class PortsTest(unittest.TestCase):\n    def test_split_port_with_host_ip(self):\n        internal_port, external_port = split_port(\"127.0.0.1:1000:2000\")\n        assert internal_port == [\"2000\"]\n        assert external_port == [(\"127.0.0.1\", \"1000\")]\n    def test_split_port_with_protocol(self):\n        for protocol in ['tcp', 'udp', 'sctp']:\n            internal_port, external_port = split_port(\n                \"127.0.0.1:1000:2000/\" + protocol\n            )",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_ports",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_ports",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_ports",
        "peekOfCode": "__metaclass__ = type\nimport unittest\nimport sys\nimport pytest\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')\nfrom ansible_collections.community.docker.plugins.module_utils._api.utils.ports import build_port_bindings, split_port\nclass PortsTest(unittest.TestCase):\n    def test_split_port_with_host_ip(self):\n        internal_port, external_port = split_port(\"127.0.0.1:1000:2000\")",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_ports",
        "documentation": {}
    },
    {
        "label": "ProxyConfigTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "class ProxyConfigTest(unittest.TestCase):\n    def test_from_dict(self):\n        config = ProxyConfig.from_dict({\n            'httpProxy': HTTP,\n            'httpsProxy': HTTPS,\n            'ftpProxy': FTP,\n            'noProxy': NO_PROXY\n        })\n        self.assertEqual(CONFIG.http, config.http)\n        self.assertEqual(CONFIG.https, config.https)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "__metaclass__ = type\nimport unittest\nimport sys\nimport pytest\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')\nfrom ansible_collections.community.docker.plugins.module_utils._api.utils.proxy import ProxyConfig\nHTTP = 'http://test:80'\nHTTPS = 'https://test:443'\nFTP = 'ftp://user:password@host:23'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "HTTP",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "HTTP = 'http://test:80'\nHTTPS = 'https://test:443'\nFTP = 'ftp://user:password@host:23'\nNO_PROXY = 'localhost,.localdomain'\nCONFIG = ProxyConfig(http=HTTP, https=HTTPS, ftp=FTP, no_proxy=NO_PROXY)\nENV = {\n    'http_proxy': HTTP,\n    'HTTP_PROXY': HTTP,\n    'https_proxy': HTTPS,\n    'HTTPS_PROXY': HTTPS,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "HTTPS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "HTTPS = 'https://test:443'\nFTP = 'ftp://user:password@host:23'\nNO_PROXY = 'localhost,.localdomain'\nCONFIG = ProxyConfig(http=HTTP, https=HTTPS, ftp=FTP, no_proxy=NO_PROXY)\nENV = {\n    'http_proxy': HTTP,\n    'HTTP_PROXY': HTTP,\n    'https_proxy': HTTPS,\n    'HTTPS_PROXY': HTTPS,\n    'ftp_proxy': FTP,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "FTP",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "FTP = 'ftp://user:password@host:23'\nNO_PROXY = 'localhost,.localdomain'\nCONFIG = ProxyConfig(http=HTTP, https=HTTPS, ftp=FTP, no_proxy=NO_PROXY)\nENV = {\n    'http_proxy': HTTP,\n    'HTTP_PROXY': HTTP,\n    'https_proxy': HTTPS,\n    'HTTPS_PROXY': HTTPS,\n    'ftp_proxy': FTP,\n    'FTP_PROXY': FTP,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "NO_PROXY",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "NO_PROXY = 'localhost,.localdomain'\nCONFIG = ProxyConfig(http=HTTP, https=HTTPS, ftp=FTP, no_proxy=NO_PROXY)\nENV = {\n    'http_proxy': HTTP,\n    'HTTP_PROXY': HTTP,\n    'https_proxy': HTTPS,\n    'HTTPS_PROXY': HTTPS,\n    'ftp_proxy': FTP,\n    'FTP_PROXY': FTP,\n    'no_proxy': NO_PROXY,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "CONFIG",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "CONFIG = ProxyConfig(http=HTTP, https=HTTPS, ftp=FTP, no_proxy=NO_PROXY)\nENV = {\n    'http_proxy': HTTP,\n    'HTTP_PROXY': HTTP,\n    'https_proxy': HTTPS,\n    'HTTPS_PROXY': HTTPS,\n    'ftp_proxy': FTP,\n    'FTP_PROXY': FTP,\n    'no_proxy': NO_PROXY,\n    'NO_PROXY': NO_PROXY,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "ENV",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "peekOfCode": "ENV = {\n    'http_proxy': HTTP,\n    'HTTP_PROXY': HTTP,\n    'https_proxy': HTTPS,\n    'HTTPS_PROXY': HTTPS,\n    'ftp_proxy': FTP,\n    'FTP_PROXY': FTP,\n    'no_proxy': NO_PROXY,\n    'NO_PROXY': NO_PROXY,\n}",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_proxy",
        "documentation": {}
    },
    {
        "label": "KwargsFromEnvTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class KwargsFromEnvTest(unittest.TestCase):\n    def setUp(self):\n        self.os_environ = os.environ.copy()\n    def tearDown(self):\n        os.environ = self.os_environ\n    def test_kwargs_from_env_empty(self):\n        os.environ.update(DOCKER_HOST='',\n                          DOCKER_CERT_PATH='')\n        os.environ.pop('DOCKER_TLS_VERIFY', None)\n        kwargs = kwargs_from_env()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "ConverVolumeBindsTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class ConverVolumeBindsTest(unittest.TestCase):\n    def test_convert_volume_binds_empty(self):\n        assert convert_volume_binds({}) == []\n        assert convert_volume_binds([]) == []\n    def test_convert_volume_binds_list(self):\n        data = ['/a:/a:ro', '/b:/c:z']\n        assert convert_volume_binds(data) == data\n    def test_convert_volume_binds_complete(self):\n        data = {\n            '/mnt/vol1': {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "ParseEnvFileTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class ParseEnvFileTest(unittest.TestCase):\n    def generate_tempfile(self, file_content=None):\n        \"\"\"\n        Generates a temporary file for tests with the content\n        of 'file_content' and returns the filename.\n        Don't forget to unlink the file with os.unlink() after.\n        \"\"\"\n        local_tempfile = tempfile.NamedTemporaryFile(delete=False)\n        local_tempfile.write(file_content.encode('UTF-8'))\n        local_tempfile.close()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "ParseHostTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class ParseHostTest(unittest.TestCase):\n    def test_parse_host(self):\n        invalid_hosts = [\n            '0.0.0.0',\n            'tcp://',\n            'udp://127.0.0.1',\n            'udp://127.0.0.1:2375',\n            'ssh://:22/path',\n            'tcp://netloc:3333/path?q=1',\n            'unix:///sock/path#fragment',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "ParseRepositoryTagTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class ParseRepositoryTagTest(unittest.TestCase):\n    sha = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n    def test_index_image_no_tag(self):\n        assert parse_repository_tag(\"root\") == (\"root\", None)\n    def test_index_image_tag(self):\n        assert parse_repository_tag(\"root:tag\") == (\"root\", \"tag\")\n    def test_index_user_image_no_tag(self):\n        assert parse_repository_tag(\"user/repo\") == (\"user/repo\", None)\n    def test_index_user_image_tag(self):\n        assert parse_repository_tag(\"user/repo:tag\") == (\"user/repo\", \"tag\")",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "ParseDeviceTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class ParseDeviceTest(unittest.TestCase):\n    def test_dict(self):\n        devices = parse_devices([{\n            'PathOnHost': '/dev/sda1',\n            'PathInContainer': '/dev/mnt1',\n            'CgroupPermissions': 'r'\n        }])\n        assert devices[0] == {\n            'PathOnHost': '/dev/sda1',\n            'PathInContainer': '/dev/mnt1',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "ParseBytesTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class ParseBytesTest(unittest.TestCase):\n    def test_parse_bytes_valid(self):\n        assert parse_bytes(\"512MB\") == 536870912\n        assert parse_bytes(\"512M\") == 536870912\n        assert parse_bytes(\"512m\") == 536870912\n    def test_parse_bytes_invalid(self):\n        with pytest.raises(DockerException):\n            parse_bytes(\"512MK\")\n        with pytest.raises(DockerException):\n            parse_bytes(\"512L\")",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "UtilsTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class UtilsTest(unittest.TestCase):\n    longMessage = True\n    def test_convert_filters(self):\n        tests = [\n            ({'dangling': True}, '{\"dangling\": [\"true\"]}'),\n            ({'dangling': \"true\"}, '{\"dangling\": [\"true\"]}'),\n            ({'exited': 0}, '{\"exited\": [\"0\"]}'),\n            ({'exited': [0, 1]}, '{\"exited\": [\"0\", \"1\"]}'),\n        ]\n        for filters, expected in tests:",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "SplitCommandTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class SplitCommandTest(unittest.TestCase):\n    def test_split_command_with_unicode(self):\n        assert split_command(u'echo ') == ['echo', '']\n    @pytest.mark.skipif(PY3, reason=\"shlex doesn't support bytes in py3\")\n    def test_split_command_with_bytes(self):\n        assert split_command('echo ') == ['echo', '']\nclass FormatEnvironmentTest(unittest.TestCase):\n    def test_format_env_binary_unicode_value(self):\n        env_dict = {\n            'ARTIST_NAME': b'\\xec\\x86\\xa1\\xec\\xa7\\x80\\xec\\x9d\\x80'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "FormatEnvironmentTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "class FormatEnvironmentTest(unittest.TestCase):\n    def test_format_env_binary_unicode_value(self):\n        env_dict = {\n            'ARTIST_NAME': b'\\xec\\x86\\xa1\\xec\\xa7\\x80\\xec\\x9d\\x80'\n        }\n        assert format_environment(env_dict) == [u'ARTIST_NAME=']\n    def test_format_env_no_value(self):\n        env_dict = {\n            'FOO': None,\n            'BAR': '',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "__metaclass__ = type\nimport base64\nimport json\nimport os\nimport os.path\nimport shutil\nimport tempfile\nimport unittest\nimport sys\nfrom ansible.module_utils.six import PY3",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "TEST_CERT_DIR",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "peekOfCode": "TEST_CERT_DIR = os.path.join(\n    os.path.dirname(__file__),\n    'testdata/certs',\n)\nclass KwargsFromEnvTest(unittest.TestCase):\n    def setUp(self):\n        self.os_environ = os.environ.copy()\n    def tearDown(self):\n        os.environ = self.os_environ\n    def test_kwargs_from_env_empty(self):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.utils.test_utils",
        "documentation": {}
    },
    {
        "label": "get_fake_version",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_version():\n    status_code = 200\n    response = {\n        'ApiVersion': '1.35',\n        'Arch': 'amd64',\n        'BuildTime': '2018-01-10T20:09:37.000000000+00:00',\n        'Components': [{\n            'Details': {\n                'ApiVersion': '1.35',\n                'Arch': 'amd64',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_info",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_info():\n    status_code = 200\n    response = {'Containers': 1, 'Images': 1, 'Debug': False,\n                'MemoryLimit': False, 'SwapLimit': False,\n                'IPv4Forwarding': True}\n    return status_code, response\ndef post_fake_auth():\n    status_code = 200\n    response = {'Status': 'Login Succeeded',\n                'IdentityToken': '9cbaf023786cd7'}",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_auth",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_auth():\n    status_code = 200\n    response = {'Status': 'Login Succeeded',\n                'IdentityToken': '9cbaf023786cd7'}\n    return status_code, response\ndef get_fake_ping():\n    return 200, \"OK\"\ndef get_fake_search():\n    status_code = 200\n    response = [{'Name': 'busybox', 'Description': 'Fake Description'}]",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_ping",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_ping():\n    return 200, \"OK\"\ndef get_fake_search():\n    status_code = 200\n    response = [{'Name': 'busybox', 'Description': 'Fake Description'}]\n    return status_code, response\ndef get_fake_images():\n    status_code = 200\n    response = [{\n        'Id': FAKE_IMAGE_ID,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_search",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_search():\n    status_code = 200\n    response = [{'Name': 'busybox', 'Description': 'Fake Description'}]\n    return status_code, response\ndef get_fake_images():\n    status_code = 200\n    response = [{\n        'Id': FAKE_IMAGE_ID,\n        'Created': '2 days ago',\n        'Repository': 'busybox',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_images",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_images():\n    status_code = 200\n    response = [{\n        'Id': FAKE_IMAGE_ID,\n        'Created': '2 days ago',\n        'Repository': 'busybox',\n        'RepoTags': ['busybox:latest', 'busybox:1.0'],\n    }]\n    return status_code, response\ndef get_fake_image_history():",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_image_history",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_image_history():\n    status_code = 200\n    response = [\n        {\n            \"Id\": \"b750fe79269d\",\n            \"Created\": 1364102658,\n            \"CreatedBy\": \"/bin/bash\"\n        },\n        {\n            \"Id\": \"27cf78414709\",",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_import_image",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_import_image():\n    status_code = 200\n    response = 'Import messages...'\n    return status_code, response\ndef get_fake_containers():\n    status_code = 200\n    response = [{\n        'Id': FAKE_CONTAINER_ID,\n        'Image': 'busybox:latest',\n        'Created': '2 days ago',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_containers",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_containers():\n    status_code = 200\n    response = [{\n        'Id': FAKE_CONTAINER_ID,\n        'Image': 'busybox:latest',\n        'Created': '2 days ago',\n        'Command': 'true',\n        'Status': 'fake status'\n    }]\n    return status_code, response",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_start_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_start_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_resize_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_create_container():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_resize_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_resize_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_create_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef get_fake_inspect_container(tty=False):\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_create_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_create_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef get_fake_inspect_container(tty=False):\n    status_code = 200\n    response = {\n        'Id': FAKE_CONTAINER_ID,\n        'Config': {'Labels': {'foo': 'bar'}, 'Privileged': True, 'Tty': tty},\n        'ID': FAKE_CONTAINER_ID,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_inspect_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_inspect_container(tty=False):\n    status_code = 200\n    response = {\n        'Id': FAKE_CONTAINER_ID,\n        'Config': {'Labels': {'foo': 'bar'}, 'Privileged': True, 'Tty': tty},\n        'ID': FAKE_CONTAINER_ID,\n        'Image': 'busybox:latest',\n        'Name': 'foobar',\n        \"State\": {\n            \"Status\": \"running\",",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_inspect_image",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_inspect_image():\n    status_code = 200\n    response = {\n        'Id': FAKE_IMAGE_ID,\n        'Parent': \"27cf784147099545\",\n        'Created': \"2013-03-23T22:24:18.818426-07:00\",\n        'Container': FAKE_CONTAINER_ID,\n        'Config': {'Labels': {'bar': 'foo'}},\n        'ContainerConfig':\n        {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_insert_image",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_insert_image():\n    status_code = 200\n    response = {'StatusCode': 0}\n    return status_code, response\ndef get_fake_wait():\n    status_code = 200\n    response = {'StatusCode': 0}\n    return status_code, response\ndef get_fake_logs():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_wait",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_wait():\n    status_code = 200\n    response = {'StatusCode': 0}\n    return status_code, response\ndef get_fake_logs():\n    status_code = 200\n    response = (b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n                b'\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x11Flowering Nights\\n'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x10(Sakuya Iyazoi)\\n')",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_logs",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_logs():\n    status_code = 200\n    response = (b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n                b'\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x11Flowering Nights\\n'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x10(Sakuya Iyazoi)\\n')\n    return status_code, response\ndef get_fake_diff():\n    status_code = 200\n    response = [{'Path': '/test', 'Kind': 1}]",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_diff",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_diff():\n    status_code = 200\n    response = [{'Path': '/test', 'Kind': 1}]\n    return status_code, response\ndef get_fake_events():\n    status_code = 200\n    response = [{'status': 'stop', 'id': FAKE_CONTAINER_ID,\n                 'from': FAKE_IMAGE_ID, 'time': 1423247867}]\n    return status_code, response\ndef get_fake_export():",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_events",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_events():\n    status_code = 200\n    response = [{'status': 'stop', 'id': FAKE_CONTAINER_ID,\n                 'from': FAKE_IMAGE_ID, 'time': 1423247867}]\n    return status_code, response\ndef get_fake_export():\n    status_code = 200\n    response = 'Byte Stream....'\n    return status_code, response\ndef post_fake_exec_create():",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_export",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_export():\n    status_code = 200\n    response = 'Byte Stream....'\n    return status_code, response\ndef post_fake_exec_create():\n    status_code = 200\n    response = {'Id': FAKE_EXEC_ID}\n    return status_code, response\ndef post_fake_exec_start():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_exec_create",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_exec_create():\n    status_code = 200\n    response = {'Id': FAKE_EXEC_ID}\n    return status_code, response\ndef post_fake_exec_start():\n    status_code = 200\n    response = (b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x11bin\\nboot\\ndev\\netc\\n'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x12lib\\nmnt\\nproc\\nroot\\n'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x0csbin\\nusr\\nvar\\n')\n    return status_code, response",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_exec_start",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_exec_start():\n    status_code = 200\n    response = (b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x11bin\\nboot\\ndev\\netc\\n'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x12lib\\nmnt\\nproc\\nroot\\n'\n                b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x0csbin\\nusr\\nvar\\n')\n    return status_code, response\ndef post_fake_exec_resize():\n    status_code = 201\n    return status_code, ''\ndef get_fake_exec_inspect():",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_exec_resize",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_exec_resize():\n    status_code = 201\n    return status_code, ''\ndef get_fake_exec_inspect():\n    return 200, {\n        'OpenStderr': True,\n        'OpenStdout': True,\n        'Container': get_fake_inspect_container()[1],\n        'Running': False,\n        'ProcessConfig': {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_exec_inspect",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_exec_inspect():\n    return 200, {\n        'OpenStderr': True,\n        'OpenStdout': True,\n        'Container': get_fake_inspect_container()[1],\n        'Running': False,\n        'ProcessConfig': {\n            'arguments': ['hello world'],\n            'tty': False,\n            'entrypoint': 'echo',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_stop_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_stop_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_kill_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_pause_container():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_kill_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_kill_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_pause_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_unpause_container():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_pause_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_pause_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_unpause_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_restart_container():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_unpause_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_unpause_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_restart_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_rename_container():\n    status_code = 204",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_restart_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_restart_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_rename_container():\n    status_code = 204\n    return status_code, None\ndef delete_fake_remove_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_rename_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_rename_container():\n    status_code = 204\n    return status_code, None\ndef delete_fake_remove_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_image_create():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "delete_fake_remove_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def delete_fake_remove_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_image_create():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef delete_fake_remove_image():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_image_create",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_image_create():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef delete_fake_remove_image():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef get_fake_get_image():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "delete_fake_remove_image",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def delete_fake_remove_image():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef get_fake_get_image():\n    status_code = 200\n    response = 'Byte Stream....'\n    return status_code, response\ndef post_fake_load_image():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_get_image",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_get_image():\n    status_code = 200\n    response = 'Byte Stream....'\n    return status_code, response\ndef post_fake_load_image():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef post_fake_commit():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_load_image",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_load_image():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef post_fake_commit():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_push():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_commit",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_commit():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_push():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef post_fake_build_container():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_push",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_push():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef post_fake_build_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_tag_image():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_build_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_build_container():\n    status_code = 200\n    response = {'Id': FAKE_CONTAINER_ID}\n    return status_code, response\ndef post_fake_tag_image():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef get_fake_stats():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_tag_image",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_tag_image():\n    status_code = 200\n    response = {'Id': FAKE_IMAGE_ID}\n    return status_code, response\ndef get_fake_stats():\n    status_code = 200\n    response = fake_stat.OBJ\n    return status_code, response\ndef get_fake_top():\n    return 200, {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_stats",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_stats():\n    status_code = 200\n    response = fake_stat.OBJ\n    return status_code, response\ndef get_fake_top():\n    return 200, {\n        'Processes': [\n            [\n                'root',\n                '26501',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_top",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_top():\n    return 200, {\n        'Processes': [\n            [\n                'root',\n                '26501',\n                '6907',\n                '0',\n                '10:32',\n                'pts/55',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_volume_list",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_volume_list():\n    status_code = 200\n    response = {\n        'Volumes': [\n            {\n                'Name': 'perfectcherryblossom',\n                'Driver': 'local',\n                'Mountpoint': '/var/lib/docker/volumes/perfectcherryblossom',\n                'Scope': 'local'\n            }, {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_volume",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_volume():\n    status_code = 200\n    response = {\n        'Name': 'perfectcherryblossom',\n        'Driver': 'local',\n        'Mountpoint': '/var/lib/docker/volumes/perfectcherryblossom',\n        'Labels': {\n            'com.example.some-label': 'some-value'\n        },\n        'Scope': 'local'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "fake_remove_volume",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def fake_remove_volume():\n    return 204, None\ndef post_fake_update_container():\n    return 200, {'Warnings': []}\ndef post_fake_update_node():\n    return 200, None\ndef post_fake_join_swarm():\n    return 200, None\ndef get_fake_network_list():\n    return 200, [{",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_update_container",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_update_container():\n    return 200, {'Warnings': []}\ndef post_fake_update_node():\n    return 200, None\ndef post_fake_join_swarm():\n    return 200, None\ndef get_fake_network_list():\n    return 200, [{\n        \"Name\": \"bridge\",\n        \"Id\": FAKE_NETWORK_ID,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_update_node",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_update_node():\n    return 200, None\ndef post_fake_join_swarm():\n    return 200, None\ndef get_fake_network_list():\n    return 200, [{\n        \"Name\": \"bridge\",\n        \"Id\": FAKE_NETWORK_ID,\n        \"Scope\": \"local\",\n        \"Driver\": \"bridge\",",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_join_swarm",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_join_swarm():\n    return 200, None\ndef get_fake_network_list():\n    return 200, [{\n        \"Name\": \"bridge\",\n        \"Id\": FAKE_NETWORK_ID,\n        \"Scope\": \"local\",\n        \"Driver\": \"bridge\",\n        \"EnableIPv6\": False,\n        \"Internal\": False,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_network_list",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_network_list():\n    return 200, [{\n        \"Name\": \"bridge\",\n        \"Id\": FAKE_NETWORK_ID,\n        \"Scope\": \"local\",\n        \"Driver\": \"bridge\",\n        \"EnableIPv6\": False,\n        \"Internal\": False,\n        \"IPAM\": {\n            \"Driver\": \"default\",",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "get_fake_network",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def get_fake_network():\n    return 200, get_fake_network_list()[1][0]\ndef post_fake_network():\n    return 201, {\"Id\": FAKE_NETWORK_ID, \"Warnings\": []}\ndef delete_fake_network():\n    return 204, None\ndef post_fake_network_connect():\n    return 200, None\ndef post_fake_network_disconnect():\n    return 200, None",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_network",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_network():\n    return 201, {\"Id\": FAKE_NETWORK_ID, \"Warnings\": []}\ndef delete_fake_network():\n    return 204, None\ndef post_fake_network_connect():\n    return 200, None\ndef post_fake_network_disconnect():\n    return 200, None\ndef post_fake_secret():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "delete_fake_network",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def delete_fake_network():\n    return 204, None\ndef post_fake_network_connect():\n    return 200, None\ndef post_fake_network_disconnect():\n    return 200, None\ndef post_fake_secret():\n    status_code = 200\n    response = {'ID': FAKE_SECRET_ID}\n    return status_code, response",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_network_connect",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_network_connect():\n    return 200, None\ndef post_fake_network_disconnect():\n    return 200, None\ndef post_fake_secret():\n    status_code = 200\n    response = {'ID': FAKE_SECRET_ID}\n    return status_code, response\n# Maps real api url to fake response callback\nprefix = 'http+docker://localhost'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_network_disconnect",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_network_disconnect():\n    return 200, None\ndef post_fake_secret():\n    status_code = 200\n    response = {'ID': FAKE_SECRET_ID}\n    return status_code, response\n# Maps real api url to fake response callback\nprefix = 'http+docker://localhost'\nif constants.IS_WINDOWS_PLATFORM:\n    prefix = 'http+docker://localnpipe'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "post_fake_secret",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "def post_fake_secret():\n    status_code = 200\n    response = {'ID': FAKE_SECRET_ID}\n    return status_code, response\n# Maps real api url to fake response callback\nprefix = 'http+docker://localhost'\nif constants.IS_WINDOWS_PLATFORM:\n    prefix = 'http+docker://localnpipe'\nfake_responses = {\n    '{prefix}/version'.format(prefix=prefix):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "__metaclass__ = type\nfrom ansible_collections.community.docker.plugins.module_utils._api import constants\nfrom . import fake_stat\nCURRENT_VERSION = 'v{api_version}'.format(api_version=constants.DEFAULT_DOCKER_API_VERSION)\nFAKE_CONTAINER_ID = '3cc2351ab11b'\nFAKE_IMAGE_ID = 'e9aa60c60128'\nFAKE_EXEC_ID = 'd5d177f121dc'\nFAKE_NETWORK_ID = '33fb6a3462b8'\nFAKE_IMAGE_NAME = 'test_image'\nFAKE_TARBALL_PATH = '/path/to/tarball'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "CURRENT_VERSION",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "CURRENT_VERSION = 'v{api_version}'.format(api_version=constants.DEFAULT_DOCKER_API_VERSION)\nFAKE_CONTAINER_ID = '3cc2351ab11b'\nFAKE_IMAGE_ID = 'e9aa60c60128'\nFAKE_EXEC_ID = 'd5d177f121dc'\nFAKE_NETWORK_ID = '33fb6a3462b8'\nFAKE_IMAGE_NAME = 'test_image'\nFAKE_TARBALL_PATH = '/path/to/tarball'\nFAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_CONTAINER_ID",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_CONTAINER_ID = '3cc2351ab11b'\nFAKE_IMAGE_ID = 'e9aa60c60128'\nFAKE_EXEC_ID = 'd5d177f121dc'\nFAKE_NETWORK_ID = '33fb6a3462b8'\nFAKE_IMAGE_NAME = 'test_image'\nFAKE_TARBALL_PATH = '/path/to/tarball'\nFAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_IMAGE_ID",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_IMAGE_ID = 'e9aa60c60128'\nFAKE_EXEC_ID = 'd5d177f121dc'\nFAKE_NETWORK_ID = '33fb6a3462b8'\nFAKE_IMAGE_NAME = 'test_image'\nFAKE_TARBALL_PATH = '/path/to/tarball'\nFAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_EXEC_ID",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_EXEC_ID = 'd5d177f121dc'\nFAKE_NETWORK_ID = '33fb6a3462b8'\nFAKE_IMAGE_NAME = 'test_image'\nFAKE_TARBALL_PATH = '/path/to/tarball'\nFAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_NETWORK_ID",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_NETWORK_ID = '33fb6a3462b8'\nFAKE_IMAGE_NAME = 'test_image'\nFAKE_TARBALL_PATH = '/path/to/tarball'\nFAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_IMAGE_NAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_IMAGE_NAME = 'test_image'\nFAKE_TARBALL_PATH = '/path/to/tarball'\nFAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_TARBALL_PATH",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_TARBALL_PATH = '/path/to/tarball'\nFAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_REPO_NAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_REPO_NAME = 'repo'\nFAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_TAG_NAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_TAG_NAME = 'tag'\nFAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_FILE_NAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_FILE_NAME = 'file'\nFAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability\ndef get_fake_version():",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_URL",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_URL = 'myurl'\nFAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability\ndef get_fake_version():\n    status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_PATH",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_PATH = '/path'\nFAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability\ndef get_fake_version():\n    status_code = 200\n    response = {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_VOLUME_NAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_VOLUME_NAME = 'perfectcherryblossom'\nFAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability\ndef get_fake_version():\n    status_code = 200\n    response = {\n        'ApiVersion': '1.35',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_NODE_ID",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_NODE_ID = '24ifsmvkjbyhk'\nFAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability\ndef get_fake_version():\n    status_code = 200\n    response = {\n        'ApiVersion': '1.35',\n        'Arch': 'amd64',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_SECRET_ID",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_SECRET_ID = 'epdyrw4tsi03xy3deu8g8ly6o'\nFAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability\ndef get_fake_version():\n    status_code = 200\n    response = {\n        'ApiVersion': '1.35',\n        'Arch': 'amd64',\n        'BuildTime': '2018-01-10T20:09:37.000000000+00:00',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "FAKE_SECRET_NAME",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "FAKE_SECRET_NAME = 'super_secret'\n# Each method is prefixed with HTTP method (get, post...)\n# for clarity and readability\ndef get_fake_version():\n    status_code = 200\n    response = {\n        'ApiVersion': '1.35',\n        'Arch': 'amd64',\n        'BuildTime': '2018-01-10T20:09:37.000000000+00:00',\n        'Components': [{",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "prefix",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "prefix = 'http+docker://localhost'\nif constants.IS_WINDOWS_PLATFORM:\n    prefix = 'http+docker://localnpipe'\nfake_responses = {\n    '{prefix}/version'.format(prefix=prefix):\n    get_fake_version,\n    '{prefix}/{CURRENT_VERSION}/version'.format(prefix=prefix, CURRENT_VERSION=CURRENT_VERSION):\n    get_fake_version,\n    '{prefix}/{CURRENT_VERSION}/info'.format(prefix=prefix, CURRENT_VERSION=CURRENT_VERSION):\n    get_fake_info,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "fake_responses",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "peekOfCode": "fake_responses = {\n    '{prefix}/version'.format(prefix=prefix):\n    get_fake_version,\n    '{prefix}/{CURRENT_VERSION}/version'.format(prefix=prefix, CURRENT_VERSION=CURRENT_VERSION):\n    get_fake_version,\n    '{prefix}/{CURRENT_VERSION}/info'.format(prefix=prefix, CURRENT_VERSION=CURRENT_VERSION):\n    get_fake_info,\n    '{prefix}/{CURRENT_VERSION}/auth'.format(prefix=prefix, CURRENT_VERSION=CURRENT_VERSION):\n    post_fake_auth,\n    '{prefix}/{CURRENT_VERSION}/_ping'.format(prefix=prefix, CURRENT_VERSION=CURRENT_VERSION):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_api",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_stat",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_stat",
        "peekOfCode": "__metaclass__ = type\nOBJ = {\n    \"read\": \"2015-02-11T19:20:46.667237763+02:00\",\n    \"network\": {\n        \"rx_bytes\": 567224,\n        \"rx_packets\": 3773,\n        \"rx_errors\": 0,\n        \"rx_dropped\": 0,\n        \"tx_bytes\": 1176,\n        \"tx_packets\": 13,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_stat",
        "documentation": {}
    },
    {
        "label": "OBJ",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_stat",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_stat",
        "peekOfCode": "OBJ = {\n    \"read\": \"2015-02-11T19:20:46.667237763+02:00\",\n    \"network\": {\n        \"rx_bytes\": 567224,\n        \"rx_packets\": 3773,\n        \"rx_errors\": 0,\n        \"rx_dropped\": 0,\n        \"tx_bytes\": 1176,\n        \"tx_packets\": 13,\n        \"tx_errors\": 0,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.fake_stat",
        "documentation": {}
    },
    {
        "label": "RegressionTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "class RegressionTest(unittest.TestCase):\n    def test_803_urlsafe_encode(self):\n        auth_data = {\n            'username': 'root',\n            'password': 'GR?XGR?XGR?XGR?X'\n        }\n        encoded = auth.encode_header(auth_data)\n        assert b'/' not in encoded\n        assert b'_' in encoded\nclass ResolveRepositoryNameTest(unittest.TestCase):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "ResolveRepositoryNameTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "class ResolveRepositoryNameTest(unittest.TestCase):\n    def test_resolve_repository_name_hub_library_image(self):\n        assert auth.resolve_repository_name('image') == (\n            'docker.io', 'image'\n        )\n    def test_resolve_repository_name_dotted_hub_library_image(self):\n        assert auth.resolve_repository_name('image.valid') == (\n            'docker.io', 'image.valid'\n        )\n    def test_resolve_repository_name_hub_image(self):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "ResolveAuthTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "class ResolveAuthTest(unittest.TestCase):\n    index_config = {'auth': encode_auth({'username': 'indexuser'})}\n    private_config = {'auth': encode_auth({'username': 'privateuser'})}\n    legacy_config = {'auth': encode_auth({'username': 'legacyauth'})}\n    auth_config = auth.AuthConfig({\n        'auths': auth.parse_auth({\n            'https://index.docker.io/v1/': index_config,\n            'my.registry.net': private_config,\n            'http://legacy.registry.url/v1/': legacy_config,\n        })",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "LoadConfigTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "class LoadConfigTest(unittest.TestCase):\n    def test_load_config_no_file(self):\n        folder = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, folder)\n        cfg = auth.load_config(folder)\n        assert cfg is not None\n    def test_load_legacy_config(self):\n        folder = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, folder)\n        cfg_path = os.path.join(folder, '.dockercfg')",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "CredstoreTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "class CredstoreTest(unittest.TestCase):\n    def setUp(self):\n        self.authconfig = auth.AuthConfig({'credsStore': 'default'})\n        self.default_store = InMemoryStore('default')\n        self.authconfig._stores['default'] = self.default_store\n        self.default_store.store(\n            'https://gensokyo.jp/v2', 'sakuya', 'izayoi',\n        )\n        self.default_store.store(\n            'https://default.com/v2', 'user', 'hunter2',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "InMemoryStore",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "class InMemoryStore(Store):\n    def __init__(self, *args, **kwargs):\n        self.__store = {}\n    def get(self, server):\n        try:\n            return self.__store[server]\n        except KeyError:\n            raise CredentialsNotFound()\n    def store(self, server, username, secret):\n        self.__store[server] = {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "encode_auth",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "def encode_auth(auth_info):\n    return base64.b64encode(\n        auth_info.get('username', '').encode('utf-8') + b':' +\n        auth_info.get('password', '').encode('utf-8'))\nclass ResolveAuthTest(unittest.TestCase):\n    index_config = {'auth': encode_auth({'username': 'indexuser'})}\n    private_config = {'auth': encode_auth({'username': 'privateuser'})}\n    legacy_config = {'auth': encode_auth({'username': 'legacyauth'})}\n    auth_config = auth.AuthConfig({\n        'auths': auth.parse_auth({",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "peekOfCode": "__metaclass__ = type\nimport base64\nimport json\nimport os\nimport os.path\nimport random\nimport shutil\nimport tempfile\nimport unittest\nimport sys",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_auth",
        "documentation": {}
    },
    {
        "label": "APIErrorTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "peekOfCode": "class APIErrorTest(unittest.TestCase):\n    def test_api_error_is_caught_by_dockerexception(self):\n        try:\n            raise APIError(\"this should be caught by DockerException\")\n        except DockerException:\n            pass\n    def test_status_code_200(self):\n        \"\"\"The status_code property is present with 200 response.\"\"\"\n        resp = requests.Response()\n        resp.status_code = 200",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "documentation": {}
    },
    {
        "label": "CreateUnexpectedKwargsErrorTest",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "peekOfCode": "class CreateUnexpectedKwargsErrorTest(unittest.TestCase):\n    def test_create_unexpected_kwargs_error_single(self):\n        e = create_unexpected_kwargs_error('f', {'foo': 'bar'})\n        assert str(e) == \"f() got an unexpected keyword argument 'foo'\"\n    def test_create_unexpected_kwargs_error_multiple(self):\n        e = create_unexpected_kwargs_error('f', {'foo': 'bar', 'baz': 'bosh'})\n        assert str(e) == \"f() got unexpected keyword arguments 'baz', 'foo'\"",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "peekOfCode": "__metaclass__ = type\nimport unittest\nimport sys\nimport pytest\nimport requests\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip('Python 2.6 is not supported')\nfrom ansible_collections.community.docker.plugins.module_utils._api.errors import (\n    APIError, DockerException,\n    create_unexpected_kwargs_error,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils._api.test_errors",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.compose_v2_test_cases",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.compose_v2_test_cases",
        "peekOfCode": "__metaclass__ = type\nfrom ansible_collections.community.docker.plugins.module_utils.compose_v2 import (\n    Event,\n)\nEVENT_TEST_CASES = [\n    # #######################################################################################################################\n    # ## Docker Compose 2.18.1 ##############################################################################################\n    # #######################################################################################################################\n    # docker_compose_v2: \"Absent\" on 2024-01-07 in 2.12-ubuntu1804\n    # Duplicated in: docker_compose_v2: \"Absent\" on 2024-01-13 in 2.12-ubuntu1804",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.compose_v2_test_cases",
        "documentation": {}
    },
    {
        "label": "EVENT_TEST_CASES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.compose_v2_test_cases",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.compose_v2_test_cases",
        "peekOfCode": "EVENT_TEST_CASES = [\n    # #######################################################################################################################\n    # ## Docker Compose 2.18.1 ##############################################################################################\n    # #######################################################################################################################\n    # docker_compose_v2: \"Absent\" on 2024-01-07 in 2.12-ubuntu1804\n    # Duplicated in: docker_compose_v2: \"Absent\" on 2024-01-13 in 2.12-ubuntu1804\n    # Duplicated in: docker_compose_v2: \"Cleanup\" on 2024-01-07 in 2.12-ubuntu1804\n    # Duplicated in: docker_compose_v2: \"Cleanup\" on 2024-01-13 in 2.12-ubuntu1804\n    (\n        '2.18.1-2.12-ubuntu1804-2024-01-07-docker_compose_v2-absent',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.compose_v2_test_cases",
        "documentation": {}
    },
    {
        "label": "test_parse_line_success",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "peekOfCode": "def test_parse_line_success(line, kwargs, result):\n    res = parse_line(line, **kwargs)\n    print(repr(res))\n    assert res == result\n@pytest.mark.parametrize('line, kwargs, message', FAILURE_TEST_CASES)\ndef test_parse_line_success(line, kwargs, message):\n    with pytest.raises(InvalidLogFmt) as exc:\n        parse_line(line, **kwargs)\n    print(repr(exc.value.args[0]))\n    assert exc.value.args[0] == message",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "documentation": {}
    },
    {
        "label": "test_parse_line_success",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "peekOfCode": "def test_parse_line_success(line, kwargs, message):\n    with pytest.raises(InvalidLogFmt) as exc:\n        parse_line(line, **kwargs)\n    print(repr(exc.value.args[0]))\n    assert exc.value.args[0] == message",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible_collections.community.docker.plugins.module_utils._logfmt import (\n    InvalidLogFmt,\n    parse_line,\n)\nSUCCESS_TEST_CASES = [\n    (\n        'time=\"2024-02-02T08:14:10+01:00\" level=warning msg=\"a network with name influxNetwork exists but was not'\n        ' created for project \\\\\"influxdb\\\\\".\\\\nSet `external: true` to use an existing network\"',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "documentation": {}
    },
    {
        "label": "SUCCESS_TEST_CASES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "peekOfCode": "SUCCESS_TEST_CASES = [\n    (\n        'time=\"2024-02-02T08:14:10+01:00\" level=warning msg=\"a network with name influxNetwork exists but was not'\n        ' created for project \\\\\"influxdb\\\\\".\\\\nSet `external: true` to use an existing network\"',\n        {},\n        {\n            'time': '2024-02-02T08:14:10+01:00',\n            'level': 'warning',\n            'msg': 'a network with name influxNetwork exists but was not created for project \"influxdb\".\\nSet `external: true` to use an existing network',\n        },",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "documentation": {}
    },
    {
        "label": "FAILURE_TEST_CASES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "peekOfCode": "FAILURE_TEST_CASES = [\n    (\n        'foo=bar a=14 baz=\"hello kitty\" cool%story=bro f %^asdf',\n        {'logrus_mode': True},\n        'Key must always be followed by \"=\" in logrus mode',\n    ),\n    (\n        '{}',\n        {'logrus_mode': True},\n        'Key must always be followed by \"=\" in logrus mode',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__logfmt",
        "documentation": {}
    },
    {
        "label": "test_scramble_unscramble",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__scramble",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__scramble",
        "peekOfCode": "def test_scramble_unscramble(plaintext, key, scrambled):\n    scrambled_ = scramble(plaintext, key)\n    print('{0!r} == {1!r}'.format(scrambled_, scrambled))\n    assert scrambled_ == scrambled\n    plaintext_ = unscramble(scrambled, key)\n    print('{0!r} == {1!r}'.format(plaintext_, plaintext))\n    assert plaintext_ == plaintext",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__scramble",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__scramble",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__scramble",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible_collections.community.docker.plugins.module_utils._scramble import (\n    scramble,\n    unscramble,\n)\n@pytest.mark.parametrize('plaintext, key, scrambled', [\n    (u'', b'0', '=S='),\n    (u'hello', b'\\x00', '=S=aGVsbG8='),\n    (u'hello', b'\\x01', '=S=aWRtbW4='),",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test__scramble",
        "documentation": {}
    },
    {
        "label": "test_parse_events",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "peekOfCode": "def test_parse_events(test_id, compose_version, dry_run, stderr, events, warnings):\n    collected_warnings = []\n    def collect_warning(msg):\n        collected_warnings.append(msg)\n    collected_events = parse_events(stderr, dry_run=dry_run, warn_function=collect_warning)\n    print(collected_events)\n    print(collected_warnings)\n    assert collected_events == events\n    assert collected_warnings == warnings",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible_collections.community.docker.plugins.module_utils.compose_v2 import (\n    Event,\n    parse_events,\n)\nfrom .compose_v2_test_cases import EVENT_TEST_CASES\nEXTRA_TEST_CASES = [\n    (\n        '2.24.2-manual-build-dry-run',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "documentation": {}
    },
    {
        "label": "EXTRA_TEST_CASES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "peekOfCode": "EXTRA_TEST_CASES = [\n    (\n        '2.24.2-manual-build-dry-run',\n        '2.24.2',\n        True,\n        ' DRY-RUN MODE -    build service foobar \\n'\n        ' DRY-RUN MODE -  ==> ==> writing image dryRun-8843d7f92416211de9ebb963ff4ce28125932878 \\n'\n        ' DRY-RUN MODE -  ==> ==> naming to my-python \\n'\n        ' DRY-RUN MODE -  Network compose_default  Creating\\n'\n        ' DRY-RUN MODE -  Network compose_default  Created\\n'",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "documentation": {}
    },
    {
        "label": "_ALL_TEST_CASES",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "peekOfCode": "_ALL_TEST_CASES = EVENT_TEST_CASES + EXTRA_TEST_CASES\n@pytest.mark.parametrize(\n    'test_id, compose_version, dry_run, stderr, events, warnings',\n    _ALL_TEST_CASES,\n    ids=[tc[0] for tc in _ALL_TEST_CASES],\n)\ndef test_parse_events(test_id, compose_version, dry_run, stderr, events, warnings):\n    collected_warnings = []\n    def collect_warning(msg):\n        collected_warnings.append(msg)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_compose_v2",
        "documentation": {}
    },
    {
        "label": "test__stream_generator_to_fileobj",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_copy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_copy",
        "peekOfCode": "def test__stream_generator_to_fileobj(chunks, read_sizes):\n    chunks = [count * data for count, data in chunks]\n    stream = _simple_generator(chunks)\n    expected = b''.join(chunks)\n    buffer = b''\n    totally_read = 0\n    f = _stream_generator_to_fileobj(stream)\n    for read_size in read_sizes:\n        chunk = f.read(read_size)\n        assert len(chunk) == min(read_size, len(expected) - len(buffer))",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_copy",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_copy",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_copy",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible_collections.community.docker.plugins.module_utils.copy import (\n    _stream_generator_to_fileobj,\n)\ndef _simple_generator(sequence):\n    for elt in sequence:\n        yield elt\n@pytest.mark.parametrize('chunks, read_sizes', [\n    (",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_copy",
        "documentation": {}
    },
    {
        "label": "tar_file_name",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "def tar_file_name(tmpdir):\n    '''\n    Return the name of a non-existing tar file in an existing temporary directory.\n    '''\n    # Cast to str required by Python 2.x\n    return str(tmpdir.join('foo.tar'))\n@pytest.mark.parametrize('expected, value', [\n    ('sha256:foo', 'foo'),\n    ('sha256:bar', 'bar')\n])",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "test_api_image_id_from_archive_id",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "def test_api_image_id_from_archive_id(expected, value):\n    assert api_image_id(value) == expected\ndef test_archived_image_manifest_extracts(tar_file_name):\n    expected_id = \"abcde12345\"\n    expected_tags = [\"foo:latest\", \"bar:v1\"]\n    write_imitation_archive(tar_file_name, expected_id, expected_tags)\n    actual = archived_image_manifest(tar_file_name)\n    assert actual.image_id == expected_id\n    assert actual.repo_tags == expected_tags\ndef test_archived_image_manifest_extracts_nothing_when_file_not_present(tar_file_name):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "test_archived_image_manifest_extracts",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "def test_archived_image_manifest_extracts(tar_file_name):\n    expected_id = \"abcde12345\"\n    expected_tags = [\"foo:latest\", \"bar:v1\"]\n    write_imitation_archive(tar_file_name, expected_id, expected_tags)\n    actual = archived_image_manifest(tar_file_name)\n    assert actual.image_id == expected_id\n    assert actual.repo_tags == expected_tags\ndef test_archived_image_manifest_extracts_nothing_when_file_not_present(tar_file_name):\n    image_id = archived_image_manifest(tar_file_name)\n    assert image_id is None",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "test_archived_image_manifest_extracts_nothing_when_file_not_present",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "def test_archived_image_manifest_extracts_nothing_when_file_not_present(tar_file_name):\n    image_id = archived_image_manifest(tar_file_name)\n    assert image_id is None\ndef test_archived_image_manifest_raises_when_file_not_a_tar():\n    try:\n        archived_image_manifest(__file__)\n        raise AssertionError()\n    except ImageArchiveInvalidException as e:\n        assert isinstance(e.cause, tarfile.ReadError)\n        assert str(__file__) in str(e)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "test_archived_image_manifest_raises_when_file_not_a_tar",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "def test_archived_image_manifest_raises_when_file_not_a_tar():\n    try:\n        archived_image_manifest(__file__)\n        raise AssertionError()\n    except ImageArchiveInvalidException as e:\n        assert isinstance(e.cause, tarfile.ReadError)\n        assert str(__file__) in str(e)\ndef test_archived_image_manifest_raises_when_tar_missing_manifest(tar_file_name):\n    write_irrelevant_tar(tar_file_name)\n    try:",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "test_archived_image_manifest_raises_when_tar_missing_manifest",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "def test_archived_image_manifest_raises_when_tar_missing_manifest(tar_file_name):\n    write_irrelevant_tar(tar_file_name)\n    try:\n        archived_image_manifest(tar_file_name)\n        raise AssertionError()\n    except ImageArchiveInvalidException as e:\n        assert isinstance(e.cause, KeyError)\n        assert 'manifest.json' in str(e.cause)\ndef test_archived_image_manifest_raises_when_manifest_missing_id(tar_file_name):\n    manifest = [",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "test_archived_image_manifest_raises_when_manifest_missing_id",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "def test_archived_image_manifest_raises_when_manifest_missing_id(tar_file_name):\n    manifest = [\n        {\n            'foo': 'bar'\n        }\n    ]\n    write_imitation_archive_with_manifest(tar_file_name, manifest)\n    try:\n        archived_image_manifest(tar_file_name)\n        raise AssertionError()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nimport tarfile\nfrom ansible_collections.community.docker.plugins.module_utils.image_archive import (\n    api_image_id,\n    archived_image_manifest,\n    ImageArchiveInvalidException\n)\nfrom ..test_support.docker_image_archive_stubbing import (\n    write_imitation_archive,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_image_archive",
        "documentation": {}
    },
    {
        "label": "test_dict_allow_more_present",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "peekOfCode": "def test_dict_allow_more_present(entry):\n    assert compare_dict_allow_more_present(entry['av'], entry['bv']) == entry['result']\n@pytest.mark.parametrize(\"entry\", COMPARE_GENERIC)\ndef test_compare_generic(entry):\n    assert compare_generic(entry['a'], entry['b'], entry['method'], entry['type']) == entry['result']\ndef test_convert_duration_to_nanosecond():\n    nanoseconds = convert_duration_to_nanosecond('5s')\n    assert nanoseconds == 5000000000\n    nanoseconds = convert_duration_to_nanosecond('1m5s')\n    assert nanoseconds == 65000000000",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "documentation": {}
    },
    {
        "label": "test_compare_generic",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "peekOfCode": "def test_compare_generic(entry):\n    assert compare_generic(entry['a'], entry['b'], entry['method'], entry['type']) == entry['result']\ndef test_convert_duration_to_nanosecond():\n    nanoseconds = convert_duration_to_nanosecond('5s')\n    assert nanoseconds == 5000000000\n    nanoseconds = convert_duration_to_nanosecond('1m5s')\n    assert nanoseconds == 65000000000\n    with pytest.raises(ValueError):\n        convert_duration_to_nanosecond([1, 2, 3])\n    with pytest.raises(ValueError):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "documentation": {}
    },
    {
        "label": "test_convert_duration_to_nanosecond",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "peekOfCode": "def test_convert_duration_to_nanosecond():\n    nanoseconds = convert_duration_to_nanosecond('5s')\n    assert nanoseconds == 5000000000\n    nanoseconds = convert_duration_to_nanosecond('1m5s')\n    assert nanoseconds == 65000000000\n    with pytest.raises(ValueError):\n        convert_duration_to_nanosecond([1, 2, 3])\n    with pytest.raises(ValueError):\n        convert_duration_to_nanosecond('10x')\ndef test_parse_healthcheck():",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "documentation": {}
    },
    {
        "label": "test_parse_healthcheck",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "peekOfCode": "def test_parse_healthcheck():\n    result, disabled = parse_healthcheck({\n        'test': 'sleep 1',\n        'interval': '1s',\n    })\n    assert disabled is False\n    assert result == {\n        'test': ['CMD-SHELL', 'sleep 1'],\n        'interval': 1000000000\n    }",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible_collections.community.docker.plugins.module_utils.util import (\n    compare_dict_allow_more_present,\n    compare_generic,\n    convert_duration_to_nanosecond,\n    parse_healthcheck\n)\nDICT_ALLOW_MORE_PRESENT = (\n    {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "documentation": {}
    },
    {
        "label": "DICT_ALLOW_MORE_PRESENT",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "peekOfCode": "DICT_ALLOW_MORE_PRESENT = (\n    {\n        'av': {},\n        'bv': {'a': 1},\n        'result': True\n    },\n    {\n        'av': {'a': 1},\n        'bv': {'a': 1, 'b': 2},\n        'result': True",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "documentation": {}
    },
    {
        "label": "COMPARE_GENERIC",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "peekOfCode": "COMPARE_GENERIC = [\n    ########################################################################################\n    # value\n    {\n        'a': 1,\n        'b': 2,\n        'method': 'strict',\n        'type': 'value',\n        'result': False\n    },",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.module_utils.test_util",
        "documentation": {}
    },
    {
        "label": "patch_ansible_module",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.conftest",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.conftest",
        "peekOfCode": "def patch_ansible_module(request, mocker):\n    if isinstance(request.param, string_types):\n        args = request.param\n    elif isinstance(request.param, MutableMapping):\n        if 'ANSIBLE_MODULE_ARGS' not in request.param:\n            request.param = {'ANSIBLE_MODULE_ARGS': request.param}\n        if '_ansible_remote_tmp' not in request.param['ANSIBLE_MODULE_ARGS']:\n            request.param['ANSIBLE_MODULE_ARGS']['_ansible_remote_tmp'] = '/tmp'\n        if '_ansible_keep_remote_files' not in request.param['ANSIBLE_MODULE_ARGS']:\n            request.param['ANSIBLE_MODULE_ARGS']['_ansible_keep_remote_files'] = False",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.conftest",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.conftest",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.conftest",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport pytest\nfrom ansible.module_utils.six import string_types\nfrom ansible.module_utils.common.text.converters import to_bytes\nfrom ansible.module_utils.common._collections_compat import MutableMapping\n@pytest.fixture\ndef patch_ansible_module(request, mocker):\n    if isinstance(request.param, string_types):\n        args = request.param",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.conftest",
        "documentation": {}
    },
    {
        "label": "assert_no_logging",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def assert_no_logging(msg):\n    raise AssertionError('Should not have logged anything but logged %s' % msg)\ndef capture_logging(messages):\n    def capture(msg):\n        messages.append(msg)\n    return capture\n@pytest.fixture\ndef tar_file_name(tmpdir):\n    \"\"\"\n    Return the name of a non-existing tar file in an existing temporary directory.",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "capture_logging",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def capture_logging(messages):\n    def capture(msg):\n        messages.append(msg)\n    return capture\n@pytest.fixture\ndef tar_file_name(tmpdir):\n    \"\"\"\n    Return the name of a non-existing tar file in an existing temporary directory.\n    \"\"\"\n    # Cast to str required by Python 2.x",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "tar_file_name",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def tar_file_name(tmpdir):\n    \"\"\"\n    Return the name of a non-existing tar file in an existing temporary directory.\n    \"\"\"\n    # Cast to str required by Python 2.x\n    return str(tmpdir.join('foo.tar'))\ndef test_archived_image_action_when_missing(tar_file_name):\n    fake_name = 'a:latest'\n    fake_id = 'a1'\n    expected = 'Archived image %s to %s, since none present' % (fake_name, tar_file_name)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "test_archived_image_action_when_missing",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def test_archived_image_action_when_missing(tar_file_name):\n    fake_name = 'a:latest'\n    fake_id = 'a1'\n    expected = 'Archived image %s to %s, since none present' % (fake_name, tar_file_name)\n    actual = ImageManager.archived_image_action(assert_no_logging, tar_file_name, fake_name, api_image_id(fake_id))\n    assert actual == expected\ndef test_archived_image_action_when_current(tar_file_name):\n    fake_name = 'b:latest'\n    fake_id = 'b2'\n    write_imitation_archive(tar_file_name, fake_id, [fake_name])",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "test_archived_image_action_when_current",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def test_archived_image_action_when_current(tar_file_name):\n    fake_name = 'b:latest'\n    fake_id = 'b2'\n    write_imitation_archive(tar_file_name, fake_id, [fake_name])\n    actual = ImageManager.archived_image_action(assert_no_logging, tar_file_name, fake_name, api_image_id(fake_id))\n    assert actual is None\ndef test_archived_image_action_when_invalid(tar_file_name):\n    fake_name = 'c:1.2.3'\n    fake_id = 'c3'\n    write_irrelevant_tar(tar_file_name)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "test_archived_image_action_when_invalid",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def test_archived_image_action_when_invalid(tar_file_name):\n    fake_name = 'c:1.2.3'\n    fake_id = 'c3'\n    write_irrelevant_tar(tar_file_name)\n    expected = 'Archived image %s to %s, overwriting an unreadable archive file' % (fake_name, tar_file_name)\n    actual_log = []\n    actual = ImageManager.archived_image_action(\n        capture_logging(actual_log),\n        tar_file_name,\n        fake_name,",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "test_archived_image_action_when_obsolete_by_id",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def test_archived_image_action_when_obsolete_by_id(tar_file_name):\n    fake_name = 'd:0.0.1'\n    old_id = 'e5'\n    new_id = 'd4'\n    write_imitation_archive(tar_file_name, old_id, [fake_name])\n    expected = 'Archived image %s to %s, overwriting archive with image %s named %s' % (\n        fake_name, tar_file_name, old_id, fake_name\n    )\n    actual = ImageManager.archived_image_action(assert_no_logging, tar_file_name, fake_name, api_image_id(new_id))\n    assert actual == expected",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "test_archived_image_action_when_obsolete_by_name",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "def test_archived_image_action_when_obsolete_by_name(tar_file_name):\n    old_name = 'hi'\n    new_name = 'd:0.0.1'\n    fake_id = 'd4'\n    write_imitation_archive(tar_file_name, fake_id, [old_name])\n    expected = 'Archived image %s to %s, overwriting archive with image %s named %s' % (\n        new_name, tar_file_name, fake_id, old_name\n    )\n    actual = ImageManager.archived_image_action(assert_no_logging, tar_file_name, new_name, api_image_id(fake_id))\n    print('actual   : %s', actual)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible_collections.community.docker.plugins.modules.docker_image import ImageManager\nfrom ansible_collections.community.docker.plugins.module_utils.image_archive import api_image_id\nfrom ..test_support.docker_image_archive_stubbing import (\n    write_imitation_archive,\n    write_irrelevant_tar,\n)\ndef assert_no_logging(msg):\n    raise AssertionError('Should not have logged anything but logged %s' % msg)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_image",
        "documentation": {}
    },
    {
        "label": "test_validate_cidr_positives",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "peekOfCode": "def test_validate_cidr_positives(cidr, expected):\n    assert validate_cidr(cidr) == expected\n@pytest.mark.parametrize(\"cidr\", [\n    '192.168.0.1',\n    '192.168.0.1/34',\n    '192.168.0.1/asd',\n    'fdd1:ac8c:0557:7ce2::',\n])\ndef test_validate_cidr_negatives(cidr):\n    with pytest.raises(ValueError) as e:",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "documentation": {}
    },
    {
        "label": "test_validate_cidr_negatives",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "peekOfCode": "def test_validate_cidr_negatives(cidr):\n    with pytest.raises(ValueError) as e:\n        validate_cidr(cidr)\n    assert '\"{0}\" is not a valid CIDR'.format(cidr) == str(e.value)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible_collections.community.docker.plugins.modules.docker_network import validate_cidr\n@pytest.mark.parametrize(\"cidr,expected\", [\n    ('192.168.0.1/16', 'ipv4'),\n    ('192.168.0.1/24', 'ipv4'),\n    ('192.168.0.1/32', 'ipv4'),\n    ('fdd1:ac8c:0557:7ce2::/64', 'ipv6'),\n    ('fdd1:ac8c:0557:7ce2::/128', 'ipv6'),\n])",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_network",
        "documentation": {}
    },
    {
        "label": "APIErrorMock",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "class APIErrorMock(Exception):\n    def __init__(self, message, response=None, explanation=None):\n        self.message = message\n        self.response = response\n        self.explanation = explanation\n@pytest.fixture(autouse=True)\ndef docker_module_mock(mocker):\n    docker_module_mock = mocker.MagicMock()\n    docker_utils_module_mock = mocker.MagicMock()\n    docker_errors_module_mock = mocker.MagicMock()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "docker_module_mock",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def docker_module_mock(mocker):\n    docker_module_mock = mocker.MagicMock()\n    docker_utils_module_mock = mocker.MagicMock()\n    docker_errors_module_mock = mocker.MagicMock()\n    docker_errors_module_mock.APIError = APIErrorMock\n    mock_modules = {\n        'docker': docker_module_mock,\n        'docker.utils': docker_utils_module_mock,\n        'docker.errors': docker_errors_module_mock,\n    }",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "docker_swarm_service",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def docker_swarm_service():\n    from ansible_collections.community.docker.plugins.modules import docker_swarm_service\n    return docker_swarm_service\ndef test_retry_on_out_of_sequence_error(mocker, docker_swarm_service):\n    run_mock = mocker.MagicMock(\n        side_effect=APIErrorMock(\n            message='',\n            response=None,\n            explanation='rpc error: code = Unknown desc = update out of sequence',\n        )",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_retry_on_out_of_sequence_error",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_retry_on_out_of_sequence_error(mocker, docker_swarm_service):\n    run_mock = mocker.MagicMock(\n        side_effect=APIErrorMock(\n            message='',\n            response=None,\n            explanation='rpc error: code = Unknown desc = update out of sequence',\n        )\n    )\n    manager = docker_swarm_service.DockerServiceManager(client=None)\n    manager.run = run_mock",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_no_retry_on_general_api_error",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_no_retry_on_general_api_error(mocker, docker_swarm_service):\n    run_mock = mocker.MagicMock(\n        side_effect=APIErrorMock(message='', response=None, explanation='some error')\n    )\n    manager = docker_swarm_service.DockerServiceManager(client=None)\n    manager.run = run_mock\n    with pytest.raises(APIErrorMock):\n        manager.run_safe()\n    assert run_mock.call_count == 1\ndef test_get_docker_environment(mocker, docker_swarm_service):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_get_docker_environment",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_get_docker_environment(mocker, docker_swarm_service):\n    env_file_result = {'TEST1': 'A', 'TEST2': 'B', 'TEST3': 'C'}\n    env_dict = {'TEST3': 'CC', 'TEST4': 'D'}\n    env_string = \"TEST3=CC,TEST4=D\"\n    env_list = ['TEST3=CC', 'TEST4=D']\n    expected_result = sorted(['TEST1=A', 'TEST2=B', 'TEST3=CC', 'TEST4=D'])\n    mocker.patch.object(\n        docker_swarm_service, 'parse_env_file', return_value=env_file_result\n    )\n    mocker.patch.object(",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_get_nanoseconds_from_raw_option",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_get_nanoseconds_from_raw_option(docker_swarm_service):\n    value = docker_swarm_service.get_nanoseconds_from_raw_option('test', None)\n    assert value is None\n    value = docker_swarm_service.get_nanoseconds_from_raw_option('test', '1m30s535ms')\n    assert value == 90535000000\n    value = docker_swarm_service.get_nanoseconds_from_raw_option('test', 10000000000)\n    assert value == 10000000000\n    with pytest.raises(ValueError):\n        docker_swarm_service.get_nanoseconds_from_raw_option('test', [])\ndef test_has_dict_changed(docker_swarm_service):",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_has_dict_changed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_has_dict_changed(docker_swarm_service):\n    assert not docker_swarm_service.has_dict_changed(\n        {\"a\": 1},\n        {\"a\": 1},\n    )\n    assert not docker_swarm_service.has_dict_changed(\n        {\"a\": 1},\n        {\"a\": 1, \"b\": 2}\n    )\n    assert docker_swarm_service.has_dict_changed(",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_has_list_changed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_has_list_changed(docker_swarm_service):\n    # List comparisons without dictionaries\n    # I could improve the indenting, but pycodestyle wants this instead\n    assert not docker_swarm_service.has_list_changed(None, None)\n    assert not docker_swarm_service.has_list_changed(None, [])\n    assert not docker_swarm_service.has_list_changed(None, [1, 2])\n    assert not docker_swarm_service.has_list_changed([], None)\n    assert not docker_swarm_service.has_list_changed([], [])\n    assert docker_swarm_service.has_list_changed([], [1, 2])\n    assert docker_swarm_service.has_list_changed([1, 2], None)",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_have_networks_changed",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_have_networks_changed(docker_swarm_service):\n    assert not docker_swarm_service.have_networks_changed(\n        None,\n        None\n    )\n    assert not docker_swarm_service.have_networks_changed(\n        [],\n        None\n    )\n    assert not docker_swarm_service.have_networks_changed(",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_get_docker_networks",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "def test_get_docker_networks(docker_swarm_service):\n    network_names = [\n        'network_1',\n        'network_2',\n        'network_3',\n        'network_4',\n    ]\n    networks = [\n        network_names[0],\n        {'name': network_names[1]},",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nclass APIErrorMock(Exception):\n    def __init__(self, message, response=None, explanation=None):\n        self.message = message\n        self.response = response\n        self.explanation = explanation\n@pytest.fixture(autouse=True)\ndef docker_module_mock(mocker):\n    docker_module_mock = mocker.MagicMock()",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.modules.test_docker_swarm_service",
        "documentation": {}
    },
    {
        "label": "test_make_unsafe",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "peekOfCode": "def test_make_unsafe(value, check_unsafe_paths, check_safe_paths):\n    unsafe_value = make_unsafe(value)\n    assert unsafe_value == value\n    for check_path in check_unsafe_paths:\n        obj = unsafe_value\n        for elt in check_path:\n            obj = obj[elt]\n        assert isinstance(obj, AnsibleUnsafe)\n    for check_path in check_safe_paths:\n        obj = unsafe_value",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "documentation": {}
    },
    {
        "label": "test_make_unsafe_dict_key",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "peekOfCode": "def test_make_unsafe_dict_key():\n    value = {\n        b'test': 1,\n        u'test': 2,\n    }\n    unsafe_value = make_unsafe(value)\n    assert unsafe_value == value\n    for obj in unsafe_value:\n        assert not isinstance(obj, AnsibleUnsafe)\n    value = {",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "documentation": {}
    },
    {
        "label": "test_make_unsafe_set",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "peekOfCode": "def test_make_unsafe_set():\n    value = set([b'test', u'test'])\n    unsafe_value = make_unsafe(value)\n    assert unsafe_value == value\n    for obj in unsafe_value:\n        assert not isinstance(obj, AnsibleUnsafe)\n    value = set([b'{{test}}', u'{{test}}'])\n    unsafe_value = make_unsafe(value)\n    assert unsafe_value == value\n    for obj in unsafe_value:",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible.utils.unsafe_proxy import AnsibleUnsafe\nfrom ansible_collections.community.docker.plugins.plugin_utils.unsafe import (\n    make_unsafe,\n)\nTEST_MAKE_UNSAFE = [\n    (\n        u'text',\n        [],",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "documentation": {}
    },
    {
        "label": "TEST_MAKE_UNSAFE",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "peekOfCode": "TEST_MAKE_UNSAFE = [\n    (\n        u'text',\n        [],\n        [\n            (),\n        ],\n    ),\n    (\n        u'{{text}}',",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.plugin_utils.test_unsafe",
        "documentation": {}
    },
    {
        "label": "write_imitation_archive",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "peekOfCode": "def write_imitation_archive(file_name, image_id, repo_tags):\n    '''\n    Write a tar file meeting these requirements:\n    * Has a file manifest.json\n    * manifest.json contains a one-element array\n    * The element has a Config property with \"[image_id].json\" as the value name\n    :param file_name: Name of file to create\n    :type file_name: str\n    :param image_id: Fake sha256 hash (without the sha256: prefix)\n    :type image_id: str",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "documentation": {}
    },
    {
        "label": "write_imitation_archive_with_manifest",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "peekOfCode": "def write_imitation_archive_with_manifest(file_name, manifest):\n    tf = tarfile.open(file_name, 'w')\n    try:\n        with TemporaryFile() as f:\n            f.write(json.dumps(manifest).encode('utf-8'))\n            ti = tarfile.TarInfo('manifest.json')\n            ti.size = f.tell()\n            f.seek(0)\n            tf.addfile(ti, f)\n    finally:",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "documentation": {}
    },
    {
        "label": "write_irrelevant_tar",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "peekOfCode": "def write_irrelevant_tar(file_name):\n    '''\n    Create a tar file that does not match the spec for \"docker image save\" / \"docker image load\" commands.\n    :param file_name: Name of tar file to create\n    :type file_name: str\n    '''\n    tf = tarfile.open(file_name, 'w')\n    try:\n        with TemporaryFile() as f:\n            f.write('Hello, world.'.encode('utf-8'))",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "description": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "peekOfCode": "__metaclass__ = type\nimport json\nimport tarfile\nfrom tempfile import TemporaryFile\ndef write_imitation_archive(file_name, image_id, repo_tags):\n    '''\n    Write a tar file meeting these requirements:\n    * Has a file manifest.json\n    * manifest.json contains a one-element array\n    * The element has a Config property with \"[image_id].json\" as the value name",
        "detail": "collections.ansible_collections.community.docker.tests.unit.plugins.test_support.docker_image_archive_stubbing",
        "documentation": {}
    },
    {
        "label": "ModuleDocFragment",
        "kind": 6,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.doc_fragments.inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.doc_fragments.inventory_filter",
        "peekOfCode": "class ModuleDocFragment(object):\n    # Docker doc fragment\n    DOCUMENTATION = r'''\noptions:\n    filters:\n        description:\n            - A list of include/exclude filters that allows to select/deselect hosts for this inventory.\n            - Filters are processed sequentially until the first filter where O(filters[].exclude) or\n              O(filters[].include) matches is found. In case O(filters[].exclude) matches, the host is\n              excluded, and in case O(filters[].include) matches, the host is included. In case no filter",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.doc_fragments.inventory_filter",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.doc_fragments.inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.doc_fragments.inventory_filter",
        "peekOfCode": "__metaclass__ = type\nclass ModuleDocFragment(object):\n    # Docker doc fragment\n    DOCUMENTATION = r'''\noptions:\n    filters:\n        description:\n            - A list of include/exclude filters that allows to select/deselect hosts for this inventory.\n            - Filters are processed sequentially until the first filter where O(filters[].exclude) or\n              O(filters[].include) matches is found. In case O(filters[].exclude) matches, the host is",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.doc_fragments.inventory_filter",
        "documentation": {}
    },
    {
        "label": "parse_filters",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "peekOfCode": "def parse_filters(filters):\n    \"\"\"\n    Parse get_option('filter') and return normalized version to be fed into filter_host().\n    \"\"\"\n    result = []\n    if filters is None:\n        return result\n    for index, filter in enumerate(filters):\n        if not isinstance(filter, Mapping):\n            raise AnsibleError('filter[{index}] must be a dictionary'.format(",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "filter_host",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "peekOfCode": "def filter_host(inventory_plugin, host, host_vars, filters):\n    \"\"\"\n    Determine whether a host should be accepted (``True``) or not (``False``).\n    \"\"\"\n    vars = {\n        'inventory_hostname': host,\n    }\n    if host_vars:\n        vars.update(host_vars)\n    def evaluate(condition):",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "peekOfCode": "__metaclass__ = type\nfrom ansible.errors import AnsibleError, AnsibleParserError\nfrom ansible.module_utils.common._collections_compat import Mapping\nfrom ansible.module_utils.common.text.converters import to_native\nfrom ansible.module_utils.parsing.convert_bool import boolean\nfrom ansible.module_utils.six import string_types\n_ALLOWED_KEYS = ('include', 'exclude')\ndef parse_filters(filters):\n    \"\"\"\n    Parse get_option('filter') and return normalized version to be fed into filter_host().",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "_ALLOWED_KEYS",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "peekOfCode": "_ALLOWED_KEYS = ('include', 'exclude')\ndef parse_filters(filters):\n    \"\"\"\n    Parse get_option('filter') and return normalized version to be fed into filter_host().\n    \"\"\"\n    result = []\n    if filters is None:\n        return result\n    for index, filter in enumerate(filters):\n        if not isinstance(filter, Mapping):",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.plugins.plugin_utils.inventory_filter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.extra-docs",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.extra-docs",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    env = os.environ.copy()\n    suffix = ':{env}'.format(env=env[\"ANSIBLE_COLLECTIONS_PATH\"]) if 'ANSIBLE_COLLECTIONS_PATH' in env else ''\n    env['ANSIBLE_COLLECTIONS_PATH'] = '{root}{suffix}'.format(root=os.path.dirname(os.path.dirname(os.path.dirname(os.getcwd()))), suffix=suffix)\n    p = subprocess.run(\n        ['antsibull-docs', 'lint-collection-docs', '--plugin-docs', '--skip-rstcheck', '.'],\n        env=env,\n        check=False,\n    )",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.extra-docs",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.extra-docs",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.extra-docs",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport sys\nimport subprocess\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    env = os.environ.copy()\n    suffix = ':{env}'.format(env=env[\"ANSIBLE_COLLECTIONS_PATH\"]) if 'ANSIBLE_COLLECTIONS_PATH' in env else ''\n    env['ANSIBLE_COLLECTIONS_PATH'] = '{root}{suffix}'.format(root=os.path.dirname(os.path.dirname(os.path.dirname(os.getcwd()))), suffix=suffix)\n    p = subprocess.run(",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.extra-docs",
        "documentation": {}
    },
    {
        "label": "format_license_list",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "peekOfCode": "def format_license_list(licenses):\n    if not licenses:\n        return '(empty)'\n    return ', '.join(['\"%s\"' % license for license in licenses])\ndef find_licenses(filename, relax=False):\n    spdx_license_identifiers = []\n    other_license_identifiers = []\n    has_copyright = False\n    try:\n        with open(filename, 'r', encoding='utf-8') as f:",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "find_licenses",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "peekOfCode": "def find_licenses(filename, relax=False):\n    spdx_license_identifiers = []\n    other_license_identifiers = []\n    has_copyright = False\n    try:\n        with open(filename, 'r', encoding='utf-8') as f:\n            for line in f:\n                line = line.rstrip()\n                if 'Copyright ' in line:\n                    has_copyright = True",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n    # The following paths are allowed to have no license identifier\n    no_comments_allowed = [\n        'changelogs/fragments/*.yml',\n        'changelogs/fragments/*.yaml',\n    ]\n    # These files are completely ignored\n    ignore_paths = [",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport glob\nimport sys\ndef format_license_list(licenses):\n    if not licenses:\n        return '(empty)'\n    return ', '.join(['\"%s\"' % license for license in licenses])\ndef find_licenses(filename, relax=False):\n    spdx_license_identifiers = []",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.licenses",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.no-unwanted-files",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.no-unwanted-files",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n    allowed_extensions = (\n        '.cs',\n        '.ps1',\n        '.psm1',\n        '.py',\n    )\n    skip_paths = set([",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.no-unwanted-files",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.no-unwanted-files",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.no-unwanted-files",
        "peekOfCode": "__metaclass__ = type\nimport os\nimport sys\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    paths = sys.argv[1:] or sys.stdin.read().splitlines()\n    allowed_extensions = (\n        '.cs',\n        '.ps1',\n        '.psm1',",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.sanity.extra.no-unwanted-files",
        "documentation": {}
    },
    {
        "label": "inventory",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "peekOfCode": "def inventory():\n    r = MagicMock()\n    r.templar = Templar(loader=DictDataLoader({}))\n    return r\n@pytest.mark.parametrize('input', [\n    None,\n    [],\n    [{'include': 'foo'}],\n    [{'include': True}],\n    [{'exclude': 'foo'}],",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "documentation": {}
    },
    {
        "label": "test_parse_success",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "peekOfCode": "def test_parse_success(input):\n    result = parse_filters(input)\n    print(result)\n    assert result == (input or [])\n@pytest.mark.parametrize('input, output', [\n    (\n        [23],\n        ('filter[1] must be a dictionary', ),\n    ),\n    (",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "documentation": {}
    },
    {
        "label": "test_parse_errors",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "peekOfCode": "def test_parse_errors(input, output):\n    with pytest.raises(AnsibleError) as exc:\n        parse_filters(input)\n    print(exc.value.args[0])\n    assert exc.value.args[0] in output\n@pytest.mark.parametrize('host, host_vars, filters, result', [\n    (\n        'example.com',\n        {},\n        [],",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "documentation": {}
    },
    {
        "label": "test_filter_success",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "peekOfCode": "def test_filter_success(inventory, host, host_vars, filters, result):\n    assert filter_host(inventory, host, host_vars, filters) == result\n@pytest.mark.parametrize('host, host_vars, filters, result', [\n    (\n        'example.com',\n        {},\n        [{'include': 'foobar'}],\n        (\n            \"Could not evaluate filter condition 'foobar' for host example.com: 'foobar' is undefined\",\n            \"Could not evaluate filter condition 'foobar' for host example.com: 'foobar' is undefined. 'foobar' is undefined\",",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "documentation": {}
    },
    {
        "label": "test_filter_errors",
        "kind": 2,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "peekOfCode": "def test_filter_errors(inventory, host, host_vars, filters, result):\n    with pytest.raises(AnsibleParserError) as exc:\n        filter_host(inventory, host, host_vars, filters)\n    print(exc.value.args[0])\n    assert exc.value.args[0] in result",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "documentation": {}
    },
    {
        "label": "__metaclass__",
        "kind": 5,
        "importPath": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "description": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "peekOfCode": "__metaclass__ = type\nimport pytest\nfrom ansible.errors import AnsibleError, AnsibleParserError\nfrom ansible.template import Templar\nfrom mock import MagicMock\nfrom ansible_collections.community.internal_test_tools.tests.unit.mock.loader import DictDataLoader\nfrom .....plugins.plugin_utils.inventory_filter import parse_filters, filter_host\n@pytest.fixture(scope='module')\ndef inventory():\n    r = MagicMock()",
        "detail": "collections.ansible_collections.community.library_inventory_filtering_v1.tests.unit.plugins.plugin_utils.test_inventory_filter",
        "documentation": {}
    },
    {
        "label": "NewVisitorTest",
        "kind": 6,
        "importPath": "src.functional_tests.tests",
        "description": "src.functional_tests.tests",
        "peekOfCode": "class NewVisitorTest(StaticLiveServerTestCase):\n    def setUp(self):\n        self.browser = webdriver.Firefox()\n        test_server=os.environ.get(\"TEST_SERVER\")\n        if test_server:\n            self.live_server_url=\"http://\"+test_server\n    def tearDown(self):\n        self.browser.quit()\n    def wait_for_row_in_list_table(self, row_text):\n        start_time = time.time()",
        "detail": "src.functional_tests.tests",
        "documentation": {}
    },
    {
        "label": "MAX_WAIT",
        "kind": 5,
        "importPath": "src.functional_tests.tests",
        "description": "src.functional_tests.tests",
        "peekOfCode": "MAX_WAIT = 5\nclass NewVisitorTest(StaticLiveServerTestCase):\n    def setUp(self):\n        self.browser = webdriver.Firefox()\n        test_server=os.environ.get(\"TEST_SERVER\")\n        if test_server:\n            self.live_server_url=\"http://\"+test_server\n    def tearDown(self):\n        self.browser.quit()\n    def wait_for_row_in_list_table(self, row_text):",
        "detail": "src.functional_tests.tests",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "src.lists.migrations.0001_initial",
        "description": "src.lists.migrations.0001_initial",
        "peekOfCode": "class Migration(migrations.Migration):\n    initial = True\n    dependencies = [\n    ]\n    operations = [\n        migrations.CreateModel(\n            name='Item',\n            fields=[\n                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n            ],",
        "detail": "src.lists.migrations.0001_initial",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "src.lists.migrations.0002_item_text",
        "description": "src.lists.migrations.0002_item_text",
        "peekOfCode": "class Migration(migrations.Migration):\n    dependencies = [\n        ('lists', '0001_initial'),\n    ]\n    operations = [\n        migrations.AddField(\n            model_name='item',\n            name='text',\n            field=models.TextField(default=''),\n        ),",
        "detail": "src.lists.migrations.0002_item_text",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "src.lists.migrations.0003_list",
        "description": "src.lists.migrations.0003_list",
        "peekOfCode": "class Migration(migrations.Migration):\n    dependencies = [\n        ('lists', '0002_item_text'),\n    ]\n    operations = [\n        migrations.CreateModel(\n            name='List',\n            fields=[\n                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n            ],",
        "detail": "src.lists.migrations.0003_list",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "src.lists.migrations.0004_item_list",
        "description": "src.lists.migrations.0004_item_list",
        "peekOfCode": "class Migration(migrations.Migration):\n    dependencies = [\n        ('lists', '0003_list'),\n    ]\n    operations = [\n        migrations.AddField(\n            model_name='item',\n            name='list',\n            field=models.ForeignKey(default=None, on_delete=django.db.models.deletion.CASCADE, to='lists.list'),\n        ),",
        "detail": "src.lists.migrations.0004_item_list",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "src.lists.migrations.0005_remove_item_list",
        "description": "src.lists.migrations.0005_remove_item_list",
        "peekOfCode": "class Migration(migrations.Migration):\n    dependencies = [\n        ('lists', '0004_item_list'),\n    ]\n    operations = [\n        migrations.RemoveField(\n            model_name='item',\n            name='list',\n        ),\n    ]",
        "detail": "src.lists.migrations.0005_remove_item_list",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "src.lists.migrations.0006_item_list",
        "description": "src.lists.migrations.0006_item_list",
        "peekOfCode": "class Migration(migrations.Migration):\n    dependencies = [\n        ('lists', '0005_remove_item_list'),\n    ]\n    operations = [\n        migrations.AddField(\n            model_name='item',\n            name='list',\n            field=models.ForeignKey(default=None, on_delete=django.db.models.deletion.CASCADE, to='lists.list'),\n        ),",
        "detail": "src.lists.migrations.0006_item_list",
        "documentation": {}
    },
    {
        "label": "ListsConfig",
        "kind": 6,
        "importPath": "src.lists.apps",
        "description": "src.lists.apps",
        "peekOfCode": "class ListsConfig(AppConfig):\n    default_auto_field = 'django.db.models.BigAutoField'\n    name = 'lists'",
        "detail": "src.lists.apps",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 6,
        "importPath": "src.lists.models",
        "description": "src.lists.models",
        "peekOfCode": "class List(models.Model):\n    pass\nclass Item(models.Model):\n    text = models.TextField(default=\"\")\n    list = models.ForeignKey(List, default=None, on_delete=models.CASCADE)",
        "detail": "src.lists.models",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": "src.lists.models",
        "description": "src.lists.models",
        "peekOfCode": "class Item(models.Model):\n    text = models.TextField(default=\"\")\n    list = models.ForeignKey(List, default=None, on_delete=models.CASCADE)",
        "detail": "src.lists.models",
        "documentation": {}
    },
    {
        "label": "NewListTest",
        "kind": 6,
        "importPath": "src.lists.tests",
        "description": "src.lists.tests",
        "peekOfCode": "class NewListTest(TestCase):\n    def test_can_save_a_POST_request(self):\n        self.client.post(\"/lists/new\", data={\"item_text\": \"A new list item\"})\n        self.assertEqual(Item.objects.count(), 1)\n        new_item = Item.objects.first()\n        self.assertEqual(new_item.text, \"A new list item\")\n    def test_redirects_after_POST(self):\n        response = self.client.post(\"/lists/new\", data={\"item_text\": \"A new list item\"})\n        new_list = List.objects.get()\n        self.assertRedirects(response, f\"/lists/{new_list.id}/\")",
        "detail": "src.lists.tests",
        "documentation": {}
    },
    {
        "label": "ListViewTest",
        "kind": 6,
        "importPath": "src.lists.tests",
        "description": "src.lists.tests",
        "peekOfCode": "class ListViewTest(TestCase):\n    def test_uses_list_template(self):\n        mylist = List.objects.create()\n        response = self.client.get(f\"/lists/{mylist.id}/\")\n        self.assertTemplateUsed(response, \"list.html\")\n    def test_displays_all_list_items(self):\n        correct_list = List.objects.create()\n        Item.objects.create(text=\"itemey 1\", list=correct_list)\n        Item.objects.create(text=\"itemey 2\", list=correct_list)\n        other_list = List.objects.create()",
        "detail": "src.lists.tests",
        "documentation": {}
    },
    {
        "label": "ListAndItemModelTest",
        "kind": 6,
        "importPath": "src.lists.tests",
        "description": "src.lists.tests",
        "peekOfCode": "class ListAndItemModelTest(TestCase):\n    def test_saving_and_retrieving_items(self):\n        mylist = List.objects.create()\n        first_item = Item()\n        first_item.text = \"The first (ever) list item\"\n        first_item.list = mylist\n        first_item.save()\n        second_item = Item()\n        second_item.text = \"Item the second\"\n        second_item.list = mylist",
        "detail": "src.lists.tests",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "src.lists.urls",
        "description": "src.lists.urls",
        "peekOfCode": "urlpatterns = [\n    path(\n        \"new\",\n        views.new_list,\n        name=\"new_list\",\n    ),\n    path(\n        \"<int:list_id>/\",\n        views.view_list,\n        name=\"view_list\",",
        "detail": "src.lists.urls",
        "documentation": {}
    },
    {
        "label": "home_page",
        "kind": 2,
        "importPath": "src.lists.views",
        "description": "src.lists.views",
        "peekOfCode": "def home_page(request):\n    return render(request, \"home.html\")\ndef view_list(request, list_id):\n    our_list = List.objects.get(id=list_id)\n    return render(request, \"list.html\", {\"list\": our_list})\ndef new_list(request):\n    nulist = List.objects.create()\n    Item.objects.create(text=request.POST[\"item_text\"], list=nulist)\n    return redirect(f\"/lists/{nulist.id}/\")\ndef add_item(request, list_id):",
        "detail": "src.lists.views",
        "documentation": {}
    },
    {
        "label": "view_list",
        "kind": 2,
        "importPath": "src.lists.views",
        "description": "src.lists.views",
        "peekOfCode": "def view_list(request, list_id):\n    our_list = List.objects.get(id=list_id)\n    return render(request, \"list.html\", {\"list\": our_list})\ndef new_list(request):\n    nulist = List.objects.create()\n    Item.objects.create(text=request.POST[\"item_text\"], list=nulist)\n    return redirect(f\"/lists/{nulist.id}/\")\ndef add_item(request, list_id):\n    our_list = List.objects.get(id=list_id)\n    Item.objects.create(text=request.POST[\"item_text\"], list=our_list)",
        "detail": "src.lists.views",
        "documentation": {}
    },
    {
        "label": "new_list",
        "kind": 2,
        "importPath": "src.lists.views",
        "description": "src.lists.views",
        "peekOfCode": "def new_list(request):\n    nulist = List.objects.create()\n    Item.objects.create(text=request.POST[\"item_text\"], list=nulist)\n    return redirect(f\"/lists/{nulist.id}/\")\ndef add_item(request, list_id):\n    our_list = List.objects.get(id=list_id)\n    Item.objects.create(text=request.POST[\"item_text\"], list=our_list)\n    return redirect(f\"/lists/{our_list.id}/\")",
        "detail": "src.lists.views",
        "documentation": {}
    },
    {
        "label": "add_item",
        "kind": 2,
        "importPath": "src.lists.views",
        "description": "src.lists.views",
        "peekOfCode": "def add_item(request, list_id):\n    our_list = List.objects.get(id=list_id)\n    Item.objects.create(text=request.POST[\"item_text\"], list=our_list)\n    return redirect(f\"/lists/{our_list.id}/\")",
        "detail": "src.lists.views",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "src.superlists.asgi",
        "description": "src.superlists.asgi",
        "peekOfCode": "application = get_asgi_application()",
        "detail": "src.superlists.asgi",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "BASE_DIR = Path(__file__).resolve().parent.parent\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/\n# SECURITY WARNING: keep the secret key used in production secret!\nif \"DJANGO_DEBUG_FALSE\" in os.environ:\n    SECRET_KEY = os.environ[\"DJANGO_SECRET_KEY\"]\n    DEBUG = False\n    ALLOWED_HOSTS=[os.environ[\"DJANGO_ALLOWED_HOSTS\"]]\nelse:\n    SECRET_KEY = \"django-insecure--at#+pdndd$p9w%w2-xedgwuzbhwh(ejy#6fdap(ztt8qyos&3\"",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "LOGGING",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "LOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"handlers\": {\n        \"console\": {\"class\": \"logging.StreamHandler\"},\n    },\n    \"loggers\": {\n        \"root\": {\"handlers\": [\"console\"], \"level\": \"INFO\"},\n    },\n}",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "INSTALLED_APPS",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "INSTALLED_APPS = [\n    # \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"lists\",\n]\nMIDDLEWARE = [",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "MIDDLEWARE",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "MIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"whitenoise.middleware.WhiteNoiseMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "ROOT_URLCONF",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "ROOT_URLCONF = \"superlists.urls\"\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "TEMPLATES",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "TEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "WSGI_APPLICATION",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "WSGI_APPLICATION = \"superlists.wsgi.application\"\n# Database\n# https://docs.djangoproject.com/en/5.0/ref/settings/#databases\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",\n    }\n}\n# Password validation",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "DATABASES",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "DATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",\n    }\n}\n# Password validation\n# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "AUTH_PASSWORD_VALIDATORS",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "AUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_CODE",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "LANGUAGE_CODE = \"en-us\"\nTIME_ZONE = \"UTC\"\nUSE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/5.0/howto/static-files/\nSTATIC_URL = \"static/\"\nSTATIC_ROOT = BASE_DIR / \"static\"\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "TIME_ZONE",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "TIME_ZONE = \"UTC\"\nUSE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/5.0/howto/static-files/\nSTATIC_URL = \"static/\"\nSTATIC_ROOT = BASE_DIR / \"static\"\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "USE_I18N",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "USE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/5.0/howto/static-files/\nSTATIC_URL = \"static/\"\nSTATIC_ROOT = BASE_DIR / \"static\"\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "USE_TZ",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "USE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/5.0/howto/static-files/\nSTATIC_URL = \"static/\"\nSTATIC_ROOT = BASE_DIR / \"static\"\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "STATIC_URL",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "STATIC_URL = \"static/\"\nSTATIC_ROOT = BASE_DIR / \"static\"\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "STATIC_ROOT",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "STATIC_ROOT = BASE_DIR / \"static\"\n# Default primary key field type\n# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_AUTO_FIELD",
        "kind": 5,
        "importPath": "src.superlists.settings",
        "description": "src.superlists.settings",
        "peekOfCode": "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
        "detail": "src.superlists.settings",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "src.superlists.urls",
        "description": "src.superlists.urls",
        "peekOfCode": "urlpatterns = [\n    path(\"\", views.home_page, name=\"home\"),\n    path(\"lists/\", include(\"lists.urls\")),\n]",
        "detail": "src.superlists.urls",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "src.superlists.wsgi",
        "description": "src.superlists.wsgi",
        "peekOfCode": "application = get_wsgi_application()",
        "detail": "src.superlists.wsgi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.manage",
        "description": "src.manage",
        "peekOfCode": "def main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'superlists.settings')\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"",
        "detail": "src.manage",
        "documentation": {}
    }
]